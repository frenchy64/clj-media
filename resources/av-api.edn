{:functions ({:args [], :ret {:spelling "long long"}, :function/args [], :symbol "av_gettime", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_gettime, :raw-comment "/**\n * Get the current time in microseconds.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_gettime"} {:args [], :ret {:spelling "long long"}, :function/args [], :symbol "av_gettime_relative", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_gettime_relative, :raw-comment "/**\n * Get the current time in microseconds since some unspecified starting point.\n * On platforms that support it, the time comes from a monotonic clock\n * This property makes this time source ideal for measuring relative time.\n * The returned values may not be monotonic on platforms where a monotonic\n * clock is not available.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_gettime_relative"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "av_gettime_relative_is_monotonic", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_gettime_relative_is_monotonic, :raw-comment "/**\n * Indicates with a boolean result if the av_gettime_relative() time source\n * is monotonic.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_gettime_relative_is_monotonic"} {:args [{:spelling "usec", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_usleep", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_usleep, :raw-comment "/**\n * Sleep for a period of time.  Although the duration is expressed in\n * microseconds, the actual delay may be rounded to the precision of the\n * system timer.\n *\n * @param  usec Number of microseconds to sleep.\n * @return zero on success or (negative) error code.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_usleep"} {:args [{:spelling "errnum", :type "int"} {:spelling "errbuf", :type "char *"} {:spelling "errbuf_size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strerror", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strerror, :raw-comment "/**\n * Put a description of the AVERROR code errnum in errbuf.\n * In case of failure the global variable errno is set to indicate the\n * error. Even in case of failure av_strerror() will print a generic\n * error message indicating the errnum provided to errbuf.\n *\n * @param errnum      error code to describe\n * @param errbuf      buffer to which description is written\n * @param errbuf_size the size in bytes of errbuf\n * @return 0 on success, a negative value if a description for errnum\n * cannot be found\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strerror"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avutil_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avutil_version, :raw-comment "/**\n * Return the LIBAVUTIL_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avutil_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "av_version_info", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_version_info, :raw-comment "/**\n * Return an informative version string. This usually is the actual release\n * version number or a git commit description. This string has no fixed format\n * and can change any time. It should never be parsed by code.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_version_info"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avutil_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avutil_configuration, :raw-comment "/**\n * Return the libavutil build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avutil_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avutil_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avutil_license, :raw-comment "/**\n * Return the libavutil license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avutil_license"} {:args [{:spelling "media_type", :type "enum AVMediaType"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_get_media_type_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_media_type_string, :raw-comment "/**\n * Return a string describing the media_type enum, NULL if media_type\n * is unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_media_type_string"} {:args [{:spelling "pict_type", :type "enum AVPictureType"}], :ret {:spelling "char"}, :function/args [:coffi.mem/int], :symbol "av_get_picture_type_char", :function/ret :coffi.mem/char, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_picture_type_char, :raw-comment "/**\n * Return a single letter to describe the given picture type\n * pict_type.\n *\n * @param[in] pict_type the picture type @return a single character\n * representing the picture type, '?' if pict_type is unknown\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_picture_type_char"} {:args [{:spelling "v", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_log2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_log2"} {:args [{:spelling "v", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_log2_16bit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log2_16bit, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_log2_16bit"} {:args [{:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/long], :symbol "av_malloc", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_malloc, :raw-comment "/**\n * Allocate a memory block with alignment suitable for all memory accesses\n * (including vectors if available on the CPU).\n *\n * @param size Size in bytes for the memory block to be allocated\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n * @see av_mallocz()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_malloc"} {:args [{:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/long], :symbol "av_mallocz", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mallocz, :raw-comment "/**\n * Allocate a memory block with alignment suitable for all memory accesses\n * (including vectors if available on the CPU) and zero all the bytes of the\n * block.\n *\n * @param size Size in bytes for the memory block to be allocated\n * @return Pointer to the allocated block, or `NULL` if it cannot be allocated\n * @see av_malloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mallocz"} {:args [{:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_malloc_array", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_malloc_array, :raw-comment "/**\n * Allocate a memory block for an array with av_malloc().\n *\n * The allocated memory will have size `size * nmemb` bytes.\n *\n * @param nmemb Number of element\n * @param size  Size of a single element\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n * @see av_malloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_malloc_array"} {:args [{:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_mallocz_array", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mallocz_array, :raw-comment "/**\n * Allocate a memory block for an array with av_mallocz().\n *\n * The allocated memory will have size `size * nmemb` bytes.\n *\n * @param nmemb Number of elements\n * @param size  Size of the single element\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n *\n * @see av_mallocz()\n * @see av_malloc_array()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mallocz_array"} {:args [{:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_calloc", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_calloc, :raw-comment "/**\n * Non-inlined equivalent of av_mallocz_array().\n *\n * Created for symmetry with the calloc() C function.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_calloc"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/long], :symbol "av_realloc", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_realloc, :raw-comment "/**\n * Allocate, reallocate, or free a block of memory.\n *\n * If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n * zero, free the memory block pointed to by `ptr`. Otherwise, expand or\n * shrink that block of memory according to `size`.\n *\n * @param ptr  Pointer to a memory block already allocated with\n *             av_realloc() or `NULL`\n * @param size Size in bytes of the memory block to be allocated or\n *             reallocated\n *\n * @return Pointer to a newly-reallocated block or `NULL` if the block\n *         cannot be reallocated or the function is used to free the memory block\n *\n * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be\n *          correctly aligned.\n * @see av_fast_realloc()\n * @see av_reallocp()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_realloc"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/long], :symbol "av_reallocp", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_reallocp, :raw-comment "/**\n * Allocate, reallocate, or free a block of memory through a pointer to a\n * pointer.\n *\n * If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n * zero, free the memory block pointed to by `*ptr`. Otherwise, expand or\n * shrink that block of memory according to `size`.\n *\n * @param[in,out] ptr  Pointer to a pointer to a memory block already allocated\n *                     with av_realloc(), or a pointer to `NULL`. The pointer\n *                     is updated on success, or freed on failure.\n * @param[in]     size Size in bytes for the memory block to be allocated or\n *                     reallocated\n *\n * @return Zero on success, an AVERROR error code on failure\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_reallocp"} {:args [{:spelling "ptr", :type "void *"} {:spelling "nelem", :type "unsigned long"} {:spelling "elsize", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long], :symbol "av_realloc_f", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_realloc_f, :raw-comment "/**\n * Allocate, reallocate, or free a block of memory.\n *\n * This function does the same thing as av_realloc(), except:\n * - It takes two size arguments and allocates `nelem * elsize` bytes,\n *   after checking the result of the multiplication for integer overflow.\n * - It frees the input block in case of failure, thus avoiding the memory\n *   leak with the classic\n *   @code{.c}\n *   buf = realloc(buf);\n *   if (!buf)\n *       return -1;\n *   @endcode\n *   pattern.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_realloc_f"} {:args [{:spelling "ptr", :type "void *"} {:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long], :symbol "av_realloc_array", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_realloc_array, :raw-comment "/**\n * Allocate, reallocate, or free an array.\n *\n * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If\n * `nmemb` is zero, free the memory block pointed to by `ptr`.\n *\n * @param ptr   Pointer to a memory block already allocated with\n *              av_realloc() or `NULL`\n * @param nmemb Number of elements in the array\n * @param size  Size of the single element of the array\n *\n * @return Pointer to a newly-reallocated block or NULL if the block\n *         cannot be reallocated or the function is used to free the memory block\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned.\n * @see av_reallocp_array()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_realloc_array"} {:args [{:spelling "ptr", :type "void *"} {:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/long :coffi.mem/long], :symbol "av_reallocp_array", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_reallocp_array, :raw-comment "/**\n * Allocate, reallocate, or free an array through a pointer to a pointer.\n *\n * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is\n * zero, free the memory block pointed to by `*ptr`.\n *\n * @param[in,out] ptr   Pointer to a pointer to a memory block already\n *                      allocated with av_realloc(), or a pointer to `NULL`.\n *                      The pointer is updated on success, or freed on failure.\n * @param[in]     nmemb Number of elements\n * @param[in]     size  Size of the single element\n *\n * @return Zero on success, an AVERROR error code on failure\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_reallocp_array"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned int *"} {:spelling "min_size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long], :symbol "av_fast_realloc", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fast_realloc, :raw-comment "/**\n * Reallocate the given buffer if it is not large enough, otherwise do nothing.\n *\n * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.\n *\n * If the given buffer is not large enough, and reallocation fails, `NULL` is\n * returned and `*size` is set to 0, but the original buffer is not changed or\n * freed.\n *\n * A typical use pattern follows:\n *\n * @code{.c}\n * uint8_t *buf = ...;\n * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);\n * if (!new_buf) {\n *     // Allocation failed; clean up original buffer\n *     av_freep(&buf);\n *     return AVERROR(ENOMEM);\n * }\n * @endcode\n *\n * @param[in,out] ptr      Already allocated buffer, or `NULL`\n * @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `ptr`\n * @return `ptr` if the buffer is large enough, a pointer to newly reallocated\n *         buffer if the buffer was not large enough, or `NULL` in case of\n *         error\n * @see av_realloc()\n * @see av_fast_malloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fast_realloc"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned int *"} {:spelling "min_size", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long], :symbol "av_fast_malloc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fast_malloc, :raw-comment "/**\n * Allocate a buffer, reusing the given one if large enough.\n *\n * Contrary to av_fast_realloc(), the current buffer contents might not be\n * preserved and on error the old buffer is freed, thus no special handling to\n * avoid memleaks is necessary.\n *\n * `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n * `size_needed` is greater than 0.\n *\n * @code{.c}\n * uint8_t *buf = ...;\n * av_fast_malloc(&buf, &current_size, size_needed);\n * if (!buf) {\n *     // Allocation failed; buf already freed\n *     return AVERROR(ENOMEM);\n * }\n * @endcode\n *\n * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n *                         `*ptr` will be overwritten with pointer to new\n *                         buffer on success or `NULL` on failure\n * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `*ptr`\n * @see av_realloc()\n * @see av_fast_mallocz()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fast_malloc"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned int *"} {:spelling "min_size", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long], :symbol "av_fast_mallocz", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fast_mallocz, :raw-comment "/**\n * Allocate and clear a buffer, reusing the given one if large enough.\n *\n * Like av_fast_malloc(), but all newly allocated space is initially cleared.\n * Reused buffer is not cleared.\n *\n * `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n * `size_needed` is greater than 0.\n *\n * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n *                         `*ptr` will be overwritten with pointer to new\n *                         buffer on success or `NULL` on failure\n * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `*ptr`\n * @see av_fast_malloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fast_mallocz"} {:args [{:spelling "ptr", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "av_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_free, :raw-comment "/**\n * Free a memory block which has been allocated with a function of av_malloc()\n * or av_realloc() family.\n *\n * @param ptr Pointer to the memory block which should be freed.\n *\n * @note `ptr = NULL` is explicitly allowed.\n * @note It is recommended that you use av_freep() instead, to prevent leaving\n *       behind dangling pointers.\n * @see av_freep()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_free"} {:args [{:spelling "ptr", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "av_freep", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_freep, :raw-comment "/**\n * Free a memory block which has been allocated with a function of av_malloc()\n * or av_realloc() family, and set the pointer pointing to it to `NULL`.\n *\n * @code{.c}\n * uint8_t *buf = av_malloc(16);\n * av_free(buf);\n * // buf now contains a dangling pointer to freed memory, and accidental\n * // dereference of buf will result in a use-after-free, which may be a\n * // security risk.\n *\n * uint8_t *buf = av_malloc(16);\n * av_freep(&buf);\n * // buf is now NULL, and accidental dereference will only result in a\n * // NULL-pointer dereference.\n * @endcode\n *\n * @param ptr Pointer to the pointer to the memory block which should be freed\n * @note `*ptr = NULL` is safe and leads to no action.\n * @see av_free()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_freep"} {:args [{:spelling "s", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_strdup", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strdup, :raw-comment "/**\n * Duplicate a string.\n *\n * @param s String to be duplicated\n * @return Pointer to a newly-allocated string containing a\n *         copy of `s` or `NULL` if the string cannot be allocated\n * @see av_strndup()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strdup"} {:args [{:spelling "s", :type "const char *"} {:spelling "len", :type "unsigned long"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strndup", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strndup, :raw-comment "/**\n * Duplicate a substring of a string.\n *\n * @param s   String to be duplicated\n * @param len Maximum length of the resulting string (not counting the\n *            terminating byte)\n * @return Pointer to a newly-allocated string containing a\n *         substring of `s` or `NULL` if the string cannot be allocated\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strndup"} {:args [{:spelling "p", :type "const void *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/long], :symbol "av_memdup", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_memdup, :raw-comment "/**\n * Duplicate a buffer with av_malloc().\n *\n * @param p    Buffer to be duplicated\n * @param size Size in bytes of the buffer copied\n * @return Pointer to a newly allocated buffer containing a\n *         copy of `p` or `NULL` if the buffer cannot be allocated\n */", :kind "CXCursor_FunctionDecl", :spelling "av_memdup"} {:args [{:spelling "dst", :type "unsigned char *"} {:spelling "back", :type "int"} {:spelling "cnt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_memcpy_backptr", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_memcpy_backptr, :raw-comment "/**\n * Overlapping memcpy() implementation.\n *\n * @param dst  Destination buffer\n * @param back Number of bytes back to start copying (i.e. the initial size of\n *             the overlapping window); must be > 0\n * @param cnt  Number of bytes to copy; must be >= 0\n *\n * @note `cnt > back` is valid, this will copy the bytes we just copied,\n *       thus creating a repeating pattern with a period length of `back`.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_memcpy_backptr"} {:args [{:spelling "tab_ptr", :type "void *"} {:spelling "nb_ptr", :type "int *"} {:spelling "elem", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/pointer], :symbol "av_dynarray_add", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dynarray_add, :raw-comment "/**\n * Add the pointer to an element to a dynamic array.\n *\n * The array to grow is supposed to be an array of pointers to\n * structures, and the element to add must be a pointer to an already\n * allocated structure.\n *\n * The array is reallocated when its size reaches powers of 2.\n * Therefore, the amortized cost of adding an element is constant.\n *\n * In case of success, the pointer to the array is updated in order to\n * point to the new grown array, and the number pointed to by `nb_ptr`\n * is incremented.\n * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n * `*nb_ptr` is set to 0.\n *\n * @param[in,out] tab_ptr Pointer to the array to grow\n * @param[in,out] nb_ptr  Pointer to the number of elements in the array\n * @param[in]     elem    Element to add\n * @see av_dynarray_add_nofree(), av_dynarray2_add()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dynarray_add"} {:args [{:spelling "tab_ptr", :type "void *"} {:spelling "nb_ptr", :type "int *"} {:spelling "elem", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/pointer], :symbol "av_dynarray_add_nofree", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dynarray_add_nofree, :raw-comment "/**\n * Add an element to a dynamic array.\n *\n * Function has the same functionality as av_dynarray_add(),\n * but it doesn't free memory on fails. It returns error code\n * instead and leave current buffer untouched.\n *\n * @return >=0 on success, negative otherwise\n * @see av_dynarray_add(), av_dynarray2_add()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dynarray_add_nofree"} {:args [{:spelling "tab_ptr", :type "void **"} {:spelling "nb_ptr", :type "int *"} {:spelling "elem_size", :type "unsigned long"} {:spelling "elem_data", :type "const unsigned char *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_dynarray2_add", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dynarray2_add, :raw-comment "/**\n * Add an element of size `elem_size` to a dynamic array.\n *\n * The array is reallocated when its number of elements reaches powers of 2.\n * Therefore, the amortized cost of adding an element is constant.\n *\n * In case of success, the pointer to the array is updated in order to\n * point to the new grown array, and the number pointed to by `nb_ptr`\n * is incremented.\n * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n * `*nb_ptr` is set to 0.\n *\n * @param[in,out] tab_ptr   Pointer to the array to grow\n * @param[in,out] nb_ptr    Pointer to the number of elements in the array\n * @param[in]     elem_size Size in bytes of an element in the array\n * @param[in]     elem_data Pointer to the data of the element to add. If\n *                          `NULL`, the space of the newly added element is\n *                          allocated but left uninitialized.\n *\n * @return Pointer to the data of the element to copy in the newly allocated\n *         space\n * @see av_dynarray_add(), av_dynarray_add_nofree()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dynarray2_add"} {:args [{:spelling "max", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [:coffi.mem/long], :symbol "av_max_alloc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_max_alloc, :raw-comment "/**\n * Set the maximum size that may be allocated in one block.\n *\n * The value specified with this function is effective for all libavutil's @ref\n * lavu_mem_funcs \"heap management functions.\"\n *\n * By default, the max value is defined as `INT_MAX`.\n *\n * @param max Value to be set as the new maximum size\n *\n * @warning Exercise extreme caution when using this function. Don't touch\n *          this if you do not understand the full consequence of doing so.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_max_alloc"} {:args [{:spelling "dst_num", :type "int *"} {:spelling "dst_den", :type "int *"} {:spelling "num", :type "long long"} {:spelling "den", :type "long long"} {:spelling "max", :type "long long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long :coffi.mem/long :coffi.mem/long], :symbol "av_reduce", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_reduce, :raw-comment "/**\n * Reduce a fraction.\n *\n * This is useful for framerate calculations.\n *\n * @param[out] dst_num Destination numerator\n * @param[out] dst_den Destination denominator\n * @param[in]      num Source numerator\n * @param[in]      den Source denominator\n * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`\n * @return 1 if the operation is exact, 0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_reduce"} {:args [{:spelling "b", :type "struct AVRational"} {:spelling "c", :type "struct AVRational"}], :ret {:spelling "struct AVRational"}, :function/args [:clong/AVRational :clong/AVRational], :symbol "av_mul_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mul_q, :raw-comment "/**\n * Multiply two rationals.\n * @param b First rational\n * @param c Second rational\n * @return b*c\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mul_q"} {:args [{:spelling "b", :type "struct AVRational"} {:spelling "c", :type "struct AVRational"}], :ret {:spelling "struct AVRational"}, :function/args [:clong/AVRational :clong/AVRational], :symbol "av_div_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_div_q, :raw-comment "/**\n * Divide one rational by another.\n * @param b First rational\n * @param c Second rational\n * @return b/c\n */", :kind "CXCursor_FunctionDecl", :spelling "av_div_q"} {:args [{:spelling "b", :type "struct AVRational"} {:spelling "c", :type "struct AVRational"}], :ret {:spelling "struct AVRational"}, :function/args [:clong/AVRational :clong/AVRational], :symbol "av_add_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_add_q, :raw-comment "/**\n * Add two rationals.\n * @param b First rational\n * @param c Second rational\n * @return b+c\n */", :kind "CXCursor_FunctionDecl", :spelling "av_add_q"} {:args [{:spelling "b", :type "struct AVRational"} {:spelling "c", :type "struct AVRational"}], :ret {:spelling "struct AVRational"}, :function/args [:clong/AVRational :clong/AVRational], :symbol "av_sub_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sub_q, :raw-comment "/**\n * Subtract one rational from another.\n * @param b First rational\n * @param c Second rational\n * @return b-c\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sub_q"} {:args [{:spelling "d", :type "double"} {:spelling "max", :type "int"}], :ret {:spelling "struct AVRational"}, :function/args [:coffi.mem/double :coffi.mem/int], :symbol "av_d2q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_d2q, :raw-comment "/**\n * Convert a double precision floating point number to a rational.\n *\n * In case of infinity, the returned value is expressed as `{1, 0}` or\n * `{-1, 0}` depending on the sign.\n *\n * @param d   `double` to convert\n * @param max Maximum allowed numerator and denominator\n * @return `d` in AVRational form\n * @see av_q2d()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_d2q"} {:args [{:spelling "q", :type "struct AVRational"} {:spelling "q1", :type "struct AVRational"} {:spelling "q2", :type "struct AVRational"}], :ret {:spelling "int"}, :function/args [:clong/AVRational :clong/AVRational :clong/AVRational], :symbol "av_nearer_q", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_nearer_q, :raw-comment "/**\n * Find which of the two rationals is closer to another rational.\n *\n * @param q     Rational to be compared against\n * @param q1,q2 Rationals to be tested\n * @return One of the following values:\n *         - 1 if `q1` is nearer to `q` than `q2`\n *         - -1 if `q2` is nearer to `q` than `q1`\n *         - 0 if they have the same distance\n */", :kind "CXCursor_FunctionDecl", :spelling "av_nearer_q"} {:args [{:spelling "q", :type "struct AVRational"} {:spelling "q_list", :type "const struct AVRational *"}], :ret {:spelling "int"}, :function/args [:clong/AVRational [:coffi.mem/pointer :clong/AVRational]], :symbol "av_find_nearest_q_idx", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_nearest_q_idx, :raw-comment "/**\n * Find the value in a list of rationals nearest a given reference rational.\n *\n * @param q      Reference rational\n * @param q_list Array of rationals terminated by `{0, 0}`\n * @return Index of the nearest value found in the array\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_nearest_q_idx"} {:args [{:spelling "q", :type "struct AVRational"}], :ret {:spelling "unsigned int"}, :function/args [:clong/AVRational], :symbol "av_q2intfloat", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_q2intfloat, :raw-comment "/**\n * Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point\n * format.\n *\n * @param q Rational to be converted\n * @return Equivalent floating-point value, expressed as an unsigned 32-bit\n *         integer.\n * @note The returned value is platform-indepedant.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_q2intfloat"} {:args [{:spelling "a", :type "struct AVRational"} {:spelling "b", :type "struct AVRational"} {:spelling "max_den", :type "int"} {:spelling "def", :type "struct AVRational"}], :ret {:spelling "struct AVRational"}, :function/args [:clong/AVRational :clong/AVRational :coffi.mem/int :clong/AVRational], :symbol "av_gcd_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_gcd_q, :raw-comment "/**\n * Return the best rational so that a and b are multiple of it.\n * If the resulting denominator is larger than max_den, return def.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_gcd_q"} {:args [{:spelling "a", :type "long long"} {:spelling "b", :type "long long"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_gcd", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_gcd, :raw-comment "/**\n * Compute the greatest common divisor of two integer operands.\n *\n * @param a,b Operands\n * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;\n * if a == 0 and b == 0, returns 0.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_gcd"} {:args [{:spelling "a", :type "long long"} {:spelling "b", :type "long long"} {:spelling "c", :type "long long"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :coffi.mem/long :coffi.mem/long], :symbol "av_rescale", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rescale, :raw-comment "/**\n * Rescale a 64-bit integer with rounding to nearest.\n *\n * The operation is mathematically equivalent to `a * b / c`, but writing that\n * directly can overflow.\n *\n * This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.\n *\n * @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rescale"} {:args [{:spelling "a", :type "long long"} {:spelling "b", :type "long long"} {:spelling "c", :type "long long"} {:spelling "rnd", :type "enum AVRounding"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :coffi.mem/long :coffi.mem/long :coffi.mem/int], :symbol "av_rescale_rnd", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rescale_rnd, :raw-comment "/**\n * Rescale a 64-bit integer with specified rounding.\n *\n * The operation is mathematically equivalent to `a * b / c`, but writing that\n * directly can overflow, and does not support different rounding methods.\n * If the result is not representable then INT64_MIN is returned.\n *\n * @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rescale_rnd"} {:args [{:spelling "a", :type "long long"} {:spelling "bq", :type "struct AVRational"} {:spelling "cq", :type "struct AVRational"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :clong/AVRational :clong/AVRational], :symbol "av_rescale_q", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rescale_q, :raw-comment "/**\n * Rescale a 64-bit integer by 2 rational numbers.\n *\n * The operation is mathematically equivalent to `a * bq / cq`.\n *\n * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.\n *\n * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rescale_q"} {:args [{:spelling "a", :type "long long"} {:spelling "bq", :type "struct AVRational"} {:spelling "cq", :type "struct AVRational"} {:spelling "rnd", :type "enum AVRounding"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :clong/AVRational :clong/AVRational :coffi.mem/int], :symbol "av_rescale_q_rnd", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rescale_q_rnd, :raw-comment "/**\n * Rescale a 64-bit integer by 2 rational numbers with specified rounding.\n *\n * The operation is mathematically equivalent to `a * bq / cq`.\n *\n * @see av_rescale(), av_rescale_rnd(), av_rescale_q()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rescale_q_rnd"} {:args [{:spelling "ts_a", :type "long long"} {:spelling "tb_a", :type "struct AVRational"} {:spelling "ts_b", :type "long long"} {:spelling "tb_b", :type "struct AVRational"}], :ret {:spelling "int"}, :function/args [:coffi.mem/long :clong/AVRational :coffi.mem/long :clong/AVRational], :symbol "av_compare_ts", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_compare_ts, :raw-comment "/**\n * Compare two timestamps each in its own time base.\n *\n * @return One of the following values:\n *         - -1 if `ts_a` is before `ts_b`\n *         - 1 if `ts_a` is after `ts_b`\n *         - 0 if they represent the same position\n *\n * @warning\n * The result of the function is undefined if one of the timestamps is outside\n * the `int64_t` range when represented in the other's timebase.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_compare_ts"} {:args [{:spelling "a", :type "unsigned long long"} {:spelling "b", :type "unsigned long long"} {:spelling "mod", :type "unsigned long long"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/long :coffi.mem/long :coffi.mem/long], :symbol "av_compare_mod", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_compare_mod, :raw-comment "/**\n * Compare the remainders of two integer operands divided by a common divisor.\n *\n * In other words, compare the least significant `log2(mod)` bits of integers\n * `a` and `b`.\n *\n * @code{.c}\n * av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)\n * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)\n * @endcode\n *\n * @param a,b Operands\n * @param mod Divisor; must be a power of 2\n * @return\n *         - a negative value if `a % mod < b % mod`\n *         - a positive value if `a % mod > b % mod`\n *         - zero             if `a % mod == b % mod`\n */", :kind "CXCursor_FunctionDecl", :spelling "av_compare_mod"} {:args [{:spelling "in_tb", :type "struct AVRational"} {:spelling "in_ts", :type "long long"} {:spelling "fs_tb", :type "struct AVRational"} {:spelling "duration", :type "int"} {:spelling "last", :type "long long *"} {:spelling "out_tb", :type "struct AVRational"}], :ret {:spelling "long long"}, :function/args [:clong/AVRational :coffi.mem/long :clong/AVRational :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long] :clong/AVRational], :symbol "av_rescale_delta", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rescale_delta, :raw-comment "/**\n * Rescale a timestamp while preserving known durations.\n *\n * This function is designed to be called per audio packet to scale the input\n * timestamp to a different time base. Compared to a simple av_rescale_q()\n * call, this function is robust against possible inconsistent frame durations.\n *\n * The `last` parameter is a state variable that must be preserved for all\n * subsequent calls for the same stream. For the first call, `*last` should be\n * initialized to #AV_NOPTS_VALUE.\n *\n * @param[in]     in_tb    Input time base\n * @param[in]     in_ts    Input timestamp\n * @param[in]     fs_tb    Duration time base; typically this is finer-grained\n *                         (greater) than `in_tb` and `out_tb`\n * @param[in]     duration Duration till the next call to this function (i.e.\n *                         duration of the current packet/frame)\n * @param[in,out] last     Pointer to a timestamp expressed in terms of\n *                         `fs_tb`, acting as a state variable\n * @param[in]     out_tb   Output timebase\n * @return        Timestamp expressed in terms of `out_tb`\n *\n * @note In the context of this function, \"duration\" is in term of samples, not\n *       seconds.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rescale_delta"} {:args [{:spelling "ts_tb", :type "struct AVRational"} {:spelling "ts", :type "long long"} {:spelling "inc_tb", :type "struct AVRational"} {:spelling "inc", :type "long long"}], :ret {:spelling "long long"}, :function/args [:clong/AVRational :coffi.mem/long :clong/AVRational :coffi.mem/long], :symbol "av_add_stable", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_add_stable, :raw-comment "/**\n * Add a value to a timestamp.\n *\n * This function guarantees that when the same value is repeatly added that\n * no accumulation of rounding errors occurs.\n *\n * @param[in] ts     Input timestamp\n * @param[in] ts_tb  Input timestamp time base\n * @param[in] inc    Value to be added\n * @param[in] inc_tb Time base of `inc`\n */", :kind "CXCursor_FunctionDecl", :spelling "av_add_stable"} {:args [{:spelling "avcl", :type "void *"} {:spelling "level", :type "int"} {:spelling "fmt", :type "const char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_log", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log, :raw-comment "/**\n * Send the specified message to the log if the level is less than or equal\n * to the current av_log_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log_set_callback\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct or NULL if general log.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log"} {:args [{:spelling "avcl", :type "void *"} {:spelling "initial_level", :type "int"} {:spelling "subsequent_level", :type "int"} {:spelling "state", :type "int *"} {:spelling "fmt", :type "const char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_log_once", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_once, :raw-comment "/**\n * Send the specified message to the log once with the initial_level and then with\n * the subsequent_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct or NULL if general log.\n * @param initial_level importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\" for the first occurance.\n * @param subsequent_level importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\" after the first occurance.\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param state a variable to keep trak of if a message has already been printed\n *        this must be initialized to 0 before the first use. The same state\n *        must not be accessed by 2 Threads simultaneously.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_once"} {:args [{:spelling "avcl", :type "void *"} {:spelling "level", :type "int"} {:spelling "fmt", :type "const char *"} {:spelling "vl", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_vlog", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vlog, :raw-comment "/**\n * Send the specified message to the log if the level is less than or equal\n * to the current av_log_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log_set_callback\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param vl The arguments referenced by the format string.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vlog"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "av_log_get_level", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_get_level, :raw-comment "/**\n * Get the current log level\n *\n * @see lavu_log_constants\n *\n * @return Current log level\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_get_level"} {:args [{:spelling "level", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "av_log_set_level", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_set_level, :raw-comment "/**\n * Set the log level\n *\n * @see lavu_log_constants\n *\n * @param level Logging level\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_set_level"} {:args [{:spelling "callback", :type "void (*)(void *, int, const char *, char *)"}], :ret {:spelling "void"}, :function/args [[:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/void]], :symbol "av_log_set_callback", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_set_callback, :raw-comment "/**\n * Set the logging callback\n *\n * @note The callback must be thread safe, even if the application does not use\n *       threads itself as some codecs are multithreaded.\n *\n * @see av_log_default_callback\n *\n * @param callback A logging function with a compatible signature.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_set_callback"} {:args [{:spelling "avcl", :type "void *"} {:spelling "level", :type "int"} {:spelling "fmt", :type "const char *"} {:spelling "vl", :type "char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_log_default_callback", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_default_callback, :raw-comment "/**\n * Default logging callback\n *\n * It prints the message to stderr, optionally colorizing it.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param vl The arguments referenced by the format string.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_default_callback"} {:args [{:spelling "ctx", :type "void *"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/pointer], :symbol "av_default_item_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_default_item_name, :raw-comment "/**\n * Return the context name\n *\n * @param  ctx The AVClass context\n *\n * @return The AVClass class_name\n */", :kind "CXCursor_FunctionDecl", :spelling "av_default_item_name"} {:args [{:spelling "ptr", :type "void *"}], :ret {:spelling "AVClassCategory"}, :function/args [:coffi.mem/pointer], :symbol "av_default_get_category", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_default_get_category, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_default_get_category"} {:args [{:spelling "ptr", :type "void *"} {:spelling "level", :type "int"} {:spelling "fmt", :type "const char *"} {:spelling "vl", :type "char *"} {:spelling "line", :type "char *"} {:spelling "line_size", :type "int"} {:spelling "print_prefix", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_log_format_line", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_format_line, :raw-comment "/**\n * Format a line of log the same way as the default callback.\n * @param line          buffer to receive the formatted line\n * @param line_size     size of the buffer\n * @param print_prefix  used to store whether the prefix must be printed;\n *                      must point to a persistent integer initially set to 1\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_format_line"} {:args [{:spelling "ptr", :type "void *"} {:spelling "level", :type "int"} {:spelling "fmt", :type "const char *"} {:spelling "vl", :type "char *"} {:spelling "line", :type "char *"} {:spelling "line_size", :type "int"} {:spelling "print_prefix", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_log_format_line2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_format_line2, :raw-comment "/**\n * Format a line of log the same way as the default callback.\n * @param line          buffer to receive the formatted line;\n *                      may be NULL if line_size is 0\n * @param line_size     size of the buffer; at most line_size-1 characters will\n *                      be written to the buffer, plus one null terminator\n * @param print_prefix  used to store whether the prefix must be printed;\n *                      must point to a persistent integer initially set to 1\n * @return Returns a negative value if an error occurred, otherwise returns\n *         the number of characters that would have been written for a\n *         sufficiently large buffer, not including the terminating null\n *         character. If the return value is not less than line_size, it means\n *         that the log message was truncated to fit the buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_log_format_line2"} {:args [{:spelling "arg", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "av_log_set_flags", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_set_flags, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_log_set_flags"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "av_log_get_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_log_get_flags, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_log_get_flags"} {:args [{:spelling "elsize", :type "unsigned int"} {:spelling "list", :type "const void *"} {:spelling "term", :type "unsigned long long"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int :coffi.mem/pointer :coffi.mem/long], :symbol "av_int_list_length_for_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_int_list_length_for_size, :raw-comment "/**\n * Compute the length of an integer list.\n *\n * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)\n * @param term    list terminator (usually 0 or -1)\n * @param list    pointer to the list\n * @return  length of the list, in elements, not counting the terminator\n */", :kind "CXCursor_FunctionDecl", :spelling "av_int_list_length_for_size"} {:args [{:spelling "path", :type "const char *"} {:spelling "mode", :type "const char *"}], :ret {:spelling "struct __sFILE *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_fopen_utf8", :function/ret [:coffi.mem/pointer :clong/__sFILE], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fopen_utf8, :raw-comment "/**\n * Open a file using a UTF-8 filename.\n * The API of this function matches POSIX fopen(), errors are returned through\n * errno.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fopen_utf8"} {:args [], :ret {:spelling "struct AVRational"}, :function/args [], :symbol "av_get_time_base_q", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_time_base_q, :raw-comment "/**\n * Return the fractional representation of the internal time base.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_time_base_q"} {:args [{:spelling "buf", :type "char *"} {:spelling "fourcc", :type "unsigned int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_fourcc_make_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fourcc_make_string, :raw-comment "/**\n * Fill the provided buffer with a string containing a FourCC (four-character\n * code) representation.\n *\n * @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE\n * @param fourcc the fourcc to represent\n * @return the buffer in input\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fourcc_make_string"} {:args [{:spelling "size", :type "unsigned int"}], :ret {:spelling "struct AVFifoBuffer *"}, :function/args [:coffi.mem/int], :symbol "av_fifo_alloc", :function/ret [:coffi.mem/pointer :clong/AVFifoBuffer], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_alloc, :raw-comment "/**\n * Initialize an AVFifoBuffer.\n * @param size of FIFO\n * @return AVFifoBuffer or NULL in case of memory allocation failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_alloc"} {:args [{:spelling "nmemb", :type "unsigned long"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "struct AVFifoBuffer *"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_fifo_alloc_array", :function/ret [:coffi.mem/pointer :clong/AVFifoBuffer], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_alloc_array, :raw-comment "/**\n * Initialize an AVFifoBuffer.\n * @param nmemb number of elements\n * @param size  size of the single element\n * @return AVFifoBuffer or NULL in case of memory allocation failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_alloc_array"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer]], :symbol "av_fifo_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_free, :raw-comment "/**\n * Free an AVFifoBuffer.\n * @param f AVFifoBuffer to free\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_free"} {:args [{:spelling "f", :type "struct AVFifoBuffer **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFifoBuffer]]], :symbol "av_fifo_freep", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_freep, :raw-comment "/**\n * Free an AVFifoBuffer and reset pointer to NULL.\n * @param f AVFifoBuffer to free\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_freep"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer]], :symbol "av_fifo_reset", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_reset, :raw-comment "/**\n * Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.\n * @param f AVFifoBuffer to reset\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_reset"} {:args [{:spelling "f", :type "const struct AVFifoBuffer *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer]], :symbol "av_fifo_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_size, :raw-comment "/**\n * Return the amount of data in bytes in the AVFifoBuffer, that is the\n * amount of data you can read from it.\n * @param f AVFifoBuffer to read from\n * @return size\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_size"} {:args [{:spelling "f", :type "const struct AVFifoBuffer *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer]], :symbol "av_fifo_space", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_space, :raw-comment "/**\n * Return the amount of space in bytes in the AVFifoBuffer, that is the\n * amount of data you can write into it.\n * @param f AVFifoBuffer to write into\n * @return size\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_space"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "dest", :type "void *"} {:spelling "offset", :type "int"} {:spelling "buf_size", :type "int"} {:spelling "func", :type "void (*)(void *, void *, int)"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int] :coffi.mem/void]], :symbol "av_fifo_generic_peek_at", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_generic_peek_at, :raw-comment "/**\n * Feed data at specific position from an AVFifoBuffer to a user-supplied callback.\n * Similar as av_fifo_gereric_read but without discarding data.\n * @param f AVFifoBuffer to read from\n * @param offset offset from current read position\n * @param buf_size number of bytes to read\n * @param func generic read function\n * @param dest data destination\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_generic_peek_at"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "dest", :type "void *"} {:spelling "buf_size", :type "int"} {:spelling "func", :type "void (*)(void *, void *, int)"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/pointer :coffi.mem/int [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int] :coffi.mem/void]], :symbol "av_fifo_generic_peek", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_generic_peek, :raw-comment "/**\n * Feed data from an AVFifoBuffer to a user-supplied callback.\n * Similar as av_fifo_gereric_read but without discarding data.\n * @param f AVFifoBuffer to read from\n * @param buf_size number of bytes to read\n * @param func generic read function\n * @param dest data destination\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_generic_peek"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "dest", :type "void *"} {:spelling "buf_size", :type "int"} {:spelling "func", :type "void (*)(void *, void *, int)"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/pointer :coffi.mem/int [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int] :coffi.mem/void]], :symbol "av_fifo_generic_read", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_generic_read, :raw-comment "/**\n * Feed data from an AVFifoBuffer to a user-supplied callback.\n * @param f AVFifoBuffer to read from\n * @param buf_size number of bytes to read\n * @param func generic read function\n * @param dest data destination\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_generic_read"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "src", :type "void *"} {:spelling "size", :type "int"} {:spelling "func", :type "int (*)(void *, void *, int)"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/pointer :coffi.mem/int [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int] :coffi.mem/int]], :symbol "av_fifo_generic_write", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_generic_write, :raw-comment "/**\n * Feed data from a user-supplied callback to an AVFifoBuffer.\n * @param f AVFifoBuffer to write to\n * @param src data source; non-const since it may be used as a\n * modifiable context by the function defined in func\n * @param size number of bytes to write\n * @param func generic write function; the first parameter is src,\n * the second is dest_buf, the third is dest_buf_size.\n * func must return the number of bytes written to dest_buf, or <= 0 to\n * indicate no more data available to write.\n * If func is NULL, src is interpreted as a simple byte array for source data.\n * @return the number of bytes written to the FIFO\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_generic_write"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "size", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/int], :symbol "av_fifo_realloc2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_realloc2, :raw-comment "/**\n * Resize an AVFifoBuffer.\n * In case of reallocation failure, the old FIFO is kept unchanged.\n *\n * @param f AVFifoBuffer to resize\n * @param size new AVFifoBuffer size in bytes\n * @return <0 for failure, >=0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_realloc2"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "additional_space", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/int], :symbol "av_fifo_grow", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_grow, :raw-comment "/**\n * Enlarge an AVFifoBuffer.\n * In case of reallocation failure, the old FIFO is kept unchanged.\n * The new fifo size may be larger than the requested size.\n *\n * @param f AVFifoBuffer to resize\n * @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()\n * @return <0 for failure, >=0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_grow"} {:args [{:spelling "f", :type "struct AVFifoBuffer *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFifoBuffer] :coffi.mem/int], :symbol "av_fifo_drain", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fifo_drain, :raw-comment "/**\n * Read and discard the specified amount of data from an AVFifoBuffer.\n * @param f AVFifoBuffer to read from\n * @param size amount of data to read in bytes\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fifo_drain"} {:args [], :ret {:spelling "struct AVBlowfish *"}, :function/args [], :symbol "av_blowfish_alloc", :function/ret [:coffi.mem/pointer :clong/AVBlowfish], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_blowfish_alloc, :raw-comment "/**\n * Allocate an AVBlowfish context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_blowfish_alloc"} {:args [{:spelling "ctx", :type "struct AVBlowfish *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_len", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBlowfish] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_blowfish_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_blowfish_init, :raw-comment "/**\n * Initialize an AVBlowfish context.\n *\n * @param ctx an AVBlowfish context\n * @param key a key\n * @param key_len length of the key\n */", :kind "CXCursor_FunctionDecl", :spelling "av_blowfish_init"} {:args [{:spelling "ctx", :type "struct AVBlowfish *"} {:spelling "xl", :type "unsigned int *"} {:spelling "xr", :type "unsigned int *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBlowfish] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "av_blowfish_crypt_ecb", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_blowfish_crypt_ecb, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVBlowfish context\n * @param xl left four bytes halves of input to be encrypted\n * @param xr right four bytes halves of input to be encrypted\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_blowfish_crypt_ecb"} {:args [{:spelling "ctx", :type "struct AVBlowfish *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBlowfish] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_blowfish_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_blowfish_crypt, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVBlowfish context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_blowfish_crypt"} {:args [], :ret {:spelling "struct AVMurMur3 *"}, :function/args [], :symbol "av_murmur3_alloc", :function/ret [:coffi.mem/pointer :clong/AVMurMur3], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_murmur3_alloc, :raw-comment "/**\n * Allocate an AVMurMur3 hash context.\n *\n * @return Uninitialized hash context or `NULL` in case of error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_murmur3_alloc"} {:args [{:spelling "c", :type "struct AVMurMur3 *"} {:spelling "seed", :type "unsigned long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMurMur3] :coffi.mem/long], :symbol "av_murmur3_init_seeded", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_murmur3_init_seeded, :raw-comment "/**\n * Initialize or reinitialize an AVMurMur3 hash context with a seed.\n *\n * @param[out] c    Hash context\n * @param[in]  seed Random seed\n *\n * @see av_murmur3_init()\n * @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n * seeds for MurmurHash3.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_murmur3_init_seeded"} {:args [{:spelling "c", :type "struct AVMurMur3 *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMurMur3]], :symbol "av_murmur3_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_murmur3_init, :raw-comment "/**\n * Initialize or reinitialize an AVMurMur3 hash context.\n *\n * Equivalent to av_murmur3_init_seeded() with a built-in seed.\n *\n * @param[out] c    Hash context\n *\n * @see av_murmur3_init_seeded()\n * @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n * seeds for MurmurHash3.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_murmur3_init"} {:args [{:spelling "c", :type "struct AVMurMur3 *"} {:spelling "src", :type "const unsigned char *"} {:spelling "len", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMurMur3] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_murmur3_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_murmur3_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_murmur3_update"} {:args [{:spelling "c", :type "struct AVMurMur3 *"} {:spelling "dst", :type "unsigned char [16]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMurMur3] [:coffi.mem/array :coffi.mem/char 16]], :symbol "av_murmur3_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_murmur3_final, :raw-comment "/**\n * Finish hashing and output digest value.\n *\n * @param[in,out] c    Hash context\n * @param[out]    dst  Buffer where output digest value is stored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_murmur3_final"} {:args [{:spelling "size", :type "int"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [:coffi.mem/int], :symbol "av_buffer_alloc", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_alloc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_alloc"} {:args [{:spelling "size", :type "int"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [:coffi.mem/int], :symbol "av_buffer_allocz", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_allocz, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_allocz"} {:args [{:spelling "data", :type "unsigned char *"} {:spelling "size", :type "int"} {:spelling "free", :type "void (*)(void *, unsigned char *)"} {:spelling "opaque", :type "void *"} {:spelling "flags", :type "int"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/void] :coffi.mem/pointer :coffi.mem/int], :symbol "av_buffer_create", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_create, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_create"} {:args [{:spelling "opaque", :type "void *"} {:spelling "data", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_buffer_default_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_default_free, :raw-comment "/**\n * Default free callback, which calls av_free() on the buffer data.\n * This function is meant to be passed to av_buffer_create(), not called\n * directly.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_default_free"} {:args [{:spelling "buf", :type "struct AVBufferRef *"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_ref", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_ref, :raw-comment "/**\n * Create a new reference to an AVBuffer.\n *\n * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on\n * failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_ref"} {:args [{:spelling "buf", :type "struct AVBufferRef **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]]], :symbol "av_buffer_unref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_unref, :raw-comment "/**\n * Free a given reference and automatically free the buffer if there are no more\n * references to it.\n *\n * @param buf the reference to be freed. The pointer is set to NULL on return.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_unref"} {:args [{:spelling "buf", :type "const struct AVBufferRef *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_is_writable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_is_writable, :raw-comment "/**\n * @return 1 if the caller may write to the data referred to by buf (which is\n * true if and only if buf is the only reference to the underlying AVBuffer).\n * Return 0 otherwise.\n * A positive answer is valid until av_buffer_ref() is called on buf.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_is_writable"} {:args [{:spelling "buf", :type "const struct AVBufferRef *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_get_opaque", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_get_opaque, :raw-comment "/**\n * @return the opaque parameter set by av_buffer_create.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_get_opaque"} {:args [{:spelling "buf", :type "const struct AVBufferRef *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_get_ref_count", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_get_ref_count, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_get_ref_count"} {:args [{:spelling "buf", :type "struct AVBufferRef **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]]], :symbol "av_buffer_make_writable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_make_writable, :raw-comment "/**\n * Create a writable reference from a given buffer reference, avoiding data copy\n * if possible.\n *\n * @param buf buffer reference to make writable. On success, buf is either left\n *            untouched, or it is unreferenced and a new writable AVBufferRef is\n *            written in its place. On failure, buf is left untouched.\n * @return 0 on success, a negative AVERROR on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_make_writable"} {:args [{:spelling "buf", :type "struct AVBufferRef **"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int], :symbol "av_buffer_realloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_realloc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_realloc"} {:args [{:spelling "dst", :type "struct AVBufferRef **"} {:spelling "src", :type "struct AVBufferRef *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] [:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_replace", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_replace, :raw-comment "/**\n * Ensure dst refers to the same data as src.\n *\n * When *dst is already equivalent to src, do nothing. Otherwise unreference dst\n * and replace it with a new reference to src.\n *\n * @param dst Pointer to either a valid buffer reference or NULL. On success,\n *            this will point to a buffer reference equivalent to src. On\n *            failure, dst will be left untouched.\n * @param src A buffer reference to replace dst with. May be NULL, then this\n *            function is equivalent to av_buffer_unref(dst).\n * @return 0 on success\n *         AVERROR(ENOMEM) on memory allocation failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_replace"} {:args [{:spelling "size", :type "int"} {:spelling "alloc", :type "struct AVBufferRef *(*)(int)"}], :ret {:spelling "struct AVBufferPool *"}, :function/args [:coffi.mem/int [:coffi.ffi/fn [:coffi.mem/int] [:coffi.mem/pointer :clong/AVBufferRef]]], :symbol "av_buffer_pool_init", :function/ret [:coffi.mem/pointer :clong/AVBufferPool], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_pool_init, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_pool_init"} {:args [{:spelling "size", :type "int"} {:spelling "opaque", :type "void *"} {:spelling "alloc", :type "struct AVBufferRef *(*)(void *, int)"} {:spelling "pool_free", :type "void (*)(void *)"}], :ret {:spelling "struct AVBufferPool *"}, :function/args [:coffi.mem/int :coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clong/AVBufferRef]] [:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/void]], :symbol "av_buffer_pool_init2", :function/ret [:coffi.mem/pointer :clong/AVBufferPool], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_pool_init2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffer_pool_init2"} {:args [{:spelling "pool", :type "struct AVBufferPool **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferPool]]], :symbol "av_buffer_pool_uninit", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_pool_uninit, :raw-comment "/**\n * Mark the pool as being available for freeing. It will actually be freed only\n * once all the allocated buffers associated with the pool are released. Thus it\n * is safe to call this function while some of the allocated buffers are still\n * in use.\n *\n * @param pool pointer to the pool to be freed. It will be set to NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_pool_uninit"} {:args [{:spelling "pool", :type "struct AVBufferPool *"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferPool]], :symbol "av_buffer_pool_get", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_pool_get, :raw-comment "/**\n * Allocate a new AVBuffer, reusing an old buffer from the pool when available.\n * This function may be called simultaneously from multiple threads.\n *\n * @return a reference to the new buffer on success, NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_pool_get"} {:args [{:spelling "ref", :type "struct AVBufferRef *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_buffer_pool_buffer_get_opaque", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffer_pool_buffer_get_opaque, :raw-comment "/**\n * Query the original opaque parameter of an allocated buffer in the pool.\n *\n * @param ref a buffer reference to a buffer returned by av_buffer_pool_get.\n * @return the opaque parameter set by the buffer allocator function of the\n *         buffer pool.\n *\n * @note the opaque parameter of ref is used by the buffer pool implementation,\n * therefore you have to use this function to access the original opaque\n * parameter of an allocated buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffer_pool_buffer_get_opaque"} {:args [{:spelling "m", :type "const struct AVDictionary *"} {:spelling "key", :type "const char *"} {:spelling "prev", :type "const struct AVDictionaryEntry *"} {:spelling "flags", :type "int"}], :ret {:spelling "struct AVDictionaryEntry *"}, :function/args [[:coffi.mem/pointer :clong/AVDictionary] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVDictionaryEntry] :coffi.mem/int], :symbol "av_dict_get", :function/ret [:coffi.mem/pointer :clong/AVDictionaryEntry], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_get, :raw-comment "/**\n * Get a dictionary entry with matching key.\n *\n * The returned entry key or value must not be changed, or it will\n * cause undefined behavior.\n *\n * To iterate through all the dictionary entries, you can set the matching key\n * to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag.\n *\n * @param prev Set to the previous matching element to find the next.\n *             If set to NULL the first matching element is returned.\n * @param key matching key\n * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved\n * @return found entry or NULL in case no matching entry was found in the dictionary\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_get"} {:args [{:spelling "m", :type "const struct AVDictionary *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVDictionary]], :symbol "av_dict_count", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_count, :raw-comment "/**\n * Get number of entries in dictionary.\n *\n * @param m dictionary\n * @return  number of entries in dictionary\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_count"} {:args [{:spelling "pm", :type "struct AVDictionary **"} {:spelling "key", :type "const char *"} {:spelling "value", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_dict_set", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_set, :raw-comment "/**\n * Set the given entry in *pm, overwriting an existing entry.\n *\n * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,\n * these arguments will be freed on error.\n *\n * Warning: Adding a new entry to a dictionary invalidates all existing entries\n * previously returned with av_dict_get.\n *\n * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL\n * a dictionary struct is allocated and put in *pm.\n * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)\n * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).\n *        Passing a NULL value will cause an existing entry to be deleted.\n * @return >= 0 on success otherwise an error code <0\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_set"} {:args [{:spelling "pm", :type "struct AVDictionary **"} {:spelling "key", :type "const char *"} {:spelling "value", :type "long long"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long :coffi.mem/int], :symbol "av_dict_set_int", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_set_int, :raw-comment "/**\n * Convenience wrapper for av_dict_set that converts the value to a string\n * and stores it.\n *\n * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_set_int"} {:args [{:spelling "pm", :type "struct AVDictionary **"} {:spelling "str", :type "const char *"} {:spelling "key_val_sep", :type "const char *"} {:spelling "pairs_sep", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_dict_parse_string", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_parse_string, :raw-comment "/**\n * Parse the key/value pairs list and add the parsed entries to a dictionary.\n *\n * In case of failure, all the successfully set entries are stored in\n * *pm. You may need to manually free the created dictionary.\n *\n * @param key_val_sep  a 0-terminated list of characters used to separate\n *                     key from value\n * @param pairs_sep    a 0-terminated list of characters used to separate\n *                     two pairs from each other\n * @param flags        flags to use when adding to dictionary.\n *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL\n *                     are ignored since the key/value tokens will always\n *                     be duplicated.\n * @return             0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_parse_string"} {:args [{:spelling "dst", :type "struct AVDictionary **"} {:spelling "src", :type "const struct AVDictionary *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]] [:coffi.mem/pointer :clong/AVDictionary] :coffi.mem/int], :symbol "av_dict_copy", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_copy, :raw-comment "/**\n * Copy entries from one AVDictionary struct into another.\n * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,\n *            this function will allocate a struct for you and put it in *dst\n * @param src pointer to source AVDictionary struct\n * @param flags flags to use when setting entries in *dst\n * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag\n * @return 0 on success, negative AVERROR code on failure. If dst was allocated\n *           by this function, callers should free the associated memory.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_copy"} {:args [{:spelling "m", :type "struct AVDictionary **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "av_dict_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_free, :raw-comment "/**\n * Free all the memory allocated for an AVDictionary struct\n * and all keys and values.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_free"} {:args [{:spelling "m", :type "const struct AVDictionary *"} {:spelling "buffer", :type "char **"} {:spelling "key_val_sep", :type "const char"} {:spelling "pairs_sep", :type "const char"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVDictionary] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/char :coffi.mem/char], :symbol "av_dict_get_string", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dict_get_string, :raw-comment "/**\n * Get dictionary entries as a string.\n *\n * Create a string containing dictionary's entries.\n * Such string may be passed back to av_dict_parse_string().\n * @note String is escaped with backslashes ('\\').\n *\n * @param[in]  m             dictionary\n * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.\n *                           Buffer must be freed by the caller when is no longer needed.\n * @param[in]  key_val_sep   character used to separate key from value\n * @param[in]  pairs_sep     character used to separate two pairs from each other\n * @return                   >= 0 on success, negative on error\n * @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dict_get_string"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_get_sample_fmt_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_sample_fmt_name, :raw-comment "/**\n * Return the name of sample_fmt, or NULL if sample_fmt is not\n * recognized.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_sample_fmt_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "enum AVSampleFormat"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_get_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_sample_fmt, :raw-comment "/**\n * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE\n * on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_sample_fmt"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "planar", :type "int"}], :ret {:spelling "enum AVSampleFormat"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_get_alt_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_alt_sample_fmt, :raw-comment "/**\n * Return the planar<->packed alternative form of the given sample format, or\n * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the\n * requested planar/packed format, the format returned is the same as the\n * input.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_alt_sample_fmt"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "enum AVSampleFormat"}, :function/args [:coffi.mem/int], :symbol "av_get_packed_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_packed_sample_fmt, :raw-comment "/**\n * Get the packed alternative form of the given sample format.\n *\n * If the passed sample_fmt is already in packed format, the format returned is\n * the same as the input.\n *\n * @return  the packed alternative form of the given sample format or\n            AV_SAMPLE_FMT_NONE on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_packed_sample_fmt"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "enum AVSampleFormat"}, :function/args [:coffi.mem/int], :symbol "av_get_planar_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_planar_sample_fmt, :raw-comment "/**\n * Get the planar alternative form of the given sample format.\n *\n * If the passed sample_fmt is already in planar format, the format returned is\n * the same as the input.\n *\n * @return  the planar alternative form of the given sample format or\n            AV_SAMPLE_FMT_NONE on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_planar_sample_fmt"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_get_sample_fmt_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_sample_fmt_string, :raw-comment "/**\n * Generate a string corresponding to the sample format with\n * sample_fmt, or a header if sample_fmt is negative.\n *\n * @param buf the buffer where to write the string\n * @param buf_size the size of buf\n * @param sample_fmt the number of the sample format to print the\n * corresponding info string, or a negative value to print the\n * corresponding header.\n * @return the pointer to the filled buffer or NULL if sample_fmt is\n * unknown or in case of other errors\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_sample_fmt_string"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_get_bytes_per_sample", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_bytes_per_sample, :raw-comment "/**\n * Return number of bytes per sample.\n *\n * @param sample_fmt the sample format\n * @return number of bytes per sample or zero if unknown for the given\n * sample format\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_bytes_per_sample"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_sample_fmt_is_planar", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sample_fmt_is_planar, :raw-comment "/**\n * Check if the sample format is planar.\n *\n * @param sample_fmt the sample format to inspect\n * @return 1 if the sample format is planar, 0 if it is interleaved\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sample_fmt_is_planar"} {:args [{:spelling "linesize", :type "int *"} {:spelling "nb_channels", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_get_buffer_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_get_buffer_size, :raw-comment "/**\n * Get the required buffer size for the given audio parameters.\n *\n * @param[out] linesize calculated linesize, may be NULL\n * @param nb_channels   the number of channels\n * @param nb_samples    the number of samples in a single channel\n * @param sample_fmt    the sample format\n * @param align         buffer size alignment (0 = default, 1 = no alignment)\n * @return              required buffer size, or negative error code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_get_buffer_size"} {:args [{:spelling "audio_data", :type "unsigned char **"} {:spelling "linesize", :type "int *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "nb_channels", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_fill_arrays", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_fill_arrays, :raw-comment "/**\n * Fill plane data pointers and linesize for samples with sample\n * format sample_fmt.\n *\n * The audio_data array is filled with the pointers to the samples data planes:\n * for planar, set the start point of each channel's data within the buffer,\n * for packed, set the start point of the entire buffer only.\n *\n * The value pointed to by linesize is set to the aligned size of each\n * channel's data buffer for planar layout, or to the aligned size of the\n * buffer for all channels for packed layout.\n *\n * The buffer in buf must be big enough to contain all the samples\n * (use av_samples_get_buffer_size() to compute its minimum size),\n * otherwise the audio_data pointers will point to invalid data.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param[out] audio_data  array to be filled with the pointer for each channel\n * @param[out] linesize    calculated linesize, may be NULL\n * @param buf              the pointer to a buffer containing the samples\n * @param nb_channels      the number of channels\n * @param nb_samples       the number of samples in a single channel\n * @param sample_fmt       the sample format\n * @param align            buffer size alignment (0 = default, 1 = no alignment)\n * @return                 >=0 on success or a negative error code on failure\n * @todo return minimum size in bytes required for the buffer in case\n * of success at the next bump\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_fill_arrays"} {:args [{:spelling "audio_data", :type "unsigned char **"} {:spelling "linesize", :type "int *"} {:spelling "nb_channels", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_alloc, :raw-comment "/**\n * Allocate a samples buffer for nb_samples samples, and fill data pointers and\n * linesize accordingly.\n * The allocated samples buffer can be freed by using av_freep(&audio_data[0])\n * Allocated data will be initialized to silence.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param[out] audio_data  array to be filled with the pointer for each channel\n * @param[out] linesize    aligned size for audio buffer(s), may be NULL\n * @param nb_channels      number of audio channels\n * @param nb_samples       number of samples per channel\n * @param align            buffer size alignment (0 = default, 1 = no alignment)\n * @return                 >=0 on success or a negative error code on failure\n * @todo return the size of the allocated buffer in case of success at the next bump\n * @see av_samples_fill_arrays()\n * @see av_samples_alloc_array_and_samples()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_alloc"} {:args [{:spelling "audio_data", :type "unsigned char ***"} {:spelling "linesize", :type "int *"} {:spelling "nb_channels", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_alloc_array_and_samples", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_alloc_array_and_samples, :raw-comment "/**\n * Allocate a data pointers array, samples buffer for nb_samples\n * samples, and fill data pointers and linesize accordingly.\n *\n * This is the same as av_samples_alloc(), but also allocates the data\n * pointers array.\n *\n * @see av_samples_alloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_alloc_array_and_samples"} {:args [{:spelling "dst", :type "unsigned char **"} {:spelling "src", :type "unsigned char *const *"} {:spelling "dst_offset", :type "int"} {:spelling "src_offset", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "nb_channels", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_copy", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_copy, :raw-comment "/**\n * Copy samples from src to dst.\n *\n * @param dst destination array of pointers to data planes\n * @param src source array of pointers to data planes\n * @param dst_offset offset in samples at which the data will be written to dst\n * @param src_offset offset in samples at which the data will be read from src\n * @param nb_samples number of samples to be copied\n * @param nb_channels number of audio channels\n * @param sample_fmt audio sample format\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_copy"} {:args [{:spelling "audio_data", :type "unsigned char **"} {:spelling "offset", :type "int"} {:spelling "nb_samples", :type "int"} {:spelling "nb_channels", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_samples_set_silence", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_samples_set_silence, :raw-comment "/**\n * Fill an audio buffer with silence.\n *\n * @param audio_data  array of pointers to data planes\n * @param offset      offset in samples at which to start filling\n * @param nb_samples  number of samples to fill\n * @param nb_channels number of audio channels\n * @param sample_fmt  audio sample format\n */", :kind "CXCursor_FunctionDecl", :spelling "av_samples_set_silence"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_best_effort_timestamp", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_best_effort_timestamp, :raw-comment "/**\n * Accessors for some AVFrame fields. These used to be provided for ABI\n * compatibility, and do not need to be used anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_best_effort_timestamp"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/long], :symbol "av_frame_set_best_effort_timestamp", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_best_effort_timestamp, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_best_effort_timestamp"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_pkt_duration", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_pkt_duration, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_pkt_duration"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/long], :symbol "av_frame_set_pkt_duration", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_pkt_duration, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_pkt_duration"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_pkt_pos", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_pkt_pos, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_pkt_pos"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/long], :symbol "av_frame_set_pkt_pos", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_pkt_pos, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_pkt_pos"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_channel_layout", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_channel_layout, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_channel_layout"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/long], :symbol "av_frame_set_channel_layout", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_channel_layout, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_channel_layout"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_channels", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_channels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_channels"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_channels", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_channels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_channels"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_sample_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_sample_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_sample_rate"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_sample_rate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_sample_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_sample_rate"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "struct AVDictionary *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_metadata", :function/ret [:coffi.mem/pointer :clong/AVDictionary], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_metadata, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_metadata"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "struct AVDictionary *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVDictionary]], :symbol "av_frame_set_metadata", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_metadata, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_metadata"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_decode_error_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_decode_error_flags, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_decode_error_flags"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_decode_error_flags", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_decode_error_flags, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_decode_error_flags"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_pkt_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_pkt_size, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_pkt_size"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_pkt_size", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_pkt_size, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_pkt_size"} {:args [{:spelling "f", :type "struct AVFrame *"} {:spelling "stride", :type "int *"} {:spelling "type", :type "int *"}], :ret {:spelling "signed char *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_frame_get_qp_table", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_qp_table, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_qp_table"} {:args [{:spelling "f", :type "struct AVFrame *"} {:spelling "buf", :type "struct AVBufferRef *"} {:spelling "stride", :type "int"} {:spelling "type", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/int :coffi.mem/int], :symbol "av_frame_set_qp_table", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_qp_table, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_qp_table"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "enum AVColorSpace"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_colorspace", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_colorspace, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_colorspace"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "enum AVColorSpace"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_colorspace", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_colorspace, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_colorspace"} {:args [{:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "enum AVColorRange"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_get_color_range", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_color_range, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_color_range"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "val", :type "enum AVColorRange"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_set_color_range", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_set_color_range, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_frame_set_color_range"} {:args [{:spelling "val", :type "enum AVColorSpace"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_get_colorspace_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_colorspace_name, :raw-comment "/**\n * Get the name of a colorspace.\n * @return a static string identifying the colorspace; can be NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_colorspace_name"} {:args [], :ret {:spelling "struct AVFrame *"}, :function/args [], :symbol "av_frame_alloc", :function/ret [:coffi.mem/pointer :clong/AVFrame], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_alloc, :raw-comment "/**\n * Allocate an AVFrame and set its fields to default values.  The resulting\n * struct must be freed using av_frame_free().\n *\n * @return An AVFrame filled with default values or NULL on failure.\n *\n * @note this only allocates the AVFrame itself, not the data buffers. Those\n * must be allocated through other means, e.g. with av_frame_get_buffer() or\n * manually.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_alloc"} {:args [{:spelling "frame", :type "struct AVFrame **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFrame]]], :symbol "av_frame_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_free, :raw-comment "/**\n * Free the frame and any dynamically allocated objects in it,\n * e.g. extended_data. If the frame is reference counted, it will be\n * unreferenced first.\n *\n * @param frame frame to be freed. The pointer will be set to NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_free"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_ref", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_ref, :raw-comment "/**\n * Set up a new reference to the data described by the source frame.\n *\n * Copy frame properties from src to dst and create a new reference for each\n * AVBufferRef from src.\n *\n * If src is not reference counted, new buffers are allocated and the data is\n * copied.\n *\n * @warning: dst MUST have been either unreferenced with av_frame_unref(dst),\n *           or newly allocated with av_frame_alloc() before calling this\n *           function, or undefined behavior will occur.\n *\n * @return 0 on success, a negative AVERROR on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_ref"} {:args [{:spelling "src", :type "const struct AVFrame *"}], :ret {:spelling "struct AVFrame *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_clone", :function/ret [:coffi.mem/pointer :clong/AVFrame], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_clone, :raw-comment "/**\n * Create a new frame that references the same data as src.\n *\n * This is a shortcut for av_frame_alloc()+av_frame_ref().\n *\n * @return newly created AVFrame on success, NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_clone"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_unref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_unref, :raw-comment "/**\n * Unreference all the buffers referenced by frame and reset the frame fields.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_unref"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "struct AVFrame *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_move_ref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_move_ref, :raw-comment "/**\n * Move everything contained in src to dst and reset src.\n *\n * @warning: dst is not unreferenced, but directly overwritten without reading\n *           or deallocating its contents. Call av_frame_unref(dst) manually\n *           before calling this function to ensure that no memory is leaked.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_move_ref"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_get_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_buffer, :raw-comment "/**\n * Allocate new buffer(s) for audio or video data.\n *\n * The following fields must be set on frame before calling this function:\n * - format (pixel format for video, sample format for audio)\n * - width and height for video\n * - nb_samples and channel_layout for audio\n *\n * This function will fill AVFrame.data and AVFrame.buf arrays and, if\n * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.\n * For planar formats, one buffer will be allocated for each plane.\n *\n * @warning: if frame already has been allocated, calling this function will\n *           leak memory. In addition, undefined behavior can occur in certain\n *           cases.\n *\n * @param frame frame in which to store the new buffers.\n * @param align Required buffer size alignment. If equal to 0, alignment will be\n *              chosen automatically for the current CPU. It is highly\n *              recommended to pass 0 here unless you know what you are doing.\n *\n * @return 0 on success, a negative AVERROR on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_buffer"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_is_writable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_is_writable, :raw-comment "/**\n * Check if the frame data is writable.\n *\n * @return A positive value if the frame data is writable (which is true if and\n * only if each of the underlying buffers has only one reference, namely the one\n * stored in this frame). Return 0 otherwise.\n *\n * If 1 is returned the answer is valid until av_buffer_ref() is called on any\n * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).\n *\n * @see av_frame_make_writable(), av_buffer_is_writable()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_is_writable"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_make_writable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_make_writable, :raw-comment "/**\n * Ensure that the frame data is writable, avoiding data copy if possible.\n *\n * Do nothing if the frame is writable, allocate new buffers and copy the data\n * if it is not.\n *\n * @return 0 on success, a negative AVERROR on error.\n *\n * @see av_frame_is_writable(), av_buffer_is_writable(),\n * av_buffer_make_writable()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_make_writable"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_copy", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_copy, :raw-comment "/**\n * Copy the frame data from src to dst.\n *\n * This function does not allocate anything, dst must be already initialized and\n * allocated with the same parameters as src.\n *\n * This function only copies the frame data (i.e. the contents of the data /\n * extended data arrays), not any other properties.\n *\n * @return >= 0 on success, a negative AVERROR on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_copy"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_frame_copy_props", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_copy_props, :raw-comment "/**\n * Copy only \"metadata\" fields from src to dst.\n *\n * Metadata for the purpose of this function are those fields that do not affect\n * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample\n * aspect ratio (for video), but not width/height or channel layout.\n * Side data is also copied.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_copy_props"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "plane", :type "int"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_get_plane_buffer", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_plane_buffer, :raw-comment "/**\n * Get the buffer reference a given data plane is stored in.\n *\n * @param plane index of the data plane of interest in frame->extended_data.\n *\n * @return the buffer reference that contains the plane or NULL if the input\n * frame is not valid.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_plane_buffer"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "type", :type "enum AVFrameSideDataType"} {:spelling "size", :type "int"}], :ret {:spelling "struct AVFrameSideData *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int :coffi.mem/int], :symbol "av_frame_new_side_data", :function/ret [:coffi.mem/pointer :clong/AVFrameSideData], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_new_side_data, :raw-comment "/**\n * Add a new side data to a frame.\n *\n * @param frame a frame to which the side data should be added\n * @param type type of the added side data\n * @param size size of the side data\n *\n * @return newly added side data on success, NULL on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_new_side_data"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "type", :type "enum AVFrameSideDataType"} {:spelling "buf", :type "struct AVBufferRef *"}], :ret {:spelling "struct AVFrameSideData *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int [:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_frame_new_side_data_from_buf", :function/ret [:coffi.mem/pointer :clong/AVFrameSideData], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_new_side_data_from_buf, :raw-comment "/**\n * Add a new side data to a frame from an existing AVBufferRef\n *\n * @param frame a frame to which the side data should be added\n * @param type  the type of the added side data\n * @param buf   an AVBufferRef to add as side data. The ownership of\n *              the reference is transferred to the frame.\n *\n * @return newly added side data on success, NULL on error. On failure\n *         the frame is unchanged and the AVBufferRef remains owned by\n *         the caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_new_side_data_from_buf"} {:args [{:spelling "frame", :type "const struct AVFrame *"} {:spelling "type", :type "enum AVFrameSideDataType"}], :ret {:spelling "struct AVFrameSideData *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_get_side_data", :function/ret [:coffi.mem/pointer :clong/AVFrameSideData], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_get_side_data, :raw-comment "/**\n * @return a pointer to the side data of a given type on success, NULL if there\n * is no side data with such type in this frame.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_get_side_data"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "type", :type "enum AVFrameSideDataType"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_remove_side_data", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_remove_side_data, :raw-comment "/**\n * Remove and free all side data instances of the given type.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_remove_side_data"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_frame_apply_cropping", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_apply_cropping, :raw-comment "/**\n * Crop the given video AVFrame according to its crop_left/crop_top/crop_right/\n * crop_bottom fields. If cropping is successful, the function will adjust the\n * data pointers and the width/height fields, and set the crop fields to 0.\n *\n * In all cases, the cropping boundaries will be rounded to the inherent\n * alignment of the pixel format. In some cases, such as for opaque hwaccel\n * formats, the left/top cropping is ignored. The crop fields are set to 0 even\n * if the cropping was rounded or ignored.\n *\n * @param frame the frame which should be cropped\n * @param flags Some combination of AV_FRAME_CROP_* flags, or 0.\n *\n * @return >= 0 on success, a negative AVERROR on error. If the cropping fields\n * were invalid, AVERROR(ERANGE) is returned, and nothing is changed.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_apply_cropping"} {:args [{:spelling "type", :type "enum AVFrameSideDataType"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_frame_side_data_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_frame_side_data_name, :raw-comment "/**\n * @return a string identifying the side data type\n */", :kind "CXCursor_FunctionDecl", :spelling "av_frame_side_data_name"} {:args [], :ret {:spelling "struct AVStereo3D *"}, :function/args [], :symbol "av_stereo3d_alloc", :function/ret [:coffi.mem/pointer :clong/AVStereo3D], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stereo3d_alloc, :raw-comment "/**\n * Allocate an AVStereo3D structure and set its fields to default values.\n * The resulting struct can be freed using av_freep().\n *\n * @return An AVStereo3D filled with default values or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stereo3d_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVStereo3D *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_stereo3d_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVStereo3D], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stereo3d_create_side_data, :raw-comment "/**\n * Allocate a complete AVFrameSideData and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVStereo3D structure to be filled by caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stereo3d_create_side_data"} {:args [{:spelling "type", :type "unsigned int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_stereo3d_type_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stereo3d_type_name, :raw-comment "/**\n * Provide a human-readable name of a given stereo3d type.\n *\n * @param type The input stereo3d type value.\n *\n * @return The name of the stereo3d value, or \"unknown\".\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stereo3d_type_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_stereo3d_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stereo3d_from_name, :raw-comment "/**\n * Get the AVStereo3DType form a human-readable name.\n *\n * @param name The input string.\n *\n * @return The AVStereo3DType value, or -1 if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stereo3d_from_name"} {:args [{:spelling "pixdesc", :type "const struct AVPixFmtDescriptor *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPixFmtDescriptor]], :symbol "av_get_bits_per_pixel", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_bits_per_pixel, :raw-comment "/**\n * Return the number of bits per pixel used by the pixel format\n * described by pixdesc. Note that this is not the same as the number\n * of bits per sample.\n *\n * The returned number of bits refers to the number of bits actually\n * used for storing the pixel information, that is padding bits are\n * not counted.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_bits_per_pixel"} {:args [{:spelling "pixdesc", :type "const struct AVPixFmtDescriptor *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPixFmtDescriptor]], :symbol "av_get_padded_bits_per_pixel", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_padded_bits_per_pixel, :raw-comment "/**\n * Return the number of bits per pixel for the pixel format\n * described by pixdesc, including any padding or unused bits.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_padded_bits_per_pixel"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "const struct AVPixFmtDescriptor *"}, :function/args [:coffi.mem/int], :symbol "av_pix_fmt_desc_get", :function/ret [:coffi.mem/pointer :clong/AVPixFmtDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_desc_get, :raw-comment "/**\n * @return a pixel format descriptor for provided pixel format or NULL if\n * this pixel format is unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_desc_get"} {:args [{:spelling "prev", :type "const struct AVPixFmtDescriptor *"}], :ret {:spelling "const struct AVPixFmtDescriptor *"}, :function/args [[:coffi.mem/pointer :clong/AVPixFmtDescriptor]], :symbol "av_pix_fmt_desc_next", :function/ret [:coffi.mem/pointer :clong/AVPixFmtDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_desc_next, :raw-comment "/**\n * Iterate over all pixel format descriptors known to libavutil.\n *\n * @param prev previous descriptor. NULL to get the first descriptor.\n *\n * @return next descriptor or NULL after the last descriptor\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_desc_next"} {:args [{:spelling "desc", :type "const struct AVPixFmtDescriptor *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [[:coffi.mem/pointer :clong/AVPixFmtDescriptor]], :symbol "av_pix_fmt_desc_get_id", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_desc_get_id, :raw-comment "/**\n * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc\n * is not a valid pointer to a pixel format descriptor.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_desc_get_id"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "h_shift", :type "int *"} {:spelling "v_shift", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_pix_fmt_get_chroma_sub_sample", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_get_chroma_sub_sample, :raw-comment "/**\n * Utility function to access log2_chroma_w log2_chroma_h from\n * the pixel format AVPixFmtDescriptor.\n *\n * @param[in]  pix_fmt the pixel format\n * @param[out] h_shift store log2_chroma_w (horizontal/width shift)\n * @param[out] v_shift store log2_chroma_h (vertical/height shift)\n *\n * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_get_chroma_sub_sample"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_pix_fmt_count_planes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_count_planes, :raw-comment "/**\n * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a\n * valid pixel format.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_count_planes"} {:args [{:spelling "range", :type "enum AVColorRange"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_color_range_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_range_name, :raw-comment "/**\n * @return the name for provided color range or NULL if unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_range_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_color_range_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_range_from_name, :raw-comment "/**\n * @return the AVColorRange value for name or an AVError if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_range_from_name"} {:args [{:spelling "primaries", :type "enum AVColorPrimaries"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_color_primaries_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_primaries_name, :raw-comment "/**\n * @return the name for provided color primaries or NULL if unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_primaries_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_color_primaries_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_primaries_from_name, :raw-comment "/**\n * @return the AVColorPrimaries value for name or an AVError if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_primaries_from_name"} {:args [{:spelling "transfer", :type "enum AVColorTransferCharacteristic"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_color_transfer_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_transfer_name, :raw-comment "/**\n * @return the name for provided color transfer or NULL if unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_transfer_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_color_transfer_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_transfer_from_name, :raw-comment "/**\n * @return the AVColorTransferCharacteristic value for name or an AVError if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_transfer_from_name"} {:args [{:spelling "space", :type "enum AVColorSpace"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_color_space_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_space_name, :raw-comment "/**\n * @return the name for provided color space or NULL if unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_space_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_color_space_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_color_space_from_name, :raw-comment "/**\n * @return the AVColorSpace value for name or an AVError if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_color_space_from_name"} {:args [{:spelling "location", :type "enum AVChromaLocation"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_chroma_location_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_chroma_location_name, :raw-comment "/**\n * @return the name for provided chroma location or NULL if unknown.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_chroma_location_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_chroma_location_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_chroma_location_from_name, :raw-comment "/**\n * @return the AVChromaLocation value for name or an AVError if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_chroma_location_from_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_get_pix_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_pix_fmt, :raw-comment "/**\n * Return the pixel format corresponding to name.\n *\n * If there is no pixel format with name name, then looks for a\n * pixel format with the name corresponding to the native endian\n * format of name.\n * For example in a little-endian system, first looks for \"gray16\",\n * then for \"gray16le\".\n *\n * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_pix_fmt"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_get_pix_fmt_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_pix_fmt_name, :raw-comment "/**\n * Return the short name for a pixel format, NULL in case pix_fmt is\n * unknown.\n *\n * @see av_get_pix_fmt(), av_get_pix_fmt_string()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_pix_fmt_name"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_get_pix_fmt_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_pix_fmt_string, :raw-comment "/**\n * Print in buf the string corresponding to the pixel format with\n * number pix_fmt, or a header if pix_fmt is negative.\n *\n * @param buf the buffer where to write the string\n * @param buf_size the size of buf\n * @param pix_fmt the number of the pixel format to print the\n * corresponding info string, or a negative value to print the\n * corresponding header.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_pix_fmt_string"} {:args [{:spelling "dst", :type "void *"} {:spelling "data", :type "const unsigned char *[4]"} {:spelling "linesize", :type "int const[4]"} {:spelling "desc", :type "const struct AVPixFmtDescriptor *"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "c", :type "int"} {:spelling "w", :type "int"} {:spelling "read_pal_component", :type "int"} {:spelling "dst_element_size", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :clong/AVPixFmtDescriptor] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_read_image_line2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_read_image_line2, :raw-comment "/**\n * Read a line from an image, and write the values of the\n * pixel format component c to dst.\n *\n * @param data the array containing the pointers to the planes of the image\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to read\n * @param y the vertical coordinate of the first pixel to read\n * @param w the width of the line to read, that is the number of\n * values to write to dst\n * @param read_pal_component if not zero and the format is a paletted\n * format writes the values corresponding to the palette\n * component c in data[1] to dst, rather than the palette indexes in\n * data[0]. The behavior is undefined if the format is not paletted.\n * @param dst_element_size size of elements in dst array (2 or 4 byte)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_read_image_line2"} {:args [{:spelling "dst", :type "unsigned short *"} {:spelling "data", :type "const unsigned char *[4]"} {:spelling "linesize", :type "int const[4]"} {:spelling "desc", :type "const struct AVPixFmtDescriptor *"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "c", :type "int"} {:spelling "w", :type "int"} {:spelling "read_pal_component", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short] [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :clong/AVPixFmtDescriptor] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_read_image_line", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_read_image_line, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_read_image_line"} {:args [{:spelling "src", :type "const void *"} {:spelling "data", :type "unsigned char *[4]"} {:spelling "linesize", :type "int const[4]"} {:spelling "desc", :type "const struct AVPixFmtDescriptor *"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "c", :type "int"} {:spelling "w", :type "int"} {:spelling "src_element_size", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :clong/AVPixFmtDescriptor] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_write_image_line2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_image_line2, :raw-comment "/**\n * Write the values from src to the pixel format component c of an\n * image line.\n *\n * @param src array containing the values to write\n * @param data the array containing the pointers to the planes of the\n * image to write into. It is supposed to be zeroed.\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to write\n * @param y the vertical coordinate of the first pixel to write\n * @param w the width of the line to write, that is the number of\n * values to write to the image line\n * @param src_element_size size of elements in src array (2 or 4 byte)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_write_image_line2"} {:args [{:spelling "src", :type "const unsigned short *"} {:spelling "data", :type "unsigned char *[4]"} {:spelling "linesize", :type "int const[4]"} {:spelling "desc", :type "const struct AVPixFmtDescriptor *"} {:spelling "x", :type "int"} {:spelling "y", :type "int"} {:spelling "c", :type "int"} {:spelling "w", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/short] [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :clong/AVPixFmtDescriptor] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_write_image_line", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_image_line, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_write_image_line"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [:coffi.mem/int], :symbol "av_pix_fmt_swap_endianness", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pix_fmt_swap_endianness, :raw-comment "/**\n * Utility function to swap the endianness of a pixel format.\n *\n * @param[in]  pix_fmt the pixel format\n *\n * @return pixel format with swapped endianness if it exists,\n * otherwise AV_PIX_FMT_NONE\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pix_fmt_swap_endianness"} {:args [{:spelling "dst_pix_fmt", :type "enum AVPixelFormat"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_get_pix_fmt_loss", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_pix_fmt_loss, :raw-comment "/**\n * Compute what kind of losses will occur when converting from one specific\n * pixel format to another.\n * When converting from one pixel format to another, information loss may occur.\n * For example, when converting from RGB24 to GRAY, the color information will\n * be lost. Similarly, other losses occur when converting from some formats to\n * other formats. These losses can involve loss of chroma, but also loss of\n * resolution, loss of color depth, loss due to the color space conversion, loss\n * of the alpha bits or loss due to color quantization.\n * av_get_fix_fmt_loss() informs you about the various types of losses\n * which will occur when converting from one pixel format to another.\n *\n * @param[in] dst_pix_fmt destination pixel format\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @return Combination of flags informing you what kind of losses will occur\n * (maximum loss for an invalid dst_pix_fmt).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_pix_fmt_loss"} {:args [{:spelling "dst_pix_fmt1", :type "enum AVPixelFormat"} {:spelling "dst_pix_fmt2", :type "enum AVPixelFormat"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"} {:spelling "loss_ptr", :type "int *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_find_best_pix_fmt_of_2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_best_pix_fmt_of_2, :raw-comment "/**\n * Compute what kind of losses will occur when converting from one specific\n * pixel format to another.\n * When converting from one pixel format to another, information loss may occur.\n * For example, when converting from RGB24 to GRAY, the color information will\n * be lost. Similarly, other losses occur when converting from some formats to\n * other formats. These losses can involve loss of chroma, but also loss of\n * resolution, loss of color depth, loss due to the color space conversion, loss\n * of the alpha bits or loss due to color quantization.\n * av_get_fix_fmt_loss() informs you about the various types of losses\n * which will occur when converting from one pixel format to another.\n *\n * @param[in] dst_pix_fmt destination pixel format\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @return Combination of flags informing you what kind of losses will occur\n * (maximum loss for an invalid dst_pix_fmt).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_best_pix_fmt_of_2"} {:args [{:spelling "out", :type "unsigned char *"} {:spelling "in", :type "const char *"} {:spelling "out_size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_base64_decode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_base64_decode, :raw-comment "/**\n * Decode a base64-encoded string.\n *\n * @param out      buffer for decoded data\n * @param in       null-terminated input string\n * @param out_size size in bytes of the out buffer, must be at\n *                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))\n * @return         number of bytes written, or a negative value in case of\n *                 invalid input\n */", :kind "CXCursor_FunctionDecl", :spelling "av_base64_decode"} {:args [{:spelling "out", :type "char *"} {:spelling "out_size", :type "int"} {:spelling "in", :type "const unsigned char *"} {:spelling "in_size", :type "int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_base64_encode", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_base64_encode, :raw-comment "/**\n * Encode data to base64 and null-terminate.\n *\n * @param out      buffer for encoded data\n * @param out_size size in bytes of the out buffer (including the\n *                 null terminator), must be at least AV_BASE64_SIZE(in_size)\n * @param in       input buffer containing the data to encode\n * @param in_size  size in bytes of the in buffer\n * @return         out or NULL in case of error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_base64_encode"} {:args [], :ret {:spelling "struct AVSHA *"}, :function/args [], :symbol "av_sha_alloc", :function/ret [:coffi.mem/pointer :clong/AVSHA], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha_alloc, :raw-comment "/**\n * Allocate an AVSHA context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha_alloc"} {:args [{:spelling "context", :type "struct AVSHA *"} {:spelling "bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVSHA] :coffi.mem/int], :symbol "av_sha_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha_init, :raw-comment "/**\n * Initialize SHA-1 or SHA-2 hashing.\n *\n * @param context pointer to the function context (of size av_sha_size)\n * @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha_init"} {:args [{:spelling "ctx", :type "struct AVSHA *"} {:spelling "data", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSHA] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_sha_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_sha_update"} {:args [{:spelling "context", :type "struct AVSHA *"} {:spelling "digest", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSHA] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_sha_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha_final, :raw-comment "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha_final"} {:args [{:spelling "c", :type "struct AVLFG *"} {:spelling "seed", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVLFG] :coffi.mem/int], :symbol "av_lfg_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_lfg_init, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_lfg_init"} {:args [{:spelling "c", :type "struct AVLFG *"} {:spelling "data", :type "const unsigned char *"} {:spelling "length", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVLFG] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_lfg_init_from_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_lfg_init_from_data, :raw-comment "/**\n * Seed the state of the ALFG using binary data.\n *\n * Return value: 0 on success, negative value (AVERROR) on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_lfg_init_from_data"} {:args [{:spelling "lfg", :type "struct AVLFG *"} {:spelling "out", :type "double [2]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVLFG] [:coffi.mem/array :coffi.mem/double 2]], :symbol "av_bmg_get", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bmg_get, :raw-comment "/**\n * Get the next two numbers generated by a Box-Muller Gaussian\n * generator using the random numbers issued by lfg.\n *\n * @param out array where the two generated numbers are placed\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bmg_get"} {:args [], :ret {:spelling "struct AVVkFrame *"}, :function/args [], :symbol "av_vk_frame_alloc", :function/ret [:coffi.mem/pointer :clong/AVVkFrame], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vk_frame_alloc, :raw-comment "/**\n * Allocates a single AVVkFrame and initializes everything as 0.\n * @note Must be freed via av_free()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vk_frame_alloc"} {:args [{:spelling "p", :type "enum AVPixelFormat"}], :ret {:spelling "const int *"}, :function/args [:coffi.mem/int], :symbol "av_vkfmt_from_pixfmt", :function/ret [:coffi.mem/pointer :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vkfmt_from_pixfmt, :raw-comment "/**\n * Returns the format of each image up to the number of planes for a given sw_format.\n * Returns NULL on unsupported formats.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vkfmt_from_pixfmt"} {:args [], :ret {:spelling "struct AVXTEA *"}, :function/args [], :symbol "av_xtea_alloc", :function/ret [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 64]], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xtea_alloc, :raw-comment "/**\n * Allocate an AVXTEA context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xtea_alloc"} {:args [{:spelling "ctx", :type "struct AVXTEA *"} {:spelling "key", :type "unsigned char const[16]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 64]] [:coffi.mem/array :coffi.mem/char 16]], :symbol "av_xtea_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xtea_init, :raw-comment "/**\n * Initialize an AVXTEA context.\n *\n * @param ctx an AVXTEA context\n * @param key a key of 16 bytes used for encryption/decryption,\n *            interpreted as big endian 32 bit numbers\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xtea_init"} {:args [{:spelling "ctx", :type "struct AVXTEA *"} {:spelling "key", :type "unsigned char const[16]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 64]] [:coffi.mem/array :coffi.mem/char 16]], :symbol "av_xtea_le_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xtea_le_init, :raw-comment "/**\n * Initialize an AVXTEA context.\n *\n * @param ctx an AVXTEA context\n * @param key a key of 16 bytes used for encryption/decryption,\n *            interpreted as little endian 32 bit numbers\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xtea_le_init"} {:args [{:spelling "ctx", :type "struct AVXTEA *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 64]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_xtea_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xtea_crypt, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context,\n * in big endian format.\n *\n * @param ctx an AVXTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xtea_crypt"} {:args [{:spelling "ctx", :type "struct AVXTEA *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 64]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_xtea_le_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xtea_le_crypt, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context,\n * in little endian format.\n *\n * @param ctx an AVXTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xtea_le_crypt"} {:args [{:spelling "ctx", :type "unsigned int *"} {:spelling "le", :type "int"} {:spelling "bits", :type "int"} {:spelling "poly", :type "unsigned int"} {:spelling "ctx_size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_crc_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_crc_init, :raw-comment "/**\n * Initialize a CRC table.\n * @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024\n * @param le If 1, the lowest bit represents the coefficient for the highest\n *           exponent of the corresponding polynomial (both for poly and\n *           actual CRC).\n *           If 0, you must swap the CRC parameter and the result of av_crc\n *           if you need the standard representation (can be simplified in\n *           most cases to e.g. bswap16):\n *           av_bswap32(crc << (32-bits))\n * @param bits number of bits for the CRC\n * @param poly generator polynomial without the x**bits coefficient, in the\n *             representation as specified by le\n * @param ctx_size size of ctx in bytes\n * @return <0 on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_crc_init"} {:args [{:spelling "crc_id", :type "AVCRCId"}], :ret {:spelling "const unsigned int *"}, :function/args [:coffi.mem/int], :symbol "av_crc_get_table", :function/ret [:coffi.mem/pointer :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_crc_get_table, :raw-comment "/**\n * Get an initialized standard CRC table.\n * @param crc_id ID of a standard CRC\n * @return a pointer to the CRC table or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_crc_get_table"} {:args [{:spelling "ctx", :type "const unsigned int *"} {:spelling "crc", :type "unsigned int"} {:spelling "buffer", :type "const unsigned char *"} {:spelling "length", :type "unsigned long"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_crc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_crc, :raw-comment "/**\n * Calculate the CRC of a block.\n * @param crc CRC of previous blocks if any or initial value for CRC\n * @return CRC updated with the data from the given block\n *\n * @see av_crc_init() \"le\" parameter\n */", :kind "CXCursor_FunctionDecl", :spelling "av_crc"} {:args [{:spelling "filename", :type "const char *"} {:spelling "bufptr", :type "unsigned char **"} {:spelling "size", :type "unsigned long *"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/long] :coffi.mem/int :coffi.mem/pointer], :symbol "av_file_map", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_file_map, :raw-comment "/**\n * Read the file with name filename, and put its content in a newly\n * allocated buffer or map it with mmap() when available.\n * In case of success set *bufptr to the read or mmapped buffer, and\n * *size to the size in bytes of the buffer in *bufptr.\n * Unlike mmap this function succeeds with zero sized files, in this\n * case *bufptr will be set to NULL and *size will be set to 0.\n * The returned buffer must be released with av_file_unmap().\n *\n * @param log_offset loglevel offset used for logging\n * @param log_ctx context used for logging\n * @return a non negative number in case of success, a negative value\n * corresponding to an AVERROR error code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_file_map"} {:args [{:spelling "bufptr", :type "unsigned char *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_file_unmap", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_file_unmap, :raw-comment "/**\n * Unmap or free the buffer bufptr created by av_file_map().\n *\n * @param size size in bytes of bufptr, must be the same as returned\n * by av_file_map()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_file_unmap"} {:args [{:spelling "prefix", :type "const char *"} {:spelling "filename", :type "char **"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int :coffi.mem/pointer], :symbol "av_tempfile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tempfile, :raw-comment "/**\n * Wrapper to work around the lack of mkstemp() on mingw.\n * Also, tries to create file in /tmp first, if possible.\n * *prefix can be a character constant; *filename will be allocated internally.\n * @return file descriptor of opened file (or negative value corresponding to an\n * AVERROR code on error)\n * and opened file name in **filename.\n * @note On very old libcs it is necessary to set a secure umask before\n *       calling this, av_tempfile() can't call umask itself as it is used in\n *       libraries and could interfere with the calling application.\n * @deprecated as fd numbers cannot be passed saftely between libs on some platforms\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tempfile"} {:args [], :ret {:spelling "struct AVMD5 *"}, :function/args [], :symbol "av_md5_alloc", :function/ret [:coffi.mem/pointer :clong/AVMD5], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_md5_alloc, :raw-comment "/**\n * Allocate an AVMD5 context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_md5_alloc"} {:args [{:spelling "ctx", :type "struct AVMD5 *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMD5]], :symbol "av_md5_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_md5_init, :raw-comment "/**\n * Initialize MD5 hashing.\n *\n * @param ctx pointer to the function context (of size av_md5_size)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_md5_init"} {:args [{:spelling "ctx", :type "struct AVMD5 *"} {:spelling "src", :type "const unsigned char *"} {:spelling "len", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMD5] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_md5_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_md5_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_md5_update"} {:args [{:spelling "ctx", :type "struct AVMD5 *"} {:spelling "dst", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVMD5] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_md5_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_md5_final, :raw-comment "/**\n * Finish hashing and output digest value.\n *\n * @param ctx hash function context\n * @param dst buffer where output digest value is stored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_md5_final"} {:args [{:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "len", :type "const int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_md5_sum", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_md5_sum, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_md5_sum"} {:args [], :ret {:spelling "struct AVCAST5 *"}, :function/args [], :symbol "av_cast5_alloc", :function/ret [:coffi.mem/pointer :clong/AVCAST5], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cast5_alloc, :raw-comment "/**\n  * Allocate an AVCAST5 context\n  * To free the struct: av_free(ptr)\n  */", :kind "CXCursor_FunctionDecl", :spelling "av_cast5_alloc"} {:args [{:spelling "ctx", :type "struct AVCAST5 *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCAST5] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_cast5_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cast5_init, :raw-comment "/**\n  * Initialize an AVCAST5 context.\n  *\n  * @param ctx an AVCAST5 context\n  * @param key a key of 5,6,...16 bytes used for encryption/decryption\n  * @param key_bits number of keybits: possible are 40,48,...,128\n  * @return 0 on success, less than 0 on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cast5_init"} {:args [{:spelling "ctx", :type "struct AVCAST5 *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCAST5] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_cast5_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cast5_crypt, :raw-comment "/**\n  * Encrypt or decrypt a buffer using a previously initialized context, ECB mode only\n  *\n  * @param ctx an AVCAST5 context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 8 byte blocks\n  * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cast5_crypt"} {:args [{:spelling "ctx", :type "struct AVCAST5 *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCAST5] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_cast5_crypt2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cast5_crypt2, :raw-comment "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVCAST5 context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 8 byte blocks\n  * @param iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cast5_crypt2"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVSphericalMapping *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_spherical_alloc", :function/ret [:coffi.mem/pointer :clong/AVSphericalMapping], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_spherical_alloc, :raw-comment "/**\n * Allocate a AVSphericalVideo structure and initialize its fields to default\n * values.\n *\n * @return the newly allocated struct or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_spherical_alloc"} {:args [{:spelling "map", :type "const struct AVSphericalMapping *"} {:spelling "width", :type "unsigned long"} {:spelling "height", :type "unsigned long"} {:spelling "left", :type "unsigned long *"} {:spelling "top", :type "unsigned long *"} {:spelling "right", :type "unsigned long *"} {:spelling "bottom", :type "unsigned long *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSphericalMapping] :coffi.mem/long :coffi.mem/long [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_spherical_tile_bounds", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_spherical_tile_bounds, :raw-comment "/**\n * Convert the @ref bounding fields from an AVSphericalVideo\n * from 0.32 fixed point to pixels.\n *\n * @param map    The AVSphericalVideo map to read bound values from.\n * @param width  Width of the current frame or stream.\n * @param height Height of the current frame or stream.\n * @param left   Pixels from the left edge.\n * @param top    Pixels from the top edge.\n * @param right  Pixels from the right edge.\n * @param bottom Pixels from the bottom edge.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_spherical_tile_bounds"} {:args [{:spelling "projection", :type "enum AVSphericalProjection"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_spherical_projection_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_spherical_projection_name, :raw-comment "/**\n * Provide a human-readable name of a given AVSphericalProjection.\n *\n * @param projection The input AVSphericalProjection.\n *\n * @return The name of the AVSphericalProjection, or \"unknown\".\n */", :kind "CXCursor_FunctionDecl", :spelling "av_spherical_projection_name"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_spherical_from_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_spherical_from_name, :raw-comment "/**\n * Get the AVSphericalProjection form a human-readable name.\n *\n * @param name The input string.\n *\n * @return The AVSphericalProjection value, or -1 if not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_spherical_from_name"} {:args [{:spelling "af", :type "struct AVAudioFifo *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo]], :symbol "av_audio_fifo_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_free, :raw-comment "/**\n * Free an AVAudioFifo.\n *\n * @param af  AVAudioFifo to free\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_free"} {:args [{:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "channels", :type "int"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "struct AVAudioFifo *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_audio_fifo_alloc", :function/ret [:coffi.mem/pointer :clong/AVAudioFifo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_alloc, :raw-comment "/**\n * Allocate an AVAudioFifo.\n *\n * @param sample_fmt  sample format\n * @param channels    number of channels\n * @param nb_samples  initial allocation size, in samples\n * @return            newly allocated AVAudioFifo, or NULL on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_alloc"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] :coffi.mem/int], :symbol "av_audio_fifo_realloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_realloc, :raw-comment "/**\n * Reallocate an AVAudioFifo.\n *\n * @param af          AVAudioFifo to reallocate\n * @param nb_samples  new allocation size, in samples\n * @return            0 if OK, or negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_realloc"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "data", :type "void **"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :symbol "av_audio_fifo_write", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_write, :raw-comment "/**\n * Write data to an AVAudioFifo.\n *\n * The AVAudioFifo will be reallocated automatically if the available space\n * is less than nb_samples.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to write to\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to write\n * @return            number of samples actually written, or negative AVERROR\n *                    code on failure. If successful, the number of samples\n *                    actually written will always be nb_samples.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_write"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "data", :type "void **"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :symbol "av_audio_fifo_peek", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_peek, :raw-comment "/**\n * Peek data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to peek\n * @return            number of samples actually peek, or negative AVERROR code\n *                    on failure. The number of samples actually peek will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_peek"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "data", :type "void **"} {:spelling "nb_samples", :type "int"} {:spelling "offset", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int :coffi.mem/int], :symbol "av_audio_fifo_peek_at", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_peek_at, :raw-comment "/**\n * Peek data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to peek\n * @param offset      offset from current read position\n * @return            number of samples actually peek, or negative AVERROR code\n *                    on failure. The number of samples actually peek will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_peek_at"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "data", :type "void **"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :symbol "av_audio_fifo_read", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_read, :raw-comment "/**\n * Read data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to read\n * @return            number of samples actually read, or negative AVERROR code\n *                    on failure. The number of samples actually read will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_read"} {:args [{:spelling "af", :type "struct AVAudioFifo *"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo] :coffi.mem/int], :symbol "av_audio_fifo_drain", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_drain, :raw-comment "/**\n * Drain data from an AVAudioFifo.\n *\n * Removes the data without reading it.\n *\n * @param af          AVAudioFifo to drain\n * @param nb_samples  number of samples to drain\n * @return            0 if OK, or negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_drain"} {:args [{:spelling "af", :type "struct AVAudioFifo *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo]], :symbol "av_audio_fifo_reset", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_reset, :raw-comment "/**\n * Reset the AVAudioFifo buffer.\n *\n * This empties all data in the buffer.\n *\n * @param af  AVAudioFifo to reset\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_reset"} {:args [{:spelling "af", :type "struct AVAudioFifo *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo]], :symbol "av_audio_fifo_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_size, :raw-comment "/**\n * Get the current number of samples in the AVAudioFifo available for reading.\n *\n * @param af  the AVAudioFifo to query\n * @return    number of samples available for reading\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_size"} {:args [{:spelling "af", :type "struct AVAudioFifo *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioFifo]], :symbol "av_audio_fifo_space", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_audio_fifo_space, :raw-comment "/**\n * Get the current number of samples in the AVAudioFifo available for writing.\n *\n * @param af  the AVAudioFifo to query\n * @return    number of samples available for writing\n */", :kind "CXCursor_FunctionDecl", :spelling "av_audio_fifo_space"} {:args [], :ret {:spelling "struct AVTreeNode *"}, :function/args [], :symbol "av_tree_node_alloc", :function/ret [:coffi.mem/pointer :clong/AVTreeNode], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tree_node_alloc, :raw-comment "/**\n * Allocate an AVTreeNode.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tree_node_alloc"} {:args [{:spelling "root", :type "const struct AVTreeNode *"} {:spelling "key", :type "void *"} {:spelling "cmp", :type "int (*)(const void *, const void *)"} {:spelling "next", :type "void *[2]"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVTreeNode] :coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int] [:coffi.mem/array :coffi.mem/pointer 2]], :symbol "av_tree_find", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tree_find, :raw-comment "/**\n * Find an element.\n * @param root a pointer to the root node of the tree\n * @param next If next is not NULL, then next[0] will contain the previous\n *             element and next[1] the next element. If either does not exist,\n *             then the corresponding entry in next is unchanged.\n * @param cmp compare function used to compare elements in the tree,\n *            API identical to that of Standard C's qsort\n *            It is guaranteed that the first and only the first argument to cmp()\n *            will be the key parameter to av_tree_find(), thus it could if the\n *            user wants, be a different type (like an opaque context).\n * @return An element with cmp(key, elem) == 0 or NULL if no such element\n *         exists in the tree.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tree_find"} {:args [{:spelling "rootp", :type "struct AVTreeNode **"} {:spelling "key", :type "void *"} {:spelling "cmp", :type "int (*)(const void *, const void *)"} {:spelling "next", :type "struct AVTreeNode **"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVTreeNode]] :coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVTreeNode]]], :symbol "av_tree_insert", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tree_insert, :raw-comment "/**\n * Insert or remove an element.\n *\n * If *next is NULL, then the supplied element will be removed if it exists.\n * If *next is non-NULL, then the supplied element will be inserted, unless\n * it already exists in the tree.\n *\n * @param rootp A pointer to a pointer to the root node of the tree; note that\n *              the root node can change during insertions, this is required\n *              to keep the tree balanced.\n * @param key  pointer to the element key to insert in the tree\n * @param next Used to allocate and free AVTreeNodes. For insertion the user\n *             must set it to an allocated and zeroed object of at least\n *             av_tree_node_size bytes size. av_tree_insert() will set it to\n *             NULL if it has been consumed.\n *             For deleting elements *next is set to NULL by the user and\n *             av_tree_insert() will set it to the AVTreeNode which was\n *             used for the removed element.\n *             This allows the use of flat arrays, which have\n *             lower overhead compared to many malloced elements.\n *             You might want to define a function like:\n *             @code\n *             void *tree_insert(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b),\n *                               AVTreeNode **next)\n *             {\n *                 if (!*next)\n *                     *next = av_mallocz(av_tree_node_size);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             void *tree_remove(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b, AVTreeNode **next))\n *             {\n *                 av_freep(next);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             @endcode\n * @param cmp compare function used to compare elements in the tree, API identical\n *            to that of Standard C's qsort\n * @return If no insertion happened, the found element; if an insertion or\n *         removal happened, then either key or NULL will be returned.\n *         Which one it is depends on the tree state and the implementation. You\n *         should make no assumptions that it's one or the other in the code.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tree_insert"} {:args [{:spelling "t", :type "struct AVTreeNode *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVTreeNode]], :symbol "av_tree_destroy", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tree_destroy, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_tree_destroy"} {:args [{:spelling "t", :type "struct AVTreeNode *"} {:spelling "opaque", :type "void *"} {:spelling "cmp", :type "int (*)(void *, void *)"} {:spelling "enu", :type "int (*)(void *, void *)"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVTreeNode] :coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int] [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int]], :symbol "av_tree_enumerate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tree_enumerate, :raw-comment "/**\n * Apply enu(opaque, &elem) to all the elements in the tree in a given range.\n *\n * @param cmp a comparison function that returns < 0 for an element below the\n *            range, > 0 for an element above the range and == 0 for an\n *            element inside the range\n *\n * @note The cmp function should use the same ordering used to construct the\n *       tree.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tree_enumerate"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue **"} {:spelling "nelem", :type "unsigned int"} {:spelling "elsize", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVThreadMessageQueue]] :coffi.mem/int :coffi.mem/int], :symbol "av_thread_message_queue_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_alloc, :raw-comment "/**\n * Allocate a new message queue.\n *\n * @param mq      pointer to the message queue\n * @param nelem   maximum number of elements in the queue\n * @param elsize  size of each element in the queue\n * @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if\n *          lavu was built without thread support\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_alloc"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVThreadMessageQueue]]], :symbol "av_thread_message_queue_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_free, :raw-comment "/**\n * Free a message queue.\n *\n * The message queue must no longer be in use by another thread.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_free"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"} {:spelling "msg", :type "void *"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue] :coffi.mem/pointer :coffi.mem/int], :symbol "av_thread_message_queue_send", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_send, :raw-comment "/**\n * Send a message on the queue.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_send"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"} {:spelling "msg", :type "void *"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue] :coffi.mem/pointer :coffi.mem/int], :symbol "av_thread_message_queue_recv", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_recv, :raw-comment "/**\n * Receive a message from the queue.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_recv"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"} {:spelling "err", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue] :coffi.mem/int], :symbol "av_thread_message_queue_set_err_send", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_set_err_send, :raw-comment "/**\n * Set the sending error code.\n *\n * If the error code is set to non-zero, av_thread_message_queue_send() will\n * return it immediately. Conventional values, such as AVERROR_EOF or\n * AVERROR(EAGAIN), can be used to cause the sending thread to stop or\n * suspend its operation.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_set_err_send"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"} {:spelling "err", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue] :coffi.mem/int], :symbol "av_thread_message_queue_set_err_recv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_set_err_recv, :raw-comment "/**\n * Set the receiving error code.\n *\n * If the error code is set to non-zero, av_thread_message_queue_recv() will\n * return it immediately when there are no longer available messages.\n * Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used\n * to cause the receiving thread to stop or suspend its operation.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_set_err_recv"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"} {:spelling "free_func", :type "void (*)(void *)"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue] [:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/void]], :symbol "av_thread_message_queue_set_free_func", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_set_free_func, :raw-comment "/**\n * Set the optional free message callback function which will be called if an\n * operation is removing messages from the queue.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_set_free_func"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue]], :symbol "av_thread_message_queue_nb_elems", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_queue_nb_elems, :raw-comment "/**\n * Return the current number of messages in the queue.\n *\n * @return the current number of messages or AVERROR(ENOSYS) if lavu was built\n *         without thread support\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_queue_nb_elems"} {:args [{:spelling "mq", :type "struct AVThreadMessageQueue *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVThreadMessageQueue]], :symbol "av_thread_message_flush", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_thread_message_flush, :raw-comment "/**\n * Flush the message queue\n *\n * This function is mostly equivalent to reading and free-ing every message\n * except that it will be done in a single operation (no lock/unlock between\n * reads).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_thread_message_flush"} {:args [{:spelling "adler", :type "unsigned long"} {:spelling "buf", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"}], :ret {:spelling "unsigned long"}, :function/args [:coffi.mem/long [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_adler32_update", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_adler32_update, :raw-comment "/**\n * Calculate the Adler32 checksum of a buffer.\n *\n * Passing the return value to a subsequent av_adler32_update() call\n * allows the checksum of multiple buffers to be calculated as though\n * they were concatenated.\n *\n * @param adler initial checksum value\n * @param buf   pointer to input buffer\n * @param len   size of input buffer\n * @return      updated checksum\n */", :kind "CXCursor_FunctionDecl", :spelling "av_adler32_update"} {:args [{:spelling "framenum", :type "int"} {:spelling "fps", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_timecode_adjust_ntsc_framenum2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_adjust_ntsc_framenum2, :raw-comment "/**\n * Adjust frame number for NTSC drop frame time code.\n *\n * @param framenum frame number to adjust\n * @param fps      frame per second, multiples of 30\n * @return         adjusted frame number\n * @warning        adjustment is only valid for multiples of NTSC 29.97\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_adjust_ntsc_framenum2"} {:args [{:spelling "tc", :type "const AVTimecode *"} {:spelling "framenum", :type "int"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVTimecode] :coffi.mem/int], :symbol "av_timecode_get_smpte_from_framenum", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_get_smpte_from_framenum, :raw-comment "/**\n * Convert frame number to SMPTE 12M binary representation.\n *\n * @param tc       timecode data correctly initialized\n * @param framenum frame number\n * @return         the SMPTE binary representation\n *\n * See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\"\n * the format description as follows:\n * bits 0-5:   hours, in BCD(6bits)\n * bits 6:     BGF1\n * bits 7:     BGF2 (NTSC) or FIELD (PAL)\n * bits 8-14:  minutes, in BCD(7bits)\n * bits 15:    BGF0 (NTSC) or BGF2 (PAL)\n * bits 16-22: seconds, in BCD(7bits)\n * bits 23:    FIELD (NTSC) or BGF0 (PAL)\n * bits 24-29: frames, in BCD(6bits)\n * bits 30:    drop  frame flag (0: non drop,    1: drop)\n * bits 31:    color frame flag (0: unsync mode, 1: sync mode)\n * @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.\n * @note Frame number adjustment is automatically done in case of drop timecode,\n *       you do NOT have to call av_timecode_adjust_ntsc_framenum2().\n * @note The frame number is relative to tc->start.\n * @note Color frame (CF) and binary group flags (BGF) bits are set to zero.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_get_smpte_from_framenum"} {:args [{:spelling "rate", :type "struct AVRational"} {:spelling "drop", :type "int"} {:spelling "hh", :type "int"} {:spelling "mm", :type "int"} {:spelling "ss", :type "int"} {:spelling "ff", :type "int"}], :ret {:spelling "unsigned int"}, :function/args [:clong/AVRational :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_timecode_get_smpte", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_get_smpte, :raw-comment "/**\n * Convert sei info to SMPTE 12M binary representation.\n *\n * @param rate     frame rate in rational form\n * @param drop     drop flag\n * @param hh       hour\n * @param mm       minute\n * @param ss       second\n * @param ff       frame number\n * @return         the SMPTE binary representation\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_get_smpte"} {:args [{:spelling "tc", :type "const AVTimecode *"} {:spelling "buf", :type "char *"} {:spelling "framenum", :type "int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :clong/AVTimecode] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_timecode_make_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_make_string, :raw-comment "/**\n * Load timecode string in buf.\n *\n * @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param tc       timecode data correctly initialized\n * @param framenum frame number\n * @return         the buf parameter\n *\n * @note Timecode representation can be a negative timecode and have more than\n *       24 hours, but will only be honored if the flags are correctly set.\n * @note The frame number is relative to tc->start.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_make_string"} {:args [{:spelling "buf", :type "char *"} {:spelling "rate", :type "struct AVRational"} {:spelling "tcsmpte", :type "unsigned int"} {:spelling "prevent_df", :type "int"} {:spelling "skip_field", :type "int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :clong/AVRational :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_timecode_make_smpte_tc_string2", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_make_smpte_tc_string2, :raw-comment "/**\n * Get the timecode string from the SMPTE timecode format.\n *\n * In contrast to av_timecode_make_smpte_tc_string this function supports 50/60\n * fps timecodes by using the field bit.\n *\n * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param rate       frame rate of the timecode\n * @param tcsmpte    the 32-bit SMPTE timecode\n * @param prevent_df prevent the use of a drop flag when it is known the DF bit\n *                   is arbitrary\n * @param skip_field prevent the use of a field flag when it is known the field\n *                   bit is arbitrary (e.g. because it is used as PC flag)\n * @return           the buf parameter\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_make_smpte_tc_string2"} {:args [{:spelling "buf", :type "char *"} {:spelling "tcsmpte", :type "unsigned int"} {:spelling "prevent_df", :type "int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_timecode_make_smpte_tc_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_make_smpte_tc_string, :raw-comment "/**\n * Get the timecode string from the SMPTE timecode format.\n *\n * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param tcsmpte    the 32-bit SMPTE timecode\n * @param prevent_df prevent the use of a drop flag when it is known the DF bit\n *                   is arbitrary\n * @return           the buf parameter\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_make_smpte_tc_string"} {:args [{:spelling "buf", :type "char *"} {:spelling "tc25bit", :type "unsigned int"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_timecode_make_mpeg_tc_string", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_make_mpeg_tc_string, :raw-comment "/**\n * Get the timecode string from the 25-bit timecode format (MPEG GOP format).\n *\n * @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param tc25bit the 25-bits timecode\n * @return        the buf parameter\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_make_mpeg_tc_string"} {:args [{:spelling "tc", :type "AVTimecode *"} {:spelling "rate", :type "struct AVRational"} {:spelling "flags", :type "int"} {:spelling "frame_start", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVTimecode] :clong/AVRational :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_timecode_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_init, :raw-comment "/**\n * Init a timecode struct with the passed parameters.\n *\n * @param log_ctx     a pointer to an arbitrary struct of which the first field\n *                    is a pointer to an AVClass struct (used for av_log)\n * @param tc          pointer to an allocated AVTimecode\n * @param rate        frame rate in rational form\n * @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n *                    (see AVTimecodeFlag)\n * @param frame_start the first frame number\n * @return            0 on success, AVERROR otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_init"} {:args [{:spelling "tc", :type "AVTimecode *"} {:spelling "rate", :type "struct AVRational"} {:spelling "flags", :type "int"} {:spelling "hh", :type "int"} {:spelling "mm", :type "int"} {:spelling "ss", :type "int"} {:spelling "ff", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVTimecode] :clong/AVRational :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_timecode_init_from_components", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_init_from_components, :raw-comment "/**\n * Init a timecode struct from the passed timecode components.\n *\n * @param log_ctx     a pointer to an arbitrary struct of which the first field\n *                    is a pointer to an AVClass struct (used for av_log)\n * @param tc          pointer to an allocated AVTimecode\n * @param rate        frame rate in rational form\n * @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n *                    (see AVTimecodeFlag)\n * @param hh          hours\n * @param mm          minutes\n * @param ss          seconds\n * @param ff          frames\n * @return            0 on success, AVERROR otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_init_from_components"} {:args [{:spelling "tc", :type "AVTimecode *"} {:spelling "rate", :type "struct AVRational"} {:spelling "str", :type "const char *"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVTimecode] :clong/AVRational [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/pointer], :symbol "av_timecode_init_from_string", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_init_from_string, :raw-comment "/**\n * Parse timecode representation (hh:mm:ss[:;.]ff).\n *\n * @param log_ctx a pointer to an arbitrary struct of which the first field is a\n *                pointer to an AVClass struct (used for av_log).\n * @param tc      pointer to an allocated AVTimecode\n * @param rate    frame rate in rational form\n * @param str     timecode string which will determine the frame start\n * @return        0 on success, AVERROR otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_init_from_string"} {:args [{:spelling "rate", :type "struct AVRational"}], :ret {:spelling "int"}, :function/args [:clong/AVRational], :symbol "av_timecode_check_frame_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timecode_check_frame_rate, :raw-comment "/**\n * Check if the timecode feature is available for the given frame rate\n *\n * @return 0 if supported, <0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timecode_check_frame_rate"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVDOVIDecoderConfigurationRecord *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_dovi_alloc", :function/ret [:coffi.mem/pointer :clong/AVDOVIDecoderConfigurationRecord], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dovi_alloc, :raw-comment "/**\n * Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its\n * fields to default values.\n *\n * @return the newly allocated struct or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dovi_alloc"} {:args [{:spelling "ctx", :type "struct AVTXContext **"} {:spelling "tx", :type "void (**)(struct AVTXContext *, void *, void *, long)"} {:spelling "type", :type "enum AVTXType"} {:spelling "inv", :type "int"} {:spelling "len", :type "int"} {:spelling "scale", :type "const void *"} {:spelling "flags", :type "unsigned long long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVTXContext]] [:coffi.mem/pointer [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVTXContext] :coffi.mem/pointer :coffi.mem/pointer :coffi.mem/long] :coffi.mem/void]] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer :coffi.mem/long], :symbol "av_tx_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tx_init, :raw-comment "/**\n * Initialize a transform context with the given configuration\n * (i)MDCTs with an odd length are currently not supported.\n *\n * @param ctx the context to allocate, will be NULL on error\n * @param tx pointer to the transform function pointer to set\n * @param type type the type of transform\n * @param inv whether to do an inverse or a forward transform\n * @param len the size of the transform in samples\n * @param scale pointer to the value to scale the output if supported by type\n * @param flags a bitmask of AVTXFlags or 0\n *\n * @return 0 on success, negative error code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tx_init"} {:args [{:spelling "ctx", :type "struct AVTXContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVTXContext]]], :symbol "av_tx_uninit", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tx_uninit, :raw-comment "/**\n * Frees a context and sets ctx to NULL, does nothing when ctx == NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tx_uninit"} {:args [], :ret {:spelling "struct AVSHA512 *"}, :function/args [], :symbol "av_sha512_alloc", :function/ret [:coffi.mem/pointer :clong/AVSHA512], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha512_alloc, :raw-comment "/**\n * Allocate an AVSHA512 context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha512_alloc"} {:args [{:spelling "context", :type "struct AVSHA512 *"} {:spelling "bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVSHA512] :coffi.mem/int], :symbol "av_sha512_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha512_init, :raw-comment "/**\n * Initialize SHA-2 512 hashing.\n *\n * @param context pointer to the function context (of size av_sha512_size)\n * @param bits    number of bits in digest (224, 256, 384 or 512 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha512_init"} {:args [{:spelling "context", :type "struct AVSHA512 *"} {:spelling "data", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSHA512] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_sha512_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha512_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_sha512_update"} {:args [{:spelling "context", :type "struct AVSHA512 *"} {:spelling "digest", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSHA512] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_sha512_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sha512_final, :raw-comment "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sha512_final"} {:args [{:spelling "matrix", :type "int const[9]"}], :ret {:spelling "double"}, :function/args [[:coffi.mem/array :coffi.mem/int 9]], :symbol "av_display_rotation_get", :function/ret :coffi.mem/double, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_display_rotation_get, :raw-comment "/**\n * Extract the rotation component of the transformation matrix.\n *\n * @param matrix the transformation matrix\n * @return the angle (in degrees) by which the transformation rotates the frame\n *         counterclockwise. The angle will be in range [-180.0, 180.0],\n *         or NaN if the matrix is singular.\n *\n * @note floating point numbers are inherently inexact, so callers are\n *       recommended to round the return value to nearest integer before use.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_display_rotation_get"} {:args [{:spelling "matrix", :type "int [9]"} {:spelling "angle", :type "double"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/array :coffi.mem/int 9] :coffi.mem/double], :symbol "av_display_rotation_set", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_display_rotation_set, :raw-comment "/**\n * Initialize a transformation matrix describing a pure counterclockwise\n * rotation by the specified angle (in degrees).\n *\n * @param matrix an allocated transformation matrix (will be fully overwritten\n *               by this function)\n * @param angle rotation angle in degrees.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_display_rotation_set"} {:args [{:spelling "matrix", :type "int [9]"} {:spelling "hflip", :type "int"} {:spelling "vflip", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/array :coffi.mem/int 9] :coffi.mem/int :coffi.mem/int], :symbol "av_display_matrix_flip", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_display_matrix_flip, :raw-comment "/**\n * Flip the input matrix horizontally and/or vertically.\n *\n * @param matrix an allocated transformation matrix\n * @param hflip whether the matrix should be flipped horizontally\n * @param vflip whether the matrix should be flipped vertically\n */", :kind "CXCursor_FunctionDecl", :spelling "av_display_matrix_flip"} {:args [], :ret {:spelling "struct AVCAMELLIA *"}, :function/args [], :symbol "av_camellia_alloc", :function/ret [:coffi.mem/pointer :clong/AVCAMELLIA], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_camellia_alloc, :raw-comment "/**\n  * Allocate an AVCAMELLIA context\n  * To free the struct: av_free(ptr)\n  */", :kind "CXCursor_FunctionDecl", :spelling "av_camellia_alloc"} {:args [{:spelling "ctx", :type "struct AVCAMELLIA *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCAMELLIA] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_camellia_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_camellia_init, :raw-comment "/**\n  * Initialize an AVCAMELLIA context.\n  *\n  * @param ctx an AVCAMELLIA context\n  * @param key a key of 16, 24, 32 bytes used for encryption/decryption\n  * @param key_bits number of keybits: possible are 128, 192, 256\n */", :kind "CXCursor_FunctionDecl", :spelling "av_camellia_init"} {:args [{:spelling "ctx", :type "struct AVCAMELLIA *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCAMELLIA] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_camellia_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_camellia_crypt, :raw-comment "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVCAMELLIA context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 16 byte blocks\n  * @paran iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_camellia_crypt"} {:args [{:spelling "w_bits", :type "int"} {:spelling "h_bits", :type "int"} {:spelling "aligned", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int (*)(const unsigned char *, long, const unsigned char *, long)"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_pixelutils_get_sad_fn", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long] :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pixelutils_get_sad_fn, :raw-comment "/**\n * Get a potentially optimized pointer to a Sum-of-absolute-differences\n * function (see the av_pixelutils_sad_fn prototype).\n *\n * @param w_bits  1<<w_bits is the requested width of the block size\n * @param h_bits  1<<h_bits is the requested height of the block size\n * @param aligned If set to 2, the returned sad function will assume src1 and\n *                src2 addresses are aligned on the block size.\n *                If set to 1, the returned sad function will assume src1 is\n *                aligned on the block size.\n *                If set to 0, the returned sad function assume no particular\n *                alignment.\n * @param log_ctx context used for logging, can be NULL\n *\n * @return a pointer to the SAD function or NULL in case of error (because of\n *         invalid parameters)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pixelutils_get_sad_fn"} {:args [{:spelling "type", :type "enum AVHMACType"}], :ret {:spelling "struct AVHMAC *"}, :function/args [:coffi.mem/int], :symbol "av_hmac_alloc", :function/ret [:coffi.mem/pointer :clong/AVHMAC], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_alloc, :raw-comment "/**\n * Allocate an AVHMAC context.\n * @param type The hash function used for the HMAC.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_alloc"} {:args [{:spelling "ctx", :type "struct AVHMAC *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHMAC]], :symbol "av_hmac_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_free, :raw-comment "/**\n * Free an AVHMAC context.\n * @param ctx The context to free, may be NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_free"} {:args [{:spelling "ctx", :type "struct AVHMAC *"} {:spelling "key", :type "const unsigned char *"} {:spelling "keylen", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHMAC] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hmac_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_init, :raw-comment "/**\n * Initialize an AVHMAC context with an authentication key.\n * @param ctx    The HMAC context\n * @param key    The authentication key\n * @param keylen The length of the key, in bytes\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_init"} {:args [{:spelling "ctx", :type "struct AVHMAC *"} {:spelling "data", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHMAC] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hmac_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_update, :raw-comment "/**\n * Hash data with the HMAC.\n * @param ctx  The HMAC context\n * @param data The data to hash\n * @param len  The length of the data, in bytes\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_update"} {:args [{:spelling "ctx", :type "struct AVHMAC *"} {:spelling "out", :type "unsigned char *"} {:spelling "outlen", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVHMAC] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hmac_final", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_final, :raw-comment "/**\n * Finish hashing and output the HMAC digest.\n * @param ctx    The HMAC context\n * @param out    The output buffer to write the digest into\n * @param outlen The length of the out buffer, in bytes\n * @return       The number of bytes written to out, or a negative error code.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_final"} {:args [{:spelling "ctx", :type "struct AVHMAC *"} {:spelling "data", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"} {:spelling "key", :type "const unsigned char *"} {:spelling "keylen", :type "unsigned int"} {:spelling "out", :type "unsigned char *"} {:spelling "outlen", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVHMAC] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hmac_calc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hmac_calc, :raw-comment "/**\n * Hash an array of data with a key.\n * @param ctx    The HMAC context\n * @param data   The data to hash\n * @param len    The length of the data, in bytes\n * @param key    The authentication key\n * @param keylen The length of the key, in bytes\n * @param out    The output buffer to write the digest into\n * @param outlen The length of the out buffer, in bytes\n * @return       The number of bytes written to out, or a negative error code.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hmac_calc"} {:args [{:spelling "res", :type "double *"} {:spelling "s", :type "const char *"} {:spelling "const_names", :type "const char *const *"} {:spelling "const_values", :type "const double *"} {:spelling "func1_names", :type "const char *const *"} {:spelling "funcs1", :type "double (*const *)(void *, double)"} {:spelling "func2_names", :type "const char *const *"} {:spelling "funcs2", :type "double (*const *)(void *, double, double)"} {:spelling "opaque", :type "void *"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/double] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/double] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/double]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/double :coffi.mem/double] :coffi.mem/double]] :coffi.mem/pointer :coffi.mem/int :coffi.mem/pointer], :symbol "av_expr_parse_and_eval", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_parse_and_eval, :raw-comment "/**\n * Parse and evaluate an expression.\n * Note, this is significantly slower than av_expr_eval().\n *\n * @param res a pointer to a double where is put the result value of\n * the expression, or NAN in case of error\n * @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n * @param const_values a zero terminated array of values for the identifiers from const_names\n * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n * @param log_ctx parent logging context\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_parse_and_eval"} {:args [{:spelling "expr", :type "struct AVExpr **"} {:spelling "s", :type "const char *"} {:spelling "const_names", :type "const char *const *"} {:spelling "func1_names", :type "const char *const *"} {:spelling "funcs1", :type "double (*const *)(void *, double)"} {:spelling "func2_names", :type "const char *const *"} {:spelling "funcs2", :type "double (*const *)(void *, double, double)"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVExpr]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/double]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/double :coffi.mem/double] :coffi.mem/double]] :coffi.mem/int :coffi.mem/pointer], :symbol "av_expr_parse", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_parse, :raw-comment "/**\n * Parse an expression.\n *\n * @param expr a pointer where is put an AVExpr containing the parsed\n * value in case of successful parsing, or NULL otherwise.\n * The pointed to AVExpr must be freed with av_expr_free() by the user\n * when it is not needed anymore.\n * @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n * @param log_ctx parent logging context\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_parse"} {:args [{:spelling "e", :type "struct AVExpr *"} {:spelling "const_values", :type "const double *"} {:spelling "opaque", :type "void *"}], :ret {:spelling "double"}, :function/args [[:coffi.mem/pointer :clong/AVExpr] [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/pointer], :symbol "av_expr_eval", :function/ret :coffi.mem/double, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_eval, :raw-comment "/**\n * Evaluate a previously parsed expression.\n *\n * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names\n * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n * @return the value of the expression\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_eval"} {:args [{:spelling "e", :type "struct AVExpr *"} {:spelling "counter", :type "unsigned int *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVExpr] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "av_expr_count_vars", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_count_vars, :raw-comment "/**\n * Track the presence of variables and their number of occurrences in a parsed expression\n *\n * @param counter a zero-initialized array where the count of each variable will be stored\n * @param size size of array\n * @return 0 on success, a negative value indicates that no expression or array was passed\n * or size was zero\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_count_vars"} {:args [{:spelling "e", :type "struct AVExpr *"} {:spelling "counter", :type "unsigned int *"} {:spelling "size", :type "int"} {:spelling "arg", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVExpr] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int], :symbol "av_expr_count_func", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_count_func, :raw-comment "/**\n * Track the presence of user provided functions and their number of occurrences\n * in a parsed expression.\n *\n * @param counter a zero-initialized array where the count of each function will be stored\n *                if you passed 5 functions with 2 arguments to av_expr_parse()\n *                then for arg=2 this will use upto 5 entries.\n * @param size size of array\n * @param arg number of arguments the counted functions have\n * @return 0 on success, a negative value indicates that no expression or array was passed\n * or size was zero\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_count_func"} {:args [{:spelling "e", :type "struct AVExpr *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVExpr]], :symbol "av_expr_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_expr_free, :raw-comment "/**\n * Free a parsed expression previously created with av_expr_parse().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_expr_free"} {:args [{:spelling "numstr", :type "const char *"} {:spelling "tail", :type "char **"}], :ret {:spelling "double"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_strtod", :function/ret :coffi.mem/double, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strtod, :raw-comment "/**\n * Parse the string in numstr and return its value as a double. If\n * the string is empty, contains only whitespaces, or does not contain\n * an initial substring that has the expected syntax for a\n * floating-point number, no conversion is performed. In this case,\n * returns a value of zero and the value returned in tail is the value\n * of numstr.\n *\n * @param numstr a string representing a number, may contain one of\n * the International System number postfixes, for example 'K', 'M',\n * 'G'. If 'i' is appended after the postfix, powers of 2 are used\n * instead of powers of 10. The 'B' postfix multiplies the value by\n * 8, and can be appended after another postfix or used alone. This\n * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.\n * @param tail if non-NULL puts here the pointer to the char next\n * after the last parsed character\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strtod"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "av_get_random_seed", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_random_seed, :raw-comment "/**\n * Get a seed to use in conjunction with random functions.\n * This function tries to provide a good seed at a best effort bases.\n * Its possible to call this function multiple times if more bits are needed.\n * It can be quite slow, which is why it should only be used as seed for a faster\n * PRNG. The quality of the seed depends on the platform.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_random_seed"} {:args [{:spelling "obj", :type "void *"} {:spelling "av_log_obj", :type "void *"} {:spelling "req_flags", :type "int"} {:spelling "rej_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "av_opt_show2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_show2, :raw-comment "/**\n * Show the obj options.\n *\n * @param req_flags requested flags for the options to show. Show only the\n * options for which it is opt->flags & req_flags.\n * @param rej_flags rejected flags for the options to show. Show only the\n * options for which it is !(opt->flags & req_flags).\n * @param av_log_obj log context to use for showing the options\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_show2"} {:args [{:spelling "s", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "av_opt_set_defaults", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_defaults, :raw-comment "/**\n * Set the values of all AVOption fields to their default values.\n *\n * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_defaults"} {:args [{:spelling "s", :type "void *"} {:spelling "mask", :type "int"} {:spelling "flags", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "av_opt_set_defaults2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_defaults2, :raw-comment "/**\n * Set the values of all AVOption fields to their default values. Only these\n * AVOption fields for which (opt->flags & mask) == flags will have their\n * default applied to s.\n *\n * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n * @param mask combination of AV_OPT_FLAG_*\n * @param flags combination of AV_OPT_FLAG_*\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_defaults2"} {:args [{:spelling "ctx", :type "void *"} {:spelling "opts", :type "const char *"} {:spelling "key_val_sep", :type "const char *"} {:spelling "pairs_sep", :type "const char *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_set_options_string", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_set_options_string, :raw-comment "/**\n * Parse the key/value pairs list in opts. For each key/value pair\n * found, stores the value in the field in ctx that is named like the\n * key. ctx must be an AVClass context, storing is done using\n * AVOptions.\n *\n * @param opts options string to parse, may be NULL\n * @param key_val_sep a 0-terminated list of characters used to\n * separate key from value\n * @param pairs_sep a 0-terminated list of characters used to separate\n * two pairs from each other\n * @return the number of successfully set key/value pairs, or a negative\n * value corresponding to an AVERROR code in case of error:\n * AVERROR(EINVAL) if opts cannot be parsed,\n * the error code issued by av_opt_set() if a key/value pair\n * cannot be set\n */", :kind "CXCursor_FunctionDecl", :spelling "av_set_options_string"} {:args [{:spelling "ctx", :type "void *"} {:spelling "opts", :type "const char *"} {:spelling "shorthand", :type "const char *const *"} {:spelling "key_val_sep", :type "const char *"} {:spelling "pairs_sep", :type "const char *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_opt_set_from_string", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_from_string, :raw-comment "/**\n * Parse the key-value pairs list in opts. For each key=value pair found,\n * set the value of the corresponding option in ctx.\n *\n * @param ctx          the AVClass object to set options on\n * @param opts         the options string, key-value pairs separated by a\n *                     delimiter\n * @param shorthand    a NULL-terminated array of options names for shorthand\n *                     notation: if the first field in opts has no key part,\n *                     the key is taken from the first element of shorthand;\n *                     then again for the second, etc., until either opts is\n *                     finished, shorthand is finished or a named option is\n *                     found; after that, all options must be named\n * @param key_val_sep  a 0-terminated list of characters used to separate\n *                     key from value, for example '='\n * @param pairs_sep    a 0-terminated list of characters used to separate\n *                     two pairs from each other, for example ':' or ','\n * @return  the number of successfully set key=value pairs, or a negative\n *          value corresponding to an AVERROR code in case of error:\n *          AVERROR(EINVAL) if opts cannot be parsed,\n *          the error code issued by av_set_string3() if a key/value pair\n *          cannot be set\n *\n * Options names must use only the following characters: a-z A-Z 0-9 - . / _\n * Separators must use characters distinct from option names and from each\n * other.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_from_string"} {:args [{:spelling "obj", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "av_opt_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_free, :raw-comment "/**\n * Free all allocated objects in obj.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_free"} {:args [{:spelling "obj", :type "void *"} {:spelling "field_name", :type "const char *"} {:spelling "flag_name", :type "const char *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_opt_flag_is_set", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_flag_is_set, :raw-comment "/**\n * Check whether a particular flag is set in a flags field.\n *\n * @param field_name the name of the flag field option\n * @param flag_name the name of the flag to check\n * @return non-zero if the flag is set, zero if the flag isn't set,\n *         isn't of the right type, or the flags field doesn't exist.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_flag_is_set"} {:args [{:spelling "obj", :type "void *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "av_opt_set_dict", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_dict, :raw-comment "/**\n * Set all the options from a given dictionary on an object.\n *\n * @param obj a struct whose first element is a pointer to AVClass\n * @param options options to process. This dictionary will be freed and replaced\n *                by a new one containing all options not found in obj.\n *                Of course this new dictionary needs to be freed by caller\n *                with av_dict_free().\n *\n * @return 0 on success, a negative AVERROR if some option was found in obj,\n *         but could not be set.\n *\n * @see av_dict_copy()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_dict"} {:args [{:spelling "obj", :type "void *"} {:spelling "options", :type "struct AVDictionary **"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]] :coffi.mem/int], :symbol "av_opt_set_dict2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_dict2, :raw-comment "/**\n * Set all the options from a given dictionary on an object.\n *\n * @param obj a struct whose first element is a pointer to AVClass\n * @param options options to process. This dictionary will be freed and replaced\n *                by a new one containing all options not found in obj.\n *                Of course this new dictionary needs to be freed by caller\n *                with av_dict_free().\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n *\n * @return 0 on success, a negative AVERROR if some option was found in obj,\n *         but could not be set.\n *\n * @see av_dict_copy()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_dict2"} {:args [{:spelling "ropts", :type "const char **"} {:spelling "key_val_sep", :type "const char *"} {:spelling "pairs_sep", :type "const char *"} {:spelling "flags", :type "unsigned int"} {:spelling "rkey", :type "char **"} {:spelling "rval", :type "char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_opt_get_key_value", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_key_value, :raw-comment "/**\n * Extract a key-value pair from the beginning of a string.\n *\n * @param ropts        pointer to the options string, will be updated to\n *                     point to the rest of the string (one of the pairs_sep\n *                     or the final NUL)\n * @param key_val_sep  a 0-terminated list of characters used to separate\n *                     key from value, for example '='\n * @param pairs_sep    a 0-terminated list of characters used to separate\n *                     two pairs from each other, for example ':' or ','\n * @param flags        flags; see the AV_OPT_FLAG_* values below\n * @param rkey         parsed key; must be freed using av_free()\n * @param rval         parsed value; must be freed using av_free()\n *\n * @return  >=0 for success, or a negative value corresponding to an\n *          AVERROR code in case of error; in particular:\n *          AVERROR(EINVAL) if no key is present\n *\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_key_value"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "flags_out", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_opt_eval_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_flags, :raw-comment "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_flags"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "int_out", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_opt_eval_int", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_int, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_int"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "int64_out", :type "long long *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_opt_eval_int64", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_int64, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_int64"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "float_out", :type "float *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_opt_eval_float", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_float, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_float"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "double_out", :type "double *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/double]], :symbol "av_opt_eval_double", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_double, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_double"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"} {:spelling "val", :type "const char *"} {:spelling "q_out", :type "struct AVRational *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVRational]], :symbol "av_opt_eval_q", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_eval_q, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_eval_q"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "unit", :type "const char *"} {:spelling "opt_flags", :type "int"} {:spelling "search_flags", :type "int"}], :ret {:spelling "const struct AVOption *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_opt_find", :function/ret [:coffi.mem/pointer :clong/AVOption], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_find, :raw-comment "/**\n * Look for an option in an object. Consider only options which\n * have all the specified flags set.\n *\n * @param[in] obj A pointer to a struct whose first element is a\n *                pointer to an AVClass.\n *                Alternatively a double pointer to an AVClass, if\n *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n * @param[in] name The name of the option to look for.\n * @param[in] unit When searching for named constants, name of the unit\n *                 it belongs to.\n * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n *\n * @return A pointer to the option found, or NULL if no option\n *         was found.\n *\n * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable\n * directly with av_opt_set(). Use special calls which take an options\n * AVDictionary (e.g. avformat_open_input()) to set options found with this\n * flag.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_find"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "unit", :type "const char *"} {:spelling "opt_flags", :type "int"} {:spelling "search_flags", :type "int"} {:spelling "target_obj", :type "void **"}], :ret {:spelling "const struct AVOption *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_opt_find2", :function/ret [:coffi.mem/pointer :clong/AVOption], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_find2, :raw-comment "/**\n * Look for an option in an object. Consider only options which\n * have all the specified flags set.\n *\n * @param[in] obj A pointer to a struct whose first element is a\n *                pointer to an AVClass.\n *                Alternatively a double pointer to an AVClass, if\n *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n * @param[in] name The name of the option to look for.\n * @param[in] unit When searching for named constants, name of the unit\n *                 it belongs to.\n * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n * @param[out] target_obj if non-NULL, an object to which the option belongs will be\n * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present\n * in search_flags. This parameter is ignored if search_flags contain\n * AV_OPT_SEARCH_FAKE_OBJ.\n *\n * @return A pointer to the option found, or NULL if no option\n *         was found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_find2"} {:args [{:spelling "obj", :type "const void *"} {:spelling "prev", :type "const struct AVOption *"}], :ret {:spelling "const struct AVOption *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption]], :symbol "av_opt_next", :function/ret [:coffi.mem/pointer :clong/AVOption], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_next, :raw-comment "/**\n * Iterate over all AVOptions belonging to obj.\n *\n * @param obj an AVOptions-enabled struct or a double pointer to an\n *            AVClass describing it.\n * @param prev result of the previous call to av_opt_next() on this object\n *             or NULL\n * @return next AVOption or NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_next"} {:args [{:spelling "obj", :type "void *"} {:spelling "prev", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer], :symbol "av_opt_child_next", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_child_next, :raw-comment "/**\n * Iterate over AVOptions-enabled children of obj.\n *\n * @param prev result of a previous call to this function or NULL\n * @return next AVOptions-enabled child or NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_child_next"} {:args [{:spelling "parent", :type "const struct AVClass *"} {:spelling "prev", :type "const struct AVClass *"}], :ret {:spelling "const struct AVClass *"}, :function/args [[:coffi.mem/pointer :clong/AVClass] [:coffi.mem/pointer :clong/AVClass]], :symbol "av_opt_child_class_next", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_child_class_next, :raw-comment "/**\n * Iterate over potential AVOptions-enabled children of parent.\n *\n * @param prev result of a previous call to this function or NULL\n * @return AVClass corresponding to next potential child or NULL\n *\n * @deprecated use av_opt_child_class_iterate\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_child_class_next"} {:args [{:spelling "parent", :type "const struct AVClass *"} {:spelling "iter", :type "void **"}], :ret {:spelling "const struct AVClass *"}, :function/args [[:coffi.mem/pointer :clong/AVClass] [:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_opt_child_class_iterate", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_child_class_iterate, :raw-comment "/**\n * Iterate over potential AVOptions-enabled children of parent.\n *\n * @param iter a pointer where iteration state is stored.\n * @return AVClass corresponding to next potential child or NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_child_class_iterate"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "const char *"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_opt_set", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set, :raw-comment "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "long long"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long :coffi.mem/int], :symbol "av_opt_set_int", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_int, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_int"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "double"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/double :coffi.mem/int], :symbol "av_opt_set_double", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_double, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_double"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "struct AVRational"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :clong/AVRational :coffi.mem/int], :symbol "av_opt_set_q", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_q, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_q"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "const unsigned char *"} {:spelling "size", :type "int"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_opt_set_bin", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_bin, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_bin"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "w", :type "int"} {:spelling "h", :type "int"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_opt_set_image_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_image_size, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_image_size"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "fmt", :type "enum AVPixelFormat"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_opt_set_pixel_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_pixel_fmt, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_pixel_fmt"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "fmt", :type "enum AVSampleFormat"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_opt_set_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_sample_fmt, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_sample_fmt"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "struct AVRational"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :clong/AVRational :coffi.mem/int], :symbol "av_opt_set_video_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_video_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_video_rate"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "ch_layout", :type "long long"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long :coffi.mem/int], :symbol "av_opt_set_channel_layout", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_channel_layout, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_channel_layout"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "val", :type "const struct AVDictionary *"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVDictionary] :coffi.mem/int], :symbol "av_opt_set_dict_val", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_set_dict_val, :raw-comment "/**\n * @note Any old dictionary present is discarded and replaced with a copy of the new one. The\n * caller still owns val is and responsible for freeing it.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_set_dict_val"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "unsigned char **"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_opt_get", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get, :raw-comment "/**\n * @defgroup opt_get_funcs Option getting functions\n * @{\n * Those functions get a value of the option with the given name from an object.\n *\n * @param[in] obj a struct whose first element is a pointer to an AVClass.\n * @param[in] name name of the option to get.\n * @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be found in a child of obj.\n * @param[out] out_val value of the option will be written here\n * @return >=0 on success, a negative error code otherwise\n */\n/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_get"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "long long *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_opt_get_int", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_int, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_int"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "double *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double]], :symbol "av_opt_get_double", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_double, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_double"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "struct AVRational *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVRational]], :symbol "av_opt_get_q", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_q, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_q"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "w_out", :type "int *"} {:spelling "h_out", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_opt_get_image_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_image_size, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_image_size"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_fmt", :type "enum AVPixelFormat *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_opt_get_pixel_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_pixel_fmt, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_pixel_fmt"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_fmt", :type "enum AVSampleFormat *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_opt_get_sample_fmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_sample_fmt, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_sample_fmt"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "struct AVRational *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVRational]], :symbol "av_opt_get_video_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_video_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_video_rate"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "ch_layout", :type "long long *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_opt_get_channel_layout", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_channel_layout, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_channel_layout"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"} {:spelling "out_val", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "av_opt_get_dict_val", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_get_dict_val, :raw-comment "/**\n * @param[out] out_val The returned dictionary is a copy of the actual value and must\n * be freed with av_dict_free() by the caller\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_get_dict_val"} {:args [{:spelling "avclass", :type "const struct AVClass *"} {:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVClass] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_opt_ptr", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_ptr, :raw-comment "/**\n * @}\n */\n/**\n * Gets a pointer to the requested field in a struct.\n * This function allows accessing a struct even when its fields are moved or\n * renamed since the application making the access has been compiled,\n *\n * @returns a pointer to the field, it can be cast to the correct type and read\n *          or written to.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_ptr"} {:args [{:spelling "ranges", :type "struct AVOptionRanges **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOptionRanges]]], :symbol "av_opt_freep_ranges", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_freep_ranges, :raw-comment "/**\n * Free an AVOptionRanges struct and set it to NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_freep_ranges"} {:args [{:spelling "", :type "struct AVOptionRanges **"} {:spelling "obj", :type "void *"} {:spelling "key", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOptionRanges]] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_opt_query_ranges", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_query_ranges, :raw-comment "/**\n * Get a list of allowed ranges for the given option.\n *\n * The returned list may depend on other fields in obj like for example profile.\n *\n * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n *\n * The result must be freed with av_opt_freep_ranges.\n *\n * @return number of compontents returned on success, a negative errro code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_query_ranges"} {:args [{:spelling "dest", :type "void *"} {:spelling "src", :type "const void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer], :symbol "av_opt_copy", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_copy, :raw-comment "/**\n * Copy options from src object into dest object.\n *\n * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.\n * Original memory allocated for such options is freed unless both src and dest options points to the same memory.\n *\n * @param dest Object to copy from\n * @param src  Object to copy into\n * @return 0 on success, negative on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_copy"} {:args [{:spelling "", :type "struct AVOptionRanges **"} {:spelling "obj", :type "void *"} {:spelling "key", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOptionRanges]] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_opt_query_ranges_default", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_query_ranges_default, :raw-comment "/**\n * Get a default list of allowed ranges for the given option.\n *\n * This list is constructed without using the AVClass.query_ranges() callback\n * and can be used as fallback from within the callback.\n *\n * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n *\n * The result must be freed with av_opt_free_ranges.\n *\n * @return number of compontents returned on success, a negative errro code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_query_ranges_default"} {:args [{:spelling "obj", :type "void *"} {:spelling "o", :type "const struct AVOption *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOption]], :symbol "av_opt_is_set_to_default", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_is_set_to_default, :raw-comment "/**\n * Check if given option is set to its default value.\n *\n * Options o must belong to the obj. This function must not be called to check child's options state.\n * @see av_opt_is_set_to_default_by_name().\n *\n * @param obj  AVClass object to check option on\n * @param o    option to be checked\n * @return     >0 when option is set to its default,\n *              0 when option is not set its default,\n *             <0 on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_is_set_to_default"} {:args [{:spelling "obj", :type "void *"} {:spelling "name", :type "const char *"} {:spelling "search_flags", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_opt_is_set_to_default_by_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_is_set_to_default_by_name, :raw-comment "/**\n * Check if given option is set to its default value.\n *\n * @param obj          AVClass object to check option on\n * @param name         option name\n * @param search_flags combination of AV_OPT_SEARCH_*\n * @return             >0 when option is set to its default,\n *                     0 when option is not set its default,\n *                     <0 on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_is_set_to_default_by_name"} {:args [{:spelling "obj", :type "void *"} {:spelling "opt_flags", :type "int"} {:spelling "flags", :type "int"} {:spelling "buffer", :type "char **"} {:spelling "key_val_sep", :type "const char"} {:spelling "pairs_sep", :type "const char"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/char :coffi.mem/char], :symbol "av_opt_serialize", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_opt_serialize, :raw-comment "/**\n * Serialize object's options.\n *\n * Create a string containing object's serialized options.\n * Such string may be passed back to av_opt_set_from_string() in order to restore option values.\n * A key/value or pairs separator occurring in the serialized value or\n * name string are escaped through the av_escape() function.\n *\n * @param[in]  obj           AVClass object to serialize\n * @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)\n * @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags\n * @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.\n *                           Buffer must be freed by the caller when is no longer needed.\n * @param[in]  key_val_sep   character used to separate key from value\n * @param[in]  pairs_sep     character used to separate two pairs from each other\n * @return                   >= 0 on success, negative on error\n * @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_opt_serialize"} {:args [], :ret {:spelling "struct AVMasteringDisplayMetadata *"}, :function/args [], :symbol "av_mastering_display_metadata_alloc", :function/ret [:coffi.mem/pointer :clong/AVMasteringDisplayMetadata], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mastering_display_metadata_alloc, :raw-comment "/**\n * Allocate an AVMasteringDisplayMetadata structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVMasteringDisplayMetadata filled with default values or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mastering_display_metadata_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVMasteringDisplayMetadata *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_mastering_display_metadata_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVMasteringDisplayMetadata], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mastering_display_metadata_create_side_data, :raw-comment "/**\n * Allocate a complete AVMasteringDisplayMetadata and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVMasteringDisplayMetadata structure to be filled by caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mastering_display_metadata_create_side_data"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVContentLightMetadata *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_content_light_metadata_alloc", :function/ret [:coffi.mem/pointer :clong/AVContentLightMetadata], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_content_light_metadata_alloc, :raw-comment "/**\n * Allocate an AVContentLightMetadata structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVContentLightMetadata filled with default values or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_content_light_metadata_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVContentLightMetadata *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_content_light_metadata_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVContentLightMetadata], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_content_light_metadata_create_side_data, :raw-comment "/**\n * Allocate a complete AVContentLightMetadata and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVContentLightMetadata structure to be filled by caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_content_light_metadata_create_side_data"} {:args [], :ret {:spelling "struct AVAES *"}, :function/args [], :symbol "av_aes_alloc", :function/ret [:coffi.mem/pointer :clong/AVAES], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_alloc, :raw-comment "/**\n * Allocate an AVAES context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_alloc"} {:args [{:spelling "a", :type "struct AVAES *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"} {:spelling "decrypt", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAES] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_aes_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_init, :raw-comment "/**\n * Initialize an AVAES context.\n * @param key_bits 128, 192 or 256\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_init"} {:args [{:spelling "a", :type "struct AVAES *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAES] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_aes_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_crypt, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n * @param count number of 16 byte blocks\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_crypt"} {:args [], :ret {:spelling "struct AVRC4 *"}, :function/args [], :symbol "av_rc4_alloc", :function/ret [:coffi.mem/pointer :clong/AVRC4], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rc4_alloc, :raw-comment "/**\n * Allocate an AVRC4 context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rc4_alloc"} {:args [{:spelling "d", :type "struct AVRC4 *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"} {:spelling "decrypt", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVRC4] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_rc4_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rc4_init, :raw-comment "/**\n * @brief Initializes an AVRC4 context.\n *\n * @param key_bits must be a multiple of 8\n * @param decrypt 0 for encryption, 1 for decryption, currently has no effect\n * @return zero on success, negative value otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rc4_init"} {:args [{:spelling "d", :type "struct AVRC4 *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVRC4] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_rc4_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rc4_crypt, :raw-comment "/**\n * @brief Encrypts / decrypts using the RC4 algorithm.\n *\n * @param count number of bytes\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst, may be NULL\n * @param iv not (yet) used for RC4, should be NULL\n * @param decrypt 0 for encryption, 1 for decryption, not (yet) used\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rc4_crypt"} {:args [], :ret {:spelling "struct AVTEA *"}, :function/args [], :symbol "av_tea_alloc", :function/ret [:coffi.mem/pointer :clong/AVTEA], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tea_alloc, :raw-comment "/**\n  * Allocate an AVTEA context\n  * To free the struct: av_free(ptr)\n  */", :kind "CXCursor_FunctionDecl", :spelling "av_tea_alloc"} {:args [{:spelling "ctx", :type "struct AVTEA *"} {:spelling "key", :type "unsigned char const[16]"} {:spelling "rounds", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVTEA] [:coffi.mem/array :coffi.mem/char 16] :coffi.mem/int], :symbol "av_tea_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tea_init, :raw-comment "/**\n * Initialize an AVTEA context.\n *\n * @param ctx an AVTEA context\n * @param key a key of 16 bytes used for encryption/decryption\n * @param rounds the number of rounds in TEA (64 is the \"standard\")\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tea_init"} {:args [{:spelling "ctx", :type "struct AVTEA *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVTEA] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_tea_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_tea_crypt, :raw-comment "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_tea_crypt"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "av_get_cpu_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_cpu_flags, :raw-comment "/**\n * Return the flags which specify extensions supported by the CPU.\n * The returned value is affected by av_force_cpu_flags() if that was used\n * before. So av_get_cpu_flags() can easily be used in an application to\n * detect the enabled cpu flags.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_cpu_flags"} {:args [{:spelling "flags", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "av_force_cpu_flags", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_force_cpu_flags, :raw-comment "/**\n * Disables cpu detection and forces the specified flags.\n * -1 is a special case that disables forcing of specific flags.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_force_cpu_flags"} {:args [{:spelling "mask", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "av_set_cpu_flags_mask", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_set_cpu_flags_mask, :raw-comment "/**\n * Set a mask on flags returned by av_get_cpu_flags().\n * This function is mainly useful for testing.\n * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible\n */", :kind "CXCursor_FunctionDecl", :spelling "av_set_cpu_flags_mask"} {:args [{:spelling "s", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_parse_cpu_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_cpu_flags, :raw-comment "/**\n * Parse CPU flags from a string.\n *\n * The returned flags contain the specified flags as well as related unspecified flags.\n *\n * This function exists only for compatibility with libav.\n * Please use av_parse_cpu_caps() when possible.\n * @return a combination of AV_CPU_* flags, negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_cpu_flags"} {:args [{:spelling "flags", :type "unsigned int *"} {:spelling "s", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_parse_cpu_caps", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_cpu_caps, :raw-comment "/**\n * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.\n *\n * @return negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_cpu_caps"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "av_cpu_count", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cpu_count, :raw-comment "/**\n * @return the number of logical CPU cores present.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cpu_count"} {:args [], :ret {:spelling "unsigned long"}, :function/args [], :symbol "av_cpu_max_align", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cpu_max_align, :raw-comment "/**\n * Get the maximum data alignment that may be required by FFmpeg.\n *\n * Note that this is affected by the build configuration and the CPU flags mask,\n * so e.g. if the CPU supports AVX, but libavutil has been built with\n * --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through\n *  av_set_cpu_flags_mask(), then this function will behave as if AVX is not\n *  present.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cpu_max_align"} {:args [{:spelling "out", :type "void *"} {:spelling "outlen", :type "int *"} {:spelling "in", :type "const void *"} {:spelling "inlen", :type "int *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_lzo1x_decode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_lzo1x_decode, :raw-comment "/**\n * @brief Decodes LZO 1x compressed data.\n * @param out output buffer\n * @param outlen size of output buffer, number of bytes left are returned here\n * @param in input buffer\n * @param inlen size of input buffer, number of bytes left are returned here\n * @return 0 on success, otherwise a combination of the error flags above\n *\n * Make sure all buffers are appropriately padded, in must provide\n * AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_lzo1x_decode"} {:args [], :ret {:spelling "struct AVDES *"}, :function/args [], :symbol "av_des_alloc", :function/ret [:coffi.mem/pointer :clong/AVDES], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_des_alloc, :raw-comment "/**\n * Allocate an AVDES context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_des_alloc"} {:args [{:spelling "d", :type "struct AVDES *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"} {:spelling "decrypt", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVDES] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_des_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_des_init, :raw-comment "/**\n * @brief Initializes an AVDES context.\n *\n * @param key_bits must be 64 or 192\n * @param decrypt 0 for encryption/CBC-MAC, 1 for decryption\n * @return zero on success, negative value otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_des_init"} {:args [{:spelling "d", :type "struct AVDES *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVDES] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_des_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_des_crypt, :raw-comment "/**\n * @brief Encrypts / decrypts using the DES algorithm.\n *\n * @param count number of 8 byte blocks\n * @param dst destination array, can be equal to src, must be 8-byte aligned\n * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used,\n *           must be 8-byte aligned\n * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_des_crypt"} {:args [{:spelling "d", :type "struct AVDES *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVDES] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_des_mac", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_des_mac, :raw-comment "/**\n * @brief Calculates CBC-MAC using the DES algorithm.\n *\n * @param count number of 8 byte blocks\n * @param dst destination array, can be equal to src, must be 8-byte aligned\n * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "av_des_mac"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "unsigned long long"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_get_channel_layout", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_layout, :raw-comment "/**\n * Return a channel layout id that matches name, or 0 if no match is found.\n *\n * name can be one or several of the following notations,\n * separated by '+' or '|':\n * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,\n *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);\n * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,\n *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);\n * - a number of channels, in decimal, followed by 'c', yielding\n *   the default channel layout for that number of channels (@see\n *   av_get_default_channel_layout);\n * - a channel layout mask, in hexadecimal starting with \"0x\" (see the\n *   AV_CH_* macros).\n *\n * Example: \"stereo+FC\" = \"2c+FC\" = \"2c+1c\" = \"0x7\"\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_layout"} {:args [{:spelling "name", :type "const char *"} {:spelling "channel_layout", :type "unsigned long long *"} {:spelling "nb_channels", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_get_extended_channel_layout", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_extended_channel_layout, :raw-comment "/**\n * Return a channel layout and the number of channels based on the specified name.\n *\n * This function is similar to (@see av_get_channel_layout), but can also parse\n * unknown channel layout specifications.\n *\n * @param[in]  name             channel layout specification string\n * @param[out] channel_layout   parsed channel layout (0 if unknown)\n * @param[out] nb_channels      number of channels\n *\n * @return 0 on success, AVERROR(EINVAL) if the parsing fails.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_extended_channel_layout"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "nb_channels", :type "int"} {:spelling "channel_layout", :type "unsigned long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/long], :symbol "av_get_channel_layout_string", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_layout_string, :raw-comment "/**\n * Return a description of a channel layout.\n * If nb_channels is <= 0, it is guessed from the channel_layout.\n *\n * @param buf put here the string containing the channel layout\n * @param buf_size size in bytes of the buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_layout_string"} {:args [{:spelling "bp", :type "struct AVBPrint *"} {:spelling "nb_channels", :type "int"} {:spelling "channel_layout", :type "unsigned long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] :coffi.mem/int :coffi.mem/long], :symbol "av_bprint_channel_layout", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_channel_layout, :raw-comment "/**\n * Append a description of a channel layout to a bprint buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_channel_layout"} {:args [{:spelling "channel_layout", :type "unsigned long long"}], :ret {:spelling "int"}, :function/args [:coffi.mem/long], :symbol "av_get_channel_layout_nb_channels", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_layout_nb_channels, :raw-comment "/**\n * Return the number of channels in the channel layout.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_layout_nb_channels"} {:args [{:spelling "nb_channels", :type "int"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/int], :symbol "av_get_default_channel_layout", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_default_channel_layout, :raw-comment "/**\n * Return default channel layout for a given number of channels.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_default_channel_layout"} {:args [{:spelling "channel_layout", :type "unsigned long long"} {:spelling "channel", :type "unsigned long long"}], :ret {:spelling "int"}, :function/args [:coffi.mem/long :coffi.mem/long], :symbol "av_get_channel_layout_channel_index", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_layout_channel_index, :raw-comment "/**\n * Get the index of a channel in channel_layout.\n *\n * @param channel a channel layout describing exactly one channel which must be\n *                present in channel_layout.\n *\n * @return index of channel in channel_layout on success, a negative AVERROR\n *         on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_layout_channel_index"} {:args [{:spelling "channel_layout", :type "unsigned long long"} {:spelling "index", :type "int"}], :ret {:spelling "unsigned long long"}, :function/args [:coffi.mem/long :coffi.mem/int], :symbol "av_channel_layout_extract_channel", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_channel_layout_extract_channel, :raw-comment "/**\n * Get the channel with the given index in channel_layout.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_channel_layout_extract_channel"} {:args [{:spelling "channel", :type "unsigned long long"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/long], :symbol "av_get_channel_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_name, :raw-comment "/**\n * Get the name of a given channel.\n *\n * @return channel name on success, NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_name"} {:args [{:spelling "channel", :type "unsigned long long"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/long], :symbol "av_get_channel_description", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_channel_description, :raw-comment "/**\n * Get the description of a given channel.\n *\n * @param channel  a channel layout with a single channel\n * @return  channel description on success, NULL on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_channel_description"} {:args [{:spelling "index", :type "unsigned int"} {:spelling "layout", :type "unsigned long long *"} {:spelling "name", :type "const char **"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_get_standard_channel_layout", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_standard_channel_layout, :raw-comment "/**\n * Get the value and name of a standard channel layout.\n *\n * @param[in]  index   index in an internal list, starting at 0\n * @param[out] layout  channel layout mask\n * @param[out] name    name of the layout\n * @return  0  if the layout exists,\n *          <0 if index is beyond the limits\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_standard_channel_layout"} {:args [{:spelling "subsample_count", :type "unsigned int"} {:spelling "key_id_size", :type "unsigned int"} {:spelling "iv_size", :type "unsigned int"}], :ret {:spelling "struct AVEncryptionInfo *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_encryption_info_alloc", :function/ret [:coffi.mem/pointer :clong/AVEncryptionInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_info_alloc, :raw-comment "/**\n * Allocates an AVEncryptionInfo structure and sub-pointers to hold the given\n * number of subsamples.  This will allocate pointers for the key ID, IV,\n * and subsample entries, set the size members, and zero-initialize the rest.\n *\n * @param subsample_count The number of subsamples.\n * @param key_id_size The number of bytes in the key ID, should be 16.\n * @param iv_size The number of bytes in the IV, should be 16.\n *\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_info_alloc"} {:args [{:spelling "info", :type "const struct AVEncryptionInfo *"}], :ret {:spelling "struct AVEncryptionInfo *"}, :function/args [[:coffi.mem/pointer :clong/AVEncryptionInfo]], :symbol "av_encryption_info_clone", :function/ret [:coffi.mem/pointer :clong/AVEncryptionInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_info_clone, :raw-comment "/**\n * Allocates an AVEncryptionInfo structure with a copy of the given data.\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_info_clone"} {:args [{:spelling "info", :type "struct AVEncryptionInfo *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVEncryptionInfo]], :symbol "av_encryption_info_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_info_free, :raw-comment "/**\n * Frees the given encryption info object.  This MUST NOT be used to free the\n * side-data data pointer, that should use normal side-data methods.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_info_free"} {:args [{:spelling "side_data", :type "const unsigned char *"} {:spelling "side_data_size", :type "unsigned long"}], :ret {:spelling "struct AVEncryptionInfo *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_encryption_info_get_side_data", :function/ret [:coffi.mem/pointer :clong/AVEncryptionInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_info_get_side_data, :raw-comment "/**\n * Creates a copy of the AVEncryptionInfo that is contained in the given side\n * data.  The resulting object should be passed to av_encryption_info_free()\n * when done.\n *\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_info_get_side_data"} {:args [{:spelling "info", :type "const struct AVEncryptionInfo *"} {:spelling "side_data_size", :type "unsigned long *"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVEncryptionInfo] [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_encryption_info_add_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_info_add_side_data, :raw-comment "/**\n * Allocates and initializes side data that holds a copy of the given encryption\n * info.  The resulting pointer should be either freed using av_free or given\n * to av_packet_add_side_data().\n *\n * @return The new side-data pointer, or NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_info_add_side_data"} {:args [{:spelling "system_id_size", :type "unsigned int"} {:spelling "num_key_ids", :type "unsigned int"} {:spelling "key_id_size", :type "unsigned int"} {:spelling "data_size", :type "unsigned int"}], :ret {:spelling "struct AVEncryptionInitInfo *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_encryption_init_info_alloc", :function/ret [:coffi.mem/pointer :clong/AVEncryptionInitInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_init_info_alloc, :raw-comment "/**\n * Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the\n * given sizes.  This will allocate pointers and set all the fields.\n *\n * @return The new AVEncryptionInitInfo structure, or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_init_info_alloc"} {:args [{:spelling "info", :type "struct AVEncryptionInitInfo *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVEncryptionInitInfo]], :symbol "av_encryption_init_info_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_init_info_free, :raw-comment "/**\n * Frees the given encryption init info object.  This MUST NOT be used to free\n * the side-data data pointer, that should use normal side-data methods.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_init_info_free"} {:args [{:spelling "side_data", :type "const unsigned char *"} {:spelling "side_data_size", :type "unsigned long"}], :ret {:spelling "struct AVEncryptionInitInfo *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_encryption_init_info_get_side_data", :function/ret [:coffi.mem/pointer :clong/AVEncryptionInitInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_init_info_get_side_data, :raw-comment "/**\n * Creates a copy of the AVEncryptionInitInfo that is contained in the given\n * side data.  The resulting object should be passed to\n * av_encryption_init_info_free() when done.\n *\n * @return The new AVEncryptionInitInfo structure, or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_init_info_get_side_data"} {:args [{:spelling "info", :type "const struct AVEncryptionInitInfo *"} {:spelling "side_data_size", :type "unsigned long *"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVEncryptionInitInfo] [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_encryption_init_info_add_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_encryption_init_info_add_side_data, :raw-comment "/**\n * Allocates and initializes side data that holds a copy of the given encryption\n * init info.  The resulting pointer should be either freed using av_free or\n * given to av_packet_add_side_data().\n *\n * @return The new side-data pointer, or NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_encryption_init_info_add_side_data"} {:args [], :ret {:spelling "struct AVTWOFISH *"}, :function/args [], :symbol "av_twofish_alloc", :function/ret [:coffi.mem/pointer :clong/AVTWOFISH], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_twofish_alloc, :raw-comment "/**\n  * Allocate an AVTWOFISH context\n  * To free the struct: av_free(ptr)\n  */", :kind "CXCursor_FunctionDecl", :spelling "av_twofish_alloc"} {:args [{:spelling "ctx", :type "struct AVTWOFISH *"} {:spelling "key", :type "const unsigned char *"} {:spelling "key_bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVTWOFISH] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_twofish_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_twofish_init, :raw-comment "/**\n  * Initialize an AVTWOFISH context.\n  *\n  * @param ctx an AVTWOFISH context\n  * @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption\n  * @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_twofish_init"} {:args [{:spelling "ctx", :type "struct AVTWOFISH *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "count", :type "int"} {:spelling "iv", :type "unsigned char *"} {:spelling "decrypt", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVTWOFISH] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_twofish_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_twofish_crypt, :raw-comment "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVTWOFISH context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 16 byte blocks\n  * @paran iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */", :kind "CXCursor_FunctionDecl", :spelling "av_twofish_crypt"} {:args [{:spelling "max_pixsteps", :type "int [4]"} {:spelling "max_pixstep_comps", :type "int [4]"} {:spelling "pixdesc", :type "const struct AVPixFmtDescriptor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :clong/AVPixFmtDescriptor]], :symbol "av_image_fill_max_pixsteps", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_max_pixsteps, :raw-comment "/**\n * Compute the max pixel step for each plane of an image with a\n * format described by pixdesc.\n *\n * The pixel step is the distance in bytes between the first byte of\n * the group of bytes which describe a pixel component and the first\n * byte of the successive group in the same plane for the same\n * component.\n *\n * @param max_pixsteps an array which is filled with the max pixel step\n * for each plane. Since a plane may contain different pixel\n * components, the computed max_pixsteps[plane] is relative to the\n * component in the plane with the max pixel step.\n * @param max_pixstep_comps an array which is filled with the component\n * for each plane which has the max pixel step. May be NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_max_pixsteps"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "plane", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_get_linesize", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_get_linesize, :raw-comment "/**\n * Compute the size of an image line with format pix_fmt and width\n * width for the plane plane.\n *\n * @return the computed size in bytes\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_get_linesize"} {:args [{:spelling "linesizes", :type "int [4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int :coffi.mem/int], :symbol "av_image_fill_linesizes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_linesizes, :raw-comment "/**\n * Fill plane linesizes for an image with pixel format pix_fmt and\n * width width.\n *\n * @param linesizes array to be filled with the linesize for each plane\n * @return >= 0 in case of success, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_linesizes"} {:args [{:spelling "size", :type "unsigned long [4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "height", :type "int"} {:spelling "linesizes", :type "long const[4]"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array :coffi.mem/long 4] :coffi.mem/int :coffi.mem/int [:coffi.mem/array :coffi.mem/long 4]], :symbol "av_image_fill_plane_sizes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_plane_sizes, :raw-comment "/**\n * Fill plane sizes for an image with pixel format pix_fmt and height height.\n *\n * @param size the array to be filled with the size of each image plane\n * @param linesizes the array containing the linesize for each\n *        plane, should be filled by av_image_fill_linesizes()\n * @return >= 0 in case of success, a negative error code otherwise\n *\n * @note The linesize parameters have the type ptrdiff_t here, while they are\n *       int for av_image_fill_linesizes().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_plane_sizes"} {:args [{:spelling "data", :type "unsigned char *[4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "height", :type "int"} {:spelling "ptr", :type "unsigned char *"} {:spelling "linesizes", :type "int const[4]"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/array :coffi.mem/int 4]], :symbol "av_image_fill_pointers", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_pointers, :raw-comment "/**\n * Fill plane data pointers for an image with pixel format pix_fmt and\n * height height.\n *\n * @param data pointers array to be filled with the pointer for each image plane\n * @param ptr the pointer to a buffer which will contain the image\n * @param linesizes the array containing the linesize for each\n * plane, should be filled by av_image_fill_linesizes()\n * @return the size in bytes required for the image buffer, a negative\n * error code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_pointers"} {:args [{:spelling "pointers", :type "unsigned char *[4]"} {:spelling "linesizes", :type "int [4]"} {:spelling "w", :type "int"} {:spelling "h", :type "int"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_alloc, :raw-comment "/**\n * Allocate an image with size w and h and pixel format pix_fmt, and\n * fill pointers and linesizes accordingly.\n * The allocated image buffer has to be freed by using\n * av_freep(&pointers[0]).\n *\n * @param align the value to use for buffer size alignment\n * @return the size in bytes required for the image buffer, a negative\n * error code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_alloc"} {:args [{:spelling "dst", :type "unsigned char *"} {:spelling "dst_linesize", :type "int"} {:spelling "src", :type "const unsigned char *"} {:spelling "src_linesize", :type "int"} {:spelling "bytewidth", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_copy_plane", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_copy_plane, :raw-comment "/**\n * Copy image plane from src to dst.\n * That is, copy \"height\" number of lines of \"bytewidth\" bytes each.\n * The first byte of each successive line is separated by *_linesize\n * bytes.\n *\n * bytewidth must be contained by both absolute values of dst_linesize\n * and src_linesize, otherwise the function behavior is undefined.\n *\n * @param dst_linesize linesize for the image plane in dst\n * @param src_linesize linesize for the image plane in src\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_copy_plane"} {:args [{:spelling "dst_data", :type "unsigned char *[4]"} {:spelling "dst_linesizes", :type "int [4]"} {:spelling "src_data", :type "const unsigned char *[4]"} {:spelling "src_linesizes", :type "int const[4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_copy", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_copy, :raw-comment "/**\n * Copy image in src_data to dst_data.\n *\n * @param dst_linesizes linesizes for the image in dst_data\n * @param src_linesizes linesizes for the image in src_data\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_copy"} {:args [{:spelling "dst_data", :type "unsigned char *[4]"} {:spelling "dst_linesizes", :type "long const[4]"} {:spelling "src_data", :type "const unsigned char *[4]"} {:spelling "src_linesizes", :type "long const[4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/long 4] [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/long 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_copy_uc_from", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_copy_uc_from, :raw-comment "/**\n * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n * available, this function will use special functionality for reading from such\n * memory, which may result in greatly improved performance compared to plain\n * av_image_copy().\n *\n * The data pointers and the linesizes must be aligned to the maximum required\n * by the CPU architecture.\n *\n * @note The linesize parameters have the type ptrdiff_t here, while they are\n *       int for av_image_copy().\n * @note On x86, the linesizes currently need to be aligned to the cacheline\n *       size (i.e. 64) to get improved performance.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_copy_uc_from"} {:args [{:spelling "dst_data", :type "unsigned char *[4]"} {:spelling "dst_linesize", :type "int [4]"} {:spelling "src", :type "const unsigned char *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_fill_arrays", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_arrays, :raw-comment "/**\n * Setup the data pointers and linesizes based on the specified image\n * parameters and the provided array.\n *\n * The fields of the given image are filled in by using the src\n * address which points to the image data buffer. Depending on the\n * specified pixel format, one or multiple image data pointers and\n * line sizes will be set.  If a planar format is specified, several\n * pointers will be set pointing to the different picture planes and\n * the line sizes of the different planes will be stored in the\n * lines_sizes array. Call with src == NULL to get the required\n * size for the src buffer.\n *\n * To allocate the buffer and fill in the dst_data and dst_linesize in\n * one call, use av_image_alloc().\n *\n * @param dst_data      data pointers to be filled in\n * @param dst_linesize  linesizes for the image in dst_data to be filled in\n * @param src           buffer which will contain or contains the actual image data, can be NULL\n * @param pix_fmt       the pixel format of the image\n * @param width         the width of the image in pixels\n * @param height        the height of the image in pixels\n * @param align         the value used in src for linesize alignment\n * @return the size in bytes required for src, a negative error code\n * in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_arrays"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_get_buffer_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_get_buffer_size, :raw-comment "/**\n * Return the size in bytes of the amount of data required to store an\n * image with the given parameters.\n *\n * @param pix_fmt  the pixel format of the image\n * @param width    the width of the image in pixels\n * @param height   the height of the image in pixels\n * @param align    the assumed linesize alignment\n * @return the buffer size in bytes, a negative error code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_get_buffer_size"} {:args [{:spelling "dst", :type "unsigned char *"} {:spelling "dst_size", :type "int"} {:spelling "src_data", :type "const unsigned char *const[4]"} {:spelling "src_linesize", :type "int const[4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_copy_to_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_copy_to_buffer, :raw-comment "/**\n * Copy image data from an image into a buffer.\n *\n * av_image_get_buffer_size() can be used to compute the required size\n * for the buffer to fill.\n *\n * @param dst           a buffer into which picture data will be copied\n * @param dst_size      the size in bytes of dst\n * @param src_data      pointers containing the source image data\n * @param src_linesize  linesizes for the image in src_data\n * @param pix_fmt       the pixel format of the source image\n * @param width         the width of the source image in pixels\n * @param height        the height of the source image in pixels\n * @param align         the assumed linesize alignment for dst\n * @return the number of bytes written to dst, or a negative value\n * (error code) on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_copy_to_buffer"} {:args [{:spelling "w", :type "unsigned int"} {:spelling "h", :type "unsigned int"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_image_check_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_check_size, :raw-comment "/**\n * Check if the given dimension of an image is valid, meaning that all\n * bytes of the image can be addressed with a signed int.\n *\n * @param w the width of the picture\n * @param h the height of the picture\n * @param log_offset the offset to sum to the log level for logging with log_ctx\n * @param log_ctx the parent logging context, it may be NULL\n * @return >= 0 if valid, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_check_size"} {:args [{:spelling "w", :type "unsigned int"} {:spelling "h", :type "unsigned int"} {:spelling "max_pixels", :type "long long"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/long :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_image_check_size2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_check_size2, :raw-comment "/**\n * Check if the given dimension of an image is valid, meaning that all\n * bytes of a plane of an image with the specified pix_fmt can be addressed\n * with a signed int.\n *\n * @param w the width of the picture\n * @param h the height of the picture\n * @param max_pixels the maximum number of pixels the user wants to accept\n * @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.\n * @param log_offset the offset to sum to the log level for logging with log_ctx\n * @param log_ctx the parent logging context, it may be NULL\n * @return >= 0 if valid, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_check_size2"} {:args [{:spelling "w", :type "unsigned int"} {:spelling "h", :type "unsigned int"} {:spelling "sar", :type "struct AVRational"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :clong/AVRational], :symbol "av_image_check_sar", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_check_sar, :raw-comment "/**\n * Check if the given sample aspect ratio of an image is valid.\n *\n * It is considered invalid if the denominator is 0 or if applying the ratio\n * to the image size would make the smaller dimension less than 1. If the\n * sar numerator is 0, it is considered unknown and will return as valid.\n *\n * @param w width of the image\n * @param h height of the image\n * @param sar sample aspect ratio of the image\n * @return 0 if valid, a negative AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_check_sar"} {:args [{:spelling "dst_data", :type "unsigned char *[4]"} {:spelling "dst_linesize", :type "long const[4]"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "range", :type "enum AVColorRange"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4] [:coffi.mem/array :coffi.mem/long 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_image_fill_black", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_image_fill_black, :raw-comment "/**\n * Overwrite the image data with black. This is suitable for filling a\n * sub-rectangle of an image, meaning the padding between the right most pixel\n * and the left most pixel on the next line will not be overwritten. For some\n * formats, the image size might be rounded up due to inherent alignment.\n *\n * If the pixel format has alpha, the alpha is cleared to opaque.\n *\n * This can return an error if the pixel format is not supported. Normally, all\n * non-hwaccel pixel formats should be supported.\n *\n * Passing NULL for dst_data is allowed. Then the function returns whether the\n * operation would have succeeded. (It can return an error if the pix_fmt is\n * not supported.)\n *\n * @param dst_data      data pointers to destination image\n * @param dst_linesize  linesizes for the destination image\n * @param pix_fmt       the pixel format of the image\n * @param range         the color range of the image (important for colorspaces such as YUV)\n * @param width         the width of the image in pixels\n * @param height        the height of the image in pixels\n * @return 0 if the image data was cleared, a negative AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_image_fill_black"} {:args [{:spelling "cv_fmt", :type "unsigned int"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [:coffi.mem/int], :symbol "av_map_videotoolbox_format_to_pixfmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_map_videotoolbox_format_to_pixfmt, :raw-comment "/**\n * Convert a VideoToolbox (actually CoreVideo) format to AVPixelFormat.\n * Returns AV_PIX_FMT_NONE if no known equivalent was found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_map_videotoolbox_format_to_pixfmt"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "av_map_videotoolbox_format_from_pixfmt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_map_videotoolbox_format_from_pixfmt, :raw-comment "/**\n * Convert an AVPixelFormat to a VideoToolbox (actually CoreVideo) format.\n * Returns 0 if no known equivalent was found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_map_videotoolbox_format_from_pixfmt"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "full_range", :type "_Bool"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int :coffi.mem/char], :symbol "av_map_videotoolbox_format_from_pixfmt2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_map_videotoolbox_format_from_pixfmt2, :raw-comment "/**\n * Same as av_map_videotoolbox_format_from_pixfmt function, but can map and\n * return full range pixel formats via a flag.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_map_videotoolbox_format_from_pixfmt2"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "av_assert0_fpu", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_assert0_fpu, :raw-comment "/**\n * Assert that floating point operations can be executed.\n *\n * This will av_assert0() that the cpu is not in MMX state on X86\n */", :kind "CXCursor_FunctionDecl", :spelling "av_assert0_fpu"} {:args [{:spelling "type", :type "enum AVVideoEncParamsType"} {:spelling "nb_blocks", :type "unsigned int"} {:spelling "out_size", :type "unsigned long *"}], :ret {:spelling "struct AVVideoEncParams *"}, :function/args [:coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_video_enc_params_alloc", :function/ret [:coffi.mem/pointer :clong/AVVideoEncParams], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_video_enc_params_alloc, :raw-comment "/**\n * Allocates memory for AVVideoEncParams of the given type, plus an array of\n * {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be\n * freed with a normal av_free() call.\n *\n * @param out_size if non-NULL, the size in bytes of the resulting data array is\n * written here.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_video_enc_params_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "type", :type "enum AVVideoEncParamsType"} {:spelling "nb_blocks", :type "unsigned int"}], :ret {:spelling "struct AVVideoEncParams *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int :coffi.mem/int], :symbol "av_video_enc_params_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVVideoEncParams], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_video_enc_params_create_side_data, :raw-comment "/**\n * Allocates memory for AVEncodeInfoFrame plus an array of\n * {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}\n * as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS\n * and initializes the variables.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_video_enc_params_create_side_data"} {:args [{:spelling "q", :type "struct AVRational *"} {:spelling "str", :type "const char *"} {:spelling "max", :type "int"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVRational] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "av_parse_ratio", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_ratio, :raw-comment "/**\n * Parse str and store the parsed ratio in q.\n *\n * Note that a ratio with infinite (1/0) or negative value is\n * considered valid, so you should check on the returned value if you\n * want to exclude those values.\n *\n * The undefined value can be expressed using the \"0:0\" string.\n *\n * @param[in,out] q pointer to the AVRational which will contain the ratio\n * @param[in] str the string to parse: it has to be a string in the format\n * num:den, a float number or an expression\n * @param[in] max the maximum allowed numerator and denominator\n * @param[in] log_offset log level offset which is applied to the log\n * level of log_ctx\n * @param[in] log_ctx parent logging context\n * @return >= 0 on success, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_ratio"} {:args [{:spelling "width_ptr", :type "int *"} {:spelling "height_ptr", :type "int *"} {:spelling "str", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_parse_video_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_video_size, :raw-comment "/**\n * Parse str and put in width_ptr and height_ptr the detected values.\n *\n * @param[in,out] width_ptr pointer to the variable which will contain the detected\n * width value\n * @param[in,out] height_ptr pointer to the variable which will contain the detected\n * height value\n * @param[in] str the string to parse: it has to be a string in the format\n * width x height or a valid video size abbreviation.\n * @return >= 0 on success, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_video_size"} {:args [{:spelling "rate", :type "struct AVRational *"} {:spelling "str", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVRational] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_parse_video_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_video_rate, :raw-comment "/**\n * Parse str and store the detected values in *rate.\n *\n * @param[in,out] rate pointer to the AVRational which will contain the detected\n * frame rate\n * @param[in] str the string to parse: it has to be a string in the format\n * rate_num / rate_den, a float number or a valid video rate abbreviation\n * @return >= 0 on success, a negative error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_video_rate"} {:args [{:spelling "rgba_color", :type "unsigned char *"} {:spelling "color_string", :type "const char *"} {:spelling "slen", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/pointer], :symbol "av_parse_color", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_color, :raw-comment "/**\n * Put the RGBA values that correspond to color_string in rgba_color.\n *\n * @param color_string a string specifying a color. It can be the name of\n * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,\n * possibly followed by \"@\" and a string representing the alpha\n * component.\n * The alpha component may be a string composed by \"0x\" followed by an\n * hexadecimal number or a decimal number between 0.0 and 1.0, which\n * represents the opacity value (0x00/0.0 means completely transparent,\n * 0xff/1.0 completely opaque).\n * If the alpha component is not specified then 0xff is assumed.\n * The string \"random\" will result in a random color.\n * @param slen length of the initial part of color_string containing the\n * color. It can be set to -1 if color_string is a null terminated string\n * containing nothing else than the color.\n * @return >= 0 in case of success, a negative value in case of\n * failure (for example if color_string cannot be parsed).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_color"} {:args [{:spelling "color_idx", :type "int"} {:spelling "rgb", :type "const unsigned char **"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_get_known_color_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_known_color_name, :raw-comment "/**\n * Get the name of a color from the internal table of hard-coded named\n * colors.\n *\n * This function is meant to enumerate the color names recognized by\n * av_parse_color().\n *\n * @param color_idx index of the requested color, starting from 0\n * @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB\n * @return the color name string or NULL if color_idx is not in the array\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_known_color_name"} {:args [{:spelling "timeval", :type "long long *"} {:spelling "timestr", :type "const char *"} {:spelling "duration", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_parse_time", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parse_time, :raw-comment "/**\n * Parse timestr and return in *time a corresponding number of\n * microseconds.\n *\n * @param timeval puts here the number of microseconds corresponding\n * to the string in timestr. If the string represents a duration, it\n * is the number of microseconds contained in the time interval.  If\n * the string is a date, is the number of microseconds since 1st of\n * January, 1970 up to the time of the parsed date.  If timestr cannot\n * be successfully parsed, set *time to INT64_MIN.\n\n * @param timestr a string representing a date or a duration.\n * - If a date the syntax is:\n * @code\n * [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]\n * now\n * @endcode\n * If the value is \"now\" it takes the current time.\n * Time is local time unless Z is appended, in which case it is\n * interpreted as UTC.\n * If the year-month-day part is not specified it takes the current\n * year-month-day.\n * - If a duration the syntax is:\n * @code\n * [-][HH:]MM:SS[.m...]\n * [-]S+[.m...]\n * @endcode\n * @param duration flag which tells how to interpret timestr, if not\n * zero timestr is interpreted as a duration, otherwise as a date\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parse_time"} {:args [{:spelling "arg", :type "char *"} {:spelling "arg_size", :type "int"} {:spelling "tag1", :type "const char *"} {:spelling "info", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_find_info_tag", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_info_tag, :raw-comment "/**\n * Attempt to find a specific tag in a URL.\n *\n * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.\n * Return 1 if found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_info_tag"} {:args [{:spelling "p", :type "const char *"} {:spelling "fmt", :type "const char *"} {:spelling "dt", :type "struct tm *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/tm]], :symbol "av_small_strptime", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_small_strptime, :raw-comment "/**\n * Simplified version of strptime\n *\n * Parse the input string p according to the format string fmt and\n * store its results in the structure dt.\n * This implementation supports only a subset of the formats supported\n * by the standard strptime().\n *\n * The supported input field descriptors are listed below.\n * - %H: the hour as a decimal number, using a 24-hour clock, in the\n *   range '00' through '23'\n * - %J: hours as a decimal number, in the range '0' through INT_MAX\n * - %M: the minute as a decimal number, using a 24-hour clock, in the\n *   range '00' through '59'\n * - %S: the second as a decimal number, using a 24-hour clock, in the\n *   range '00' through '59'\n * - %Y: the year as a decimal number, using the Gregorian calendar\n * - %m: the month as a decimal number, in the range '1' through '12'\n * - %d: the day of the month as a decimal number, in the range '1'\n *   through '31'\n * - %T: alias for '%H:%M:%S'\n * - %%: a literal '%'\n *\n * @return a pointer to the first character not processed in this function\n *         call. In case the input string contains more characters than\n *         required by the format string the return value points right after\n *         the last consumed input character. In case the whole input string\n *         is consumed the return value points to the null byte at the end of\n *         the string. On failure NULL is returned.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_small_strptime"} {:args [{:spelling "tm", :type "struct tm *"}], :ret {:spelling "long"}, :function/args [[:coffi.mem/pointer :clong/tm]], :symbol "av_timegm", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_timegm, :raw-comment "/**\n * Convert the decomposed UTC time in tm to a time_t value.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_timegm"} {:args [], :ret {:spelling "struct AVRIPEMD *"}, :function/args [], :symbol "av_ripemd_alloc", :function/ret [:coffi.mem/pointer :clong/AVRIPEMD], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_ripemd_alloc, :raw-comment "/**\n * Allocate an AVRIPEMD context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_ripemd_alloc"} {:args [{:spelling "context", :type "struct AVRIPEMD *"} {:spelling "bits", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVRIPEMD] :coffi.mem/int], :symbol "av_ripemd_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_ripemd_init, :raw-comment "/**\n * Initialize RIPEMD hashing.\n *\n * @param context pointer to the function context (of size av_ripemd_size)\n * @param bits    number of bits in digest (128, 160, 256 or 320 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_ripemd_init"} {:args [{:spelling "context", :type "struct AVRIPEMD *"} {:spelling "data", :type "const unsigned char *"} {:spelling "len", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVRIPEMD] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_ripemd_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_ripemd_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_ripemd_update"} {:args [{:spelling "context", :type "struct AVRIPEMD *"} {:spelling "digest", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVRIPEMD] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_ripemd_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_ripemd_final, :raw-comment "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_ripemd_final"} {:args [{:spelling "str", :type "const char *"} {:spelling "pfx", :type "const char *"} {:spelling "ptr", :type "const char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_strstart", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strstart, :raw-comment "/**\n * Return non-zero if pfx is a prefix of str. If it is, *ptr is set to\n * the address of the first character in str after the prefix.\n *\n * @param str input string\n * @param pfx prefix to test\n * @param ptr updated if the prefix is matched inside str\n * @return non-zero if the prefix matches, zero otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strstart"} {:args [{:spelling "str", :type "const char *"} {:spelling "pfx", :type "const char *"} {:spelling "ptr", :type "const char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_stristart", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stristart, :raw-comment "/**\n * Return non-zero if pfx is a prefix of str independent of case. If\n * it is, *ptr is set to the address of the first character in str\n * after the prefix.\n *\n * @param str input string\n * @param pfx prefix to test\n * @param ptr updated if the prefix is matched inside str\n * @return non-zero if the prefix matches, zero otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stristart"} {:args [{:spelling "haystack", :type "const char *"} {:spelling "needle", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_stristr", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stristr, :raw-comment "/**\n * Locate the first case-independent occurrence in the string haystack\n * of the string needle.  A zero-length string needle is considered to\n * match at the start of haystack.\n *\n * This function is a case-insensitive version of the standard strstr().\n *\n * @param haystack string to search in\n * @param needle   string to search for\n * @return         pointer to the located match within haystack\n *                 or a null pointer if no match\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stristr"} {:args [{:spelling "haystack", :type "const char *"} {:spelling "needle", :type "const char *"} {:spelling "hay_length", :type "unsigned long"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strnstr", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strnstr, :raw-comment "/**\n * Locate the first occurrence of the string needle in the string haystack\n * where not more than hay_length characters are searched. A zero-length\n * string needle is considered to match at the start of haystack.\n *\n * This function is a length-limited version of the standard strstr().\n *\n * @param haystack   string to search in\n * @param needle     string to search for\n * @param hay_length length of string to search in\n * @return           pointer to the located match within haystack\n *                   or a null pointer if no match\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strnstr"} {:args [{:spelling "dst", :type "char *"} {:spelling "src", :type "const char *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "unsigned long"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strlcpy", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strlcpy, :raw-comment "/**\n * Copy the string src to dst, but no more than size - 1 bytes, and\n * null-terminate dst.\n *\n * This function is the same as BSD strlcpy().\n *\n * @param dst destination buffer\n * @param src source string\n * @param size size of destination buffer\n * @return the length of src\n *\n * @warning since the return value is the length of src, src absolutely\n * _must_ be a properly 0-terminated string, otherwise this will read beyond\n * the end of the buffer and possibly crash.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strlcpy"} {:args [{:spelling "dst", :type "char *"} {:spelling "src", :type "const char *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "unsigned long"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strlcat", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strlcat, :raw-comment "/**\n * Append the string src to the string dst, but to a total length of\n * no more than size - 1 bytes, and null-terminate dst.\n *\n * This function is similar to BSD strlcat(), but differs when\n * size <= strlen(dst).\n *\n * @param dst destination buffer\n * @param src source string\n * @param size size of destination buffer\n * @return the total length of src and dst\n *\n * @warning since the return value use the length of src and dst, these\n * absolutely _must_ be a properly 0-terminated strings, otherwise this\n * will read beyond the end of the buffer and possibly crash.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strlcat"} {:args [{:spelling "dst", :type "char *"} {:spelling "size", :type "unsigned long"} {:spelling "fmt", :type "const char *"}], :ret {:spelling "unsigned long"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_strlcatf", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strlcatf, :raw-comment "/**\n * Append output to a string, according to a format. Never write out of\n * the destination buffer, and always put a terminating 0 within\n * the buffer.\n * @param dst destination buffer (string to which the output is\n *  appended)\n * @param size total size of the destination buffer\n * @param fmt printf-compatible format string, specifying how the\n *  following parameters are used\n * @return the length of the string that would have been generated\n *  if enough space had been available\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strlcatf"} {:args [{:spelling "fmt", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_asprintf", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_asprintf, :raw-comment "/**\n * Print arguments following specified format into a large enough auto\n * allocated buffer. It is similar to GNU asprintf().\n * @param fmt printf-compatible format string, specifying how the\n *            following parameters are used.\n * @return the allocated string\n * @note You have to free the string yourself with av_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_asprintf"} {:args [{:spelling "d", :type "double"}], :ret {:spelling "char *"}, :function/args [:coffi.mem/double], :symbol "av_d2str", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_d2str, :raw-comment "/**\n * Convert a number to an av_malloced string.\n * @deprecated  use av_asprintf() with \"%f\" or a more specific format\n */", :kind "CXCursor_FunctionDecl", :spelling "av_d2str"} {:args [{:spelling "buf", :type "const char **"} {:spelling "term", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_get_token", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_token, :raw-comment "/**\n * Unescape the given string until a non escaped terminating char,\n * and return the token corresponding to the unescaped string.\n *\n * The normal \\ and ' escaping is supported. Leading and trailing\n * whitespaces are removed, unless they are escaped with '\\' or are\n * enclosed between ''.\n *\n * @param buf the buffer to parse, buf will be updated to point to the\n * terminating char\n * @param term a 0-terminated list of terminating chars\n * @return the malloced unescaped string, which must be av_freed by\n * the user, NULL in case of allocation failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_token"} {:args [{:spelling "s", :type "char *"} {:spelling "delim", :type "const char *"} {:spelling "saveptr", :type "char **"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_strtok", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strtok, :raw-comment "/**\n * Split the string into several tokens which can be accessed by\n * successive calls to av_strtok().\n *\n * A token is defined as a sequence of characters not belonging to the\n * set specified in delim.\n *\n * On the first call to av_strtok(), s should point to the string to\n * parse, and the value of saveptr is ignored. In subsequent calls, s\n * should be NULL, and saveptr should be unchanged since the previous\n * call.\n *\n * This function is similar to strtok_r() defined in POSIX.1.\n *\n * @param s the string to parse, may be NULL\n * @param delim 0-terminated list of token delimiters, must be non-NULL\n * @param saveptr user-provided pointer which points to stored\n * information necessary for av_strtok() to continue scanning the same\n * string. saveptr is updated to point to the next character after the\n * first delimiter found, or to NULL if the string was terminated\n * @return the found token, or NULL when no token is found\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strtok"} {:args [{:spelling "a", :type "const char *"} {:spelling "b", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_strcasecmp", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strcasecmp, :raw-comment "/**\n * Locale-independent case-insensitive compare.\n * @note This means only ASCII-range characters are case-insensitive\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strcasecmp"} {:args [{:spelling "a", :type "const char *"} {:spelling "b", :type "const char *"} {:spelling "n", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_strncasecmp", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strncasecmp, :raw-comment "/**\n * Locale-independent case-insensitive compare.\n * @note This means only ASCII-range characters are case-insensitive\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strncasecmp"} {:args [{:spelling "str", :type "const char *"} {:spelling "from", :type "const char *"} {:spelling "to", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_strireplace", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_strireplace, :raw-comment "/**\n * Locale-independent strings replace.\n * @note This means only ASCII-range characters are replace\n */", :kind "CXCursor_FunctionDecl", :spelling "av_strireplace"} {:args [{:spelling "path", :type "const char *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_basename", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_basename, :raw-comment "/**\n * Thread safe basename.\n * @param path the string to parse, on DOS both \\ and / are considered separators.\n * @return pointer to the basename substring.\n * If path does not contain a slash, the function returns a copy of path.\n * If path is a NULL pointer or points to an empty string, a pointer\n * to a string \".\" is returned.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_basename"} {:args [{:spelling "path", :type "char *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_dirname", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dirname, :raw-comment "/**\n * Thread safe dirname.\n * @param path the string to parse, on DOS both \\ and / are considered separators.\n * @return A pointer to a string that's the parent directory of path.\n * If path is a NULL pointer or points to an empty string, a pointer\n * to a string \".\" is returned.\n * @note the function may modify the contents of the path, so copies should be passed.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dirname"} {:args [{:spelling "name", :type "const char *"} {:spelling "names", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_match_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_match_name, :raw-comment "/**\n * Match instances of a name in a comma-separated list of names.\n * List entries are checked from the start to the end of the names list,\n * the first match ends further processing. If an entry prefixed with '-'\n * matches, then 0 is returned. The \"ALL\" list entry is considered to\n * match all names.\n *\n * @param name  Name to look for.\n * @param names List of names.\n * @return 1 on match, 0 otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_match_name"} {:args [{:spelling "path", :type "const char *"} {:spelling "component", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_append_path_component", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_append_path_component, :raw-comment "/**\n * Append path component to the existing path.\n * Path separator '/' is placed between when needed.\n * Resulting string have to be freed with av_free().\n * @param path      base path\n * @param component component to be appended\n * @return new path or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_append_path_component"} {:args [{:spelling "dst", :type "char **"} {:spelling "src", :type "const char *"} {:spelling "special_chars", :type "const char *"} {:spelling "mode", :type "enum AVEscapeMode"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_escape", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_escape, :raw-comment "/**\n * Escape string in src, and put the escaped string in an allocated\n * string in *dst, which must be freed with av_free().\n *\n * @param dst           pointer where an allocated string is put\n * @param src           string to escape, must be non-NULL\n * @param special_chars string containing the special characters which\n *                      need to be escaped, can be NULL\n * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n *                      Any unknown value for mode will be considered equivalent to\n *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n *                      notice.\n * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros\n * @return the length of the allocated string, or a negative error code in case of error\n * @see av_bprint_escape()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_escape"} {:args [{:spelling "codep", :type "int *"} {:spelling "bufp", :type "const unsigned char **"} {:spelling "buf_end", :type "const unsigned char *"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_utf8_decode", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_utf8_decode, :raw-comment "/**\n * Read and decode a single UTF-8 code point (character) from the\n * buffer in *buf, and update *buf to point to the next byte to\n * decode.\n *\n * In case of an invalid byte sequence, the pointer will be updated to\n * the next byte after the invalid sequence and the function will\n * return an error code.\n *\n * Depending on the specified flags, the function will also fail in\n * case the decoded code point does not belong to a valid range.\n *\n * @note For speed-relevant code a carefully implemented use of\n * GET_UTF8() may be preferred.\n *\n * @param codep   pointer used to return the parsed code in case of success.\n *                The value in *codep is set even in case the range check fails.\n * @param bufp    pointer to the address the first byte of the sequence\n *                to decode, updated by the function to point to the\n *                byte next after the decoded sequence\n * @param buf_end pointer to the end of the buffer, points to the next\n *                byte past the last in the buffer. This is used to\n *                avoid buffer overreads (in case of an unfinished\n *                UTF-8 sequence towards the end of the buffer).\n * @param flags   a collection of AV_UTF8_FLAG_* flags\n * @return >= 0 in case a sequence was successfully read, a negative\n * value in case of invalid sequence\n */", :kind "CXCursor_FunctionDecl", :spelling "av_utf8_decode"} {:args [{:spelling "name", :type "const char *"} {:spelling "list", :type "const char *"} {:spelling "separator", :type "char"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/char], :symbol "av_match_list", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_match_list, :raw-comment "/**\n * Check if a name is in a list.\n * @returns 0 if not found, or the 1 based index where it has been found in the\n *            list.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_match_list"} {:args [{:spelling "string", :type "const char *"} {:spelling "format", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_sscanf", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sscanf, :raw-comment "/**\n * See libc sscanf manual for more information.\n * Locale-independent sscanf implementation.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sscanf"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "size_init", :type "unsigned int"} {:spelling "size_max", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] :coffi.mem/int :coffi.mem/int], :symbol "av_bprint_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_init, :raw-comment "/**\n * Init a print buffer.\n *\n * @param buf        buffer to init\n * @param size_init  initial size (including the final 0)\n * @param size_max   maximum size;\n *                   0 means do not write anything, just count the length;\n *                   1 is replaced by the maximum value for automatic storage;\n *                   any large value means that the internal buffer will be\n *                   reallocated as needed up to that limit; -1 is converted to\n *                   UINT_MAX, the largest limit possible.\n *                   Check also AV_BPRINT_SIZE_* macros.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_init"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "buffer", :type "char *"} {:spelling "size", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_bprint_init_for_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_init_for_buffer, :raw-comment "/**\n * Init a print buffer using a pre-existing buffer.\n *\n * The buffer will not be reallocated.\n *\n * @param buf     buffer structure to init\n * @param buffer  byte buffer to use for the string data\n * @param size    size of buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_init_for_buffer"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "fmt", :type "const char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_bprintf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprintf, :raw-comment "/**\n * Append a formatted string to a print buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprintf"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "fmt", :type "const char *"} {:spelling "vl_arg", :type "char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_vbprintf", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vbprintf, :raw-comment "/**\n * Append a formatted string to a print buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vbprintf"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "c", :type "char"} {:spelling "n", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] :coffi.mem/char :coffi.mem/int], :symbol "av_bprint_chars", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_chars, :raw-comment "/**\n * Append char c n times to a print buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_chars"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "data", :type "const char *"} {:spelling "size", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_bprint_append_data", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_append_data, :raw-comment "/**\n * Append data to a print buffer.\n *\n * param buf  bprint buffer to use\n * param data pointer to data\n * param size size of data\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_append_data"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "fmt", :type "const char *"} {:spelling "tm", :type "const struct tm *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/tm]], :symbol "av_bprint_strftime", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_strftime, :raw-comment "/**\n * Append a formatted date and time to a print buffer.\n *\n * param buf  bprint buffer to use\n * param fmt  date and time format string, see strftime()\n * param tm   broken-down time structure to translate\n *\n * @note due to poor design of the standard strftime function, it may\n * produce poor results if the format string expands to a very long text and\n * the bprint buffer is near the limit stated by the size_max option.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_strftime"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "size", :type "unsigned int"} {:spelling "mem", :type "unsigned char **"} {:spelling "actual_size", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_bprint_get_buffer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_get_buffer, :raw-comment "/**\n * Allocate bytes in the buffer for external use.\n *\n * @param[in]  buf          buffer structure\n * @param[in]  size         required size\n * @param[out] mem          pointer to the memory area\n * @param[out] actual_size  size of the memory area after allocation;\n *                          can be larger or smaller than size\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_get_buffer"} {:args [{:spelling "buf", :type "struct AVBPrint *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint]], :symbol "av_bprint_clear", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_clear, :raw-comment "/**\n * Reset the string to \"\" but keep internal allocated data.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_clear"} {:args [{:spelling "buf", :type "struct AVBPrint *"} {:spelling "ret_str", :type "char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "av_bprint_finalize", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_finalize, :raw-comment "/**\n * Finalize a print buffer.\n *\n * The print buffer can no longer be used afterwards,\n * but the len and size fields are still valid.\n *\n * @arg[out] ret_str  if not NULL, used to return a permanent copy of the\n *                    buffer contents, or NULL if memory allocation fails;\n *                    if NULL, the buffer is discarded and freed\n * @return  0 for success or error code (probably AVERROR(ENOMEM))\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_finalize"} {:args [{:spelling "dstbuf", :type "struct AVBPrint *"} {:spelling "src", :type "const char *"} {:spelling "special_chars", :type "const char *"} {:spelling "mode", :type "enum AVEscapeMode"} {:spelling "flags", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBPrint] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_bprint_escape", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bprint_escape, :raw-comment "/**\n * Escape the content in src and append it to dstbuf.\n *\n * @param dstbuf        already inited destination bprint buffer\n * @param src           string containing the text to escape\n * @param special_chars string containing the special characters which\n *                      need to be escaped, can be NULL\n * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n *                      Any unknown value for mode will be considered equivalent to\n *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n *                      notice.\n * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bprint_escape"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVDynamicHDRPlus *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_dynamic_hdr_plus_alloc", :function/ret [:coffi.mem/pointer :clong/AVDynamicHDRPlus], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dynamic_hdr_plus_alloc, :raw-comment "/**\n * Allocate an AVDynamicHDRPlus structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVDynamicHDRPlus filled with default values or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dynamic_hdr_plus_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVDynamicHDRPlus *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_dynamic_hdr_plus_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVDynamicHDRPlus], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dynamic_hdr_plus_create_side_data, :raw-comment "/**\n * Allocate a complete AVDynamicHDRPlus and add it to the frame.\n * @param frame The frame which side data is added to.\n *\n * @return The AVDynamicHDRPlus structure to be filled by caller or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dynamic_hdr_plus_create_side_data"} {:args [], :ret {:spelling "struct AVAESCTR *"}, :function/args [], :symbol "av_aes_ctr_alloc", :function/ret [:coffi.mem/pointer :clong/AVAESCTR], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_alloc, :raw-comment "/**\n * Allocate an AVAESCTR context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_alloc"} {:args [{:spelling "a", :type "struct AVAESCTR *"} {:spelling "key", :type "const unsigned char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_aes_ctr_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_init, :raw-comment "/**\n * Initialize an AVAESCTR context.\n * @param key encryption key, must have a length of AES_CTR_KEY_SIZE\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_init"} {:args [{:spelling "a", :type "struct AVAESCTR *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR]], :symbol "av_aes_ctr_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_free, :raw-comment "/**\n * Release an AVAESCTR context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_free"} {:args [{:spelling "a", :type "struct AVAESCTR *"} {:spelling "dst", :type "unsigned char *"} {:spelling "src", :type "const unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_aes_ctr_crypt", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_crypt, :raw-comment "/**\n * Process a buffer using a previously initialized context.\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param size the size of src and dst\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_crypt"} {:args [{:spelling "a", :type "struct AVAESCTR *"}], :ret {:spelling "const unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR]], :symbol "av_aes_ctr_get_iv", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_get_iv, :raw-comment "/**\n * Get the current iv\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_get_iv"} {:args [{:spelling "a", :type "struct AVAESCTR *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR]], :symbol "av_aes_ctr_set_random_iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_set_random_iv, :raw-comment "/**\n * Generate a random iv\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_set_random_iv"} {:args [{:spelling "a", :type "struct AVAESCTR *"} {:spelling "iv", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_aes_ctr_set_iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_set_iv, :raw-comment "/**\n * Forcefully change the 8-byte iv\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_set_iv"} {:args [{:spelling "a", :type "struct AVAESCTR *"} {:spelling "iv", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_aes_ctr_set_full_iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_set_full_iv, :raw-comment "/**\n * Forcefully change the \"full\" 16-byte iv, including the counter\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_set_full_iv"} {:args [{:spelling "a", :type "struct AVAESCTR *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAESCTR]], :symbol "av_aes_ctr_increment_iv", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_aes_ctr_increment_iv, :raw-comment "/**\n * Increment the top 64 bit of the iv (performed after each frame)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_aes_ctr_increment_iv"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVDownmixInfo *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_downmix_info_update_side_data", :function/ret [:coffi.mem/pointer :clong/AVDownmixInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_downmix_info_update_side_data, :raw-comment "/**\n * Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.\n *\n * If the side data is absent, it is created and added to the frame.\n *\n * @param frame the frame for which the side data is to be obtained or created\n *\n * @return the AVDownmixInfo structure to be edited by the caller, or NULL if\n *         the structure cannot be allocated.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_downmix_info_update_side_data"} {:args [{:spelling "ctx", :type "struct AVHashContext **"} {:spelling "name", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVHashContext]] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_hash_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_alloc, :raw-comment "/**\n * Allocate a hash context for the algorithm specified by name.\n *\n * @return  >= 0 for success, a negative error code for failure\n *\n * @note The context is not initialized after a call to this function; you must\n * call av_hash_init() to do so.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_alloc"} {:args [{:spelling "i", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_hash_names", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_names, :raw-comment "/**\n * Get the names of available hash algorithms.\n *\n * This function can be used to enumerate the algorithms.\n *\n * @param[in] i  Index of the hash algorithm, starting from 0\n * @return       Pointer to a static string or `NULL` if `i` is out of range\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_names"} {:args [{:spelling "ctx", :type "const struct AVHashContext *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext]], :symbol "av_hash_get_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_get_name, :raw-comment "/**\n * Get the name of the algorithm corresponding to the given hash context.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_get_name"} {:args [{:spelling "ctx", :type "const struct AVHashContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext]], :symbol "av_hash_get_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_get_size, :raw-comment "/**\n * Get the size of the resulting hash value in bytes.\n *\n * The maximum value this function will currently return is available as macro\n * #AV_HASH_MAX_SIZE.\n *\n * @param[in]     ctx Hash context\n * @return            Size of the hash value in bytes\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_get_size"} {:args [{:spelling "ctx", :type "struct AVHashContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext]], :symbol "av_hash_init", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_init, :raw-comment "/**\n * Initialize or reset a hash context.\n *\n * @param[in,out] ctx Hash context\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_init"} {:args [{:spelling "ctx", :type "struct AVHashContext *"} {:spelling "src", :type "const unsigned char *"} {:spelling "len", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hash_update", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_update, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_hash_update"} {:args [{:spelling "ctx", :type "struct AVHashContext *"} {:spelling "dst", :type "unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_hash_final", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_final, :raw-comment "/**\n * Finalize a hash context and compute the actual hash value.\n *\n * The minimum size of `dst` buffer is given by av_hash_get_size() or\n * #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * @param[in,out] ctx Hash context\n * @param[out]    dst Where the final hash value will be stored\n *\n * @see av_hash_final_bin() provides an alternative API\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_final"} {:args [{:spelling "ctx", :type "struct AVHashContext *"} {:spelling "dst", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hash_final_bin", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_final_bin, :raw-comment "/**\n * Finalize a hash context and store the actual hash value in a buffer.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * If `size` is smaller than the hash size (given by av_hash_get_size()), the\n * hash is truncated; if size is larger, the buffer is padded with 0.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the final hash value will be stored\n * @param[in]     size Number of bytes to write to `dst`\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_final_bin"} {:args [{:spelling "ctx", :type "struct AVHashContext *"} {:spelling "dst", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hash_final_hex", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_final_hex, :raw-comment "/**\n * Finalize a hash context and store the hexadecimal representation of the\n * actual hash value as a string.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * The string is always 0-terminated.\n *\n * If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the\n * value returned by av_hash_get_size(), the string will be truncated.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the string will be stored\n * @param[in]     size Maximum number of bytes to write to `dst`\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_final_hex"} {:args [{:spelling "ctx", :type "struct AVHashContext *"} {:spelling "dst", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHashContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hash_final_b64", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_final_b64, :raw-comment "/**\n * Finalize a hash context and store the Base64 representation of the\n * actual hash value as a string.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * The string is always 0-terminated.\n *\n * If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is\n * the value returned by av_hash_get_size(), the string will be truncated.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the final hash value will be stored\n * @param[in]     size Maximum number of bytes to write to `dst`\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_final_b64"} {:args [{:spelling "ctx", :type "struct AVHashContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVHashContext]]], :symbol "av_hash_freep", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hash_freep, :raw-comment "/**\n * Free hash context and set hash context pointer to `NULL`.\n *\n * @param[in,out] ctx  Pointer to hash context\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hash_freep"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVFilmGrainParams *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_film_grain_params_alloc", :function/ret [:coffi.mem/pointer :clong/AVFilmGrainParams], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_film_grain_params_alloc, :raw-comment "/**\n * Allocate an AVFilmGrainParams structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n * If size is not NULL it will be set to the number of bytes allocated.\n *\n * @return An AVFilmGrainParams filled with default values or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_film_grain_params_alloc"} {:args [{:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVFilmGrainParams *"}, :function/args [[:coffi.mem/pointer :clong/AVFrame]], :symbol "av_film_grain_params_create_side_data", :function/ret [:coffi.mem/pointer :clong/AVFilmGrainParams], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_film_grain_params_create_side_data, :raw-comment "/**\n * Allocate a complete AVFilmGrainParams and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVFilmGrainParams structure to be filled by caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_film_grain_params_create_side_data"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avresample_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_version, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Return the LIBAVRESAMPLE_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avresample_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_configuration, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Return the libavresample build-time configuration.\n * @return  configure string\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avresample_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_license, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Return the libavresample license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_license"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avresample_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_get_class, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Get the AVClass for AVAudioResampleContext.\n *\n * Can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options\n * without allocating a context.\n *\n * @see av_opt_find().\n *\n * @return AVClass for AVAudioResampleContext\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_get_class"} {:args [], :ret {:spelling "struct AVAudioResampleContext *"}, :function/args [], :symbol "avresample_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVAudioResampleContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_alloc_context, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Allocate AVAudioResampleContext and set options.\n *\n * @return  allocated audio resample context, or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_alloc_context"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext]], :symbol "avresample_open", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_open, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Initialize AVAudioResampleContext.\n * @note The context must be configured using the AVOption API.\n * @note The fields \"in_channel_layout\", \"out_channel_layout\",\n *       \"in_sample_rate\", \"out_sample_rate\", \"in_sample_fmt\",\n *       \"out_sample_fmt\" must be set.\n *\n * @see av_opt_set_int()\n * @see av_opt_set_dict()\n * @see av_get_default_channel_layout()\n *\n * @param avr  audio resample context\n * @return     0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_open"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext]], :symbol "avresample_is_open", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_is_open, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Check whether an AVAudioResampleContext is open or closed.\n *\n * @param avr AVAudioResampleContext to check\n * @return 1 if avr is open, 0 if avr is closed.\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_is_open"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext]], :symbol "avresample_close", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_close, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Close AVAudioResampleContext.\n *\n * This closes the context, but it does not change the parameters. The context\n * can be reopened with avresample_open(). It does, however, clear the output\n * FIFO and any remaining leftover samples in the resampling delay buffer. If\n * there was a custom matrix being used, that is also cleared.\n *\n * @see avresample_convert()\n * @see avresample_set_matrix()\n *\n * @param avr  audio resample context\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_close"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVAudioResampleContext]]], :symbol "avresample_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_free, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Free AVAudioResampleContext and associated AVOption values.\n *\n * This also calls avresample_close() before freeing.\n *\n * @param avr  audio resample context\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_free"} {:args [{:spelling "in_layout", :type "unsigned long long"} {:spelling "out_layout", :type "unsigned long long"} {:spelling "center_mix_level", :type "double"} {:spelling "surround_mix_level", :type "double"} {:spelling "lfe_mix_level", :type "double"} {:spelling "normalize", :type "int"} {:spelling "matrix", :type "double *"} {:spelling "stride", :type "int"} {:spelling "matrix_encoding", :type "enum AVMatrixEncoding"}], :ret {:spelling "int"}, :function/args [:coffi.mem/long :coffi.mem/long :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/int [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/int :coffi.mem/int], :symbol "avresample_build_matrix", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_build_matrix, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Generate a channel mixing matrix.\n *\n * This function is the one used internally by libavresample for building the\n * default mixing matrix. It is made public just as a utility function for\n * building custom matrices.\n *\n * @param in_layout           input channel layout\n * @param out_layout          output channel layout\n * @param center_mix_level    mix level for the center channel\n * @param surround_mix_level  mix level for the surround channel(s)\n * @param lfe_mix_level       mix level for the low-frequency effects channel\n * @param normalize           if 1, coefficients will be normalized to prevent\n *                            overflow. if 0, coefficients will not be\n *                            normalized.\n * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is\n *                            the weight of input channel i in output channel o.\n * @param stride              distance between adjacent input channels in the\n *                            matrix array\n * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)\n * @return                    0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_build_matrix"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "matrix", :type "double *"} {:spelling "stride", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/int], :symbol "avresample_get_matrix", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_get_matrix, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Get the current channel mixing matrix.\n *\n * If no custom matrix has been previously set or the AVAudioResampleContext is\n * not open, an error is returned.\n *\n * @param avr     audio resample context\n * @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of\n *                input channel i in output channel o.\n * @param stride  distance between adjacent input channels in the matrix array\n * @return        0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_get_matrix"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "matrix", :type "const double *"} {:spelling "stride", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/int], :symbol "avresample_set_matrix", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_set_matrix, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Set channel mixing matrix.\n *\n * Allows for setting a custom mixing matrix, overriding the default matrix\n * generated internally during avresample_open(). This function can be called\n * anytime on an allocated context, either before or after calling\n * avresample_open(), as long as the channel layouts have been set.\n * avresample_convert() always uses the current matrix.\n * Calling avresample_close() on the context will clear the current matrix.\n *\n * @see avresample_close()\n *\n * @param avr     audio resample context\n * @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of\n *                input channel i in output channel o.\n * @param stride  distance between adjacent input channels in the matrix array\n * @return        0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_set_matrix"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "channel_map", :type "const int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avresample_set_channel_mapping", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_set_channel_mapping, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Set a customized input channel mapping.\n *\n * This function can only be called when the allocated context is not open.\n * Also, the input channel layout must have already been set.\n *\n * Calling avresample_close() on the context will clear the channel mapping.\n *\n * The map for each input channel specifies the channel index in the source to\n * use for that particular channel, or -1 to mute the channel. Source channels\n * can be duplicated by using the same index for multiple input channels.\n *\n * Examples:\n *\n * Reordering 5.1 AAC order (C,L,R,Ls,Rs,LFE) to FFmpeg order (L,R,C,LFE,Ls,Rs):\n * { 1, 2, 0, 5, 3, 4 }\n *\n * Muting the 3rd channel in 4-channel input:\n * { 0, 1, -1, 3 }\n *\n * Duplicating the left channel of stereo input:\n * { 0, 0 }\n *\n * @param avr         audio resample context\n * @param channel_map customized input channel mapping\n * @return            0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_set_channel_mapping"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "sample_delta", :type "int"} {:spelling "compensation_distance", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] :coffi.mem/int :coffi.mem/int], :symbol "avresample_set_compensation", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_set_compensation, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Set compensation for resampling.\n *\n * This can be called anytime after avresample_open(). If resampling is not\n * automatically enabled because of a sample rate conversion, the\n * \"force_resampling\" option must have been set to 1 when opening the context\n * in order to use resampling compensation.\n *\n * @param avr                    audio resample context\n * @param sample_delta           compensation delta, in samples\n * @param compensation_distance  compensation distance, in samples\n * @return                       0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_set_compensation"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "in_nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] :coffi.mem/int], :symbol "avresample_get_out_samples", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_get_out_samples, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Provide the upper bound on the number of samples the configured\n * conversion would output.\n *\n * @param avr           audio resample context\n * @param in_nb_samples number of input samples\n *\n * @return              number of samples or AVERROR(EINVAL) if the value\n *                      would exceed INT_MAX\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_get_out_samples"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "output", :type "unsigned char **"} {:spelling "out_plane_size", :type "int"} {:spelling "out_samples", :type "int"} {:spelling "input", :type "unsigned char *const *"} {:spelling "in_plane_size", :type "int"} {:spelling "in_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int :coffi.mem/int], :symbol "avresample_convert", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_convert, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Convert input samples and write them to the output FIFO.\n *\n * The upper bound on the number of output samples can be obtained through\n * avresample_get_out_samples().\n *\n * The output data can be NULL or have fewer allocated samples than required.\n * In this case, any remaining samples not written to the output will be added\n * to an internal FIFO buffer, to be returned at the next call to this function\n * or to avresample_read().\n *\n * If converting sample rate, there may be data remaining in the internal\n * resampling delay buffer. avresample_get_delay() tells the number of remaining\n * samples. To get this data as output, call avresample_convert() with NULL\n * input.\n *\n * At the end of the conversion process, there may be data remaining in the\n * internal FIFO buffer. avresample_available() tells the number of remaining\n * samples. To get this data as output, either call avresample_convert() with\n * NULL input or call avresample_read().\n *\n * @see avresample_get_out_samples()\n * @see avresample_read()\n * @see avresample_get_delay()\n *\n * @param avr             audio resample context\n * @param output          output data pointers\n * @param out_plane_size  output plane size, in bytes.\n *                        This can be 0 if unknown, but that will lead to\n *                        optimized functions not being used directly on the\n *                        output, which could slow down some conversions.\n * @param out_samples     maximum number of samples that the output buffer can hold\n * @param input           input data pointers\n * @param in_plane_size   input plane size, in bytes\n *                        This can be 0 if unknown, but that will lead to\n *                        optimized functions not being used directly on the\n *                        input, which could slow down some conversions.\n * @param in_samples      number of input samples to convert\n * @return                number of samples written to the output buffer,\n *                        not including converted samples added to the internal\n *                        output FIFO\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_convert"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext]], :symbol "avresample_get_delay", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_get_delay, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Return the number of samples currently in the resampling delay buffer.\n *\n * When resampling, there may be a delay between the input and output. Any\n * unconverted samples in each call are stored internally in a delay buffer.\n * This function allows the user to determine the current number of samples in\n * the delay buffer, which can be useful for synchronization.\n *\n * @see avresample_convert()\n *\n * @param avr  audio resample context\n * @return     number of samples currently in the resampling delay buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_get_delay"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext]], :symbol "avresample_available", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_available, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Return the number of available samples in the output FIFO.\n *\n * During conversion, if the user does not specify an output buffer or\n * specifies an output buffer that is smaller than what is needed, remaining\n * samples that are not written to the output are stored to an internal FIFO\n * buffer. The samples in the FIFO can be read with avresample_read() or\n * avresample_convert().\n *\n * @see avresample_read()\n * @see avresample_convert()\n *\n * @param avr  audio resample context\n * @return     number of samples available for reading\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_available"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "output", :type "unsigned char **"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int], :symbol "avresample_read", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_read, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Read samples from the output FIFO.\n *\n * During conversion, if the user does not specify an output buffer or\n * specifies an output buffer that is smaller than what is needed, remaining\n * samples that are not written to the output are stored to an internal FIFO\n * buffer. This function can be used to read samples from that internal FIFO.\n *\n * @see avresample_available()\n * @see avresample_convert()\n *\n * @param avr         audio resample context\n * @param output      output data pointers. May be NULL, in which case\n *                    nb_samples of data is discarded from output FIFO.\n * @param nb_samples  number of samples to read from the FIFO\n * @return            the number of samples written to output\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_read"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "output", :type "struct AVFrame *"} {:spelling "input", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "avresample_convert_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_convert_frame, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Convert the samples in the input AVFrame and write them to the output AVFrame.\n *\n * Input and output AVFrames must have channel_layout, sample_rate and format set.\n *\n * The upper bound on the number of output samples is obtained through\n * avresample_get_out_samples().\n *\n * If the output AVFrame does not have the data pointers allocated the nb_samples\n * field will be set using avresample_get_out_samples() and av_frame_get_buffer()\n * is called to allocate the frame.\n *\n * The output AVFrame can be NULL or have fewer allocated samples than required.\n * In this case, any remaining samples not written to the output will be added\n * to an internal FIFO buffer, to be returned at the next call to this function\n * or to avresample_convert() or to avresample_read().\n *\n * If converting sample rate, there may be data remaining in the internal\n * resampling delay buffer. avresample_get_delay() tells the number of\n * remaining samples. To get this data as output, call this function or\n * avresample_convert() with NULL input.\n *\n * At the end of the conversion process, there may be data remaining in the\n * internal FIFO buffer. avresample_available() tells the number of remaining\n * samples. To get this data as output, either call this function or\n * avresample_convert() with NULL input or call avresample_read().\n *\n * If the AVAudioResampleContext configuration does not match the output and\n * input AVFrame settings the conversion does not take place and depending on\n * which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED\n * or AVERROR_OUTPUT_CHANGED|AVERROR_INPUT_CHANGED is returned.\n *\n * @see avresample_get_out_samples()\n * @see avresample_available()\n * @see avresample_convert()\n * @see avresample_read()\n * @see avresample_get_delay()\n *\n * @param avr             audio resample context\n * @param output          output AVFrame\n * @param input           input AVFrame\n * @return                0 on success, AVERROR on failure or nonmatching\n *                        configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_convert_frame"} {:args [{:spelling "avr", :type "struct AVAudioResampleContext *"} {:spelling "out", :type "struct AVFrame *"} {:spelling "in", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVAudioResampleContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "avresample_config", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avresample_config, :raw-comment "/**\n *\n * @deprecated use libswresample\n *\n * Configure or reconfigure the AVAudioResampleContext using the information\n * provided by the AVFrames.\n *\n * The original resampling context is reset even on failure.\n * The function calls avresample_close() internally if the context is open.\n *\n * @see avresample_open();\n * @see avresample_close();\n *\n * @param avr             audio resample context\n * @param out             output AVFrame\n * @param in              input AVFrame\n * @return                0 on success, AVERROR on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avresample_config"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avfilter_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_version, :raw-comment "/**\n * Return the LIBAVFILTER_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avfilter_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_configuration, :raw-comment "/**\n * Return the libavfilter build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avfilter_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_license, :raw-comment "/**\n * Return the libavfilter license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_license"} {:args [{:spelling "pads", :type "const struct AVFilterPad *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterPad]], :symbol "avfilter_pad_count", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_pad_count, :raw-comment "/**\n * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.\n * AVFilter.inputs/outputs).\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_pad_count"} {:args [{:spelling "pads", :type "const struct AVFilterPad *"} {:spelling "pad_idx", :type "int"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clong/AVFilterPad] :coffi.mem/int], :symbol "avfilter_pad_get_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_pad_get_name, :raw-comment "/**\n * Get the name of an AVFilterPad.\n *\n * @param pads an array of AVFilterPads\n * @param pad_idx index of the pad in the array; it is the caller's\n *                responsibility to ensure the index is valid\n *\n * @return name of the pad_idx'th pad in pads\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_pad_get_name"} {:args [{:spelling "pads", :type "const struct AVFilterPad *"} {:spelling "pad_idx", :type "int"}], :ret {:spelling "enum AVMediaType"}, :function/args [[:coffi.mem/pointer :clong/AVFilterPad] :coffi.mem/int], :symbol "avfilter_pad_get_type", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_pad_get_type, :raw-comment "/**\n * Get the type of an AVFilterPad.\n *\n * @param pads an array of AVFilterPads\n * @param pad_idx index of the pad in the array; it is the caller's\n *                responsibility to ensure the index is valid\n *\n * @return type of the pad_idx'th pad in pads\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_pad_get_type"} {:args [{:spelling "src", :type "struct AVFilterContext *"} {:spelling "srcpad", :type "unsigned int"} {:spelling "dst", :type "struct AVFilterContext *"} {:spelling "dstpad", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/int [:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/int], :symbol "avfilter_link", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_link, :raw-comment "/**\n * Link two filters together.\n *\n * @param src    the source filter\n * @param srcpad index of the output pad on the source filter\n * @param dst    the destination filter\n * @param dstpad index of the input pad on the destination filter\n * @return       zero on success\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_link"} {:args [{:spelling "link", :type "struct AVFilterLink **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterLink]]], :symbol "avfilter_link_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_link_free, :raw-comment "/**\n * Free the link in *link, and set its pointer to NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_link_free"} {:args [{:spelling "link", :type "struct AVFilterLink *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterLink]], :symbol "avfilter_link_get_channels", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_link_get_channels, :raw-comment "/**\n * Get the number of channels of a link.\n * @deprecated Use av_buffersink_get_channels()\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_link_get_channels"} {:args [{:spelling "link", :type "struct AVFilterLink *"} {:spelling "closed", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFilterLink] :coffi.mem/int], :symbol "avfilter_link_set_closed", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_link_set_closed, :raw-comment "/**\n * Set the closed field of a link.\n * @deprecated applications are not supposed to mess with links, they should\n * close the sinks.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_link_set_closed"} {:args [{:spelling "filter", :type "struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "avfilter_config_links", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_config_links, :raw-comment "/**\n * Negotiate the media format, dimensions, etc of all inputs to a filter.\n *\n * @param filter the filter to negotiate the properties for its inputs\n * @return       zero on successful negotiation\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_config_links"} {:args [{:spelling "filter", :type "struct AVFilterContext *"} {:spelling "cmd", :type "const char *"} {:spelling "arg", :type "const char *"} {:spelling "res", :type "char *"} {:spelling "res_len", :type "int"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "avfilter_process_command", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_process_command, :raw-comment "/**\n * Make the filter instance process a command.\n * It is recommended to use avfilter_graph_send_command().\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_process_command"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVFilter *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_filter_iterate", :function/ret [:coffi.mem/pointer :clong/AVFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_filter_iterate, :raw-comment "/**\n * Iterate over all registered filters.\n *\n * @param opaque a pointer where libavfilter will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered filter or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_filter_iterate"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "avfilter_register_all", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_register_all, :raw-comment "/** Initialize the filter system. Register all builtin filters. */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_register_all"} {:args [{:spelling "filter", :type "struct AVFilter *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilter]], :symbol "avfilter_register", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_register, :raw-comment "/**\n * Register a filter. This is only needed if you plan to use\n * avfilter_get_by_name later to lookup the AVFilter structure by name. A\n * filter can still by instantiated with avfilter_graph_alloc_filter even if it\n * is not registered.\n *\n * @param filter the filter to register\n * @return 0 if the registration was successful, a negative value\n * otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_register"} {:args [{:spelling "prev", :type "const struct AVFilter *"}], :ret {:spelling "const struct AVFilter *"}, :function/args [[:coffi.mem/pointer :clong/AVFilter]], :symbol "avfilter_next", :function/ret [:coffi.mem/pointer :clong/AVFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_next, :raw-comment "/**\n * Iterate over all registered filters.\n * @return If prev is non-NULL, next registered filter after prev or NULL if\n * prev is the last filter. If prev is NULL, return the first registered filter.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_next"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "const struct AVFilter *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avfilter_get_by_name", :function/ret [:coffi.mem/pointer :clong/AVFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_get_by_name, :raw-comment "/**\n * Get a filter definition matching the given name.\n *\n * @param name the filter name to find\n * @return     the filter definition, if any matching one is registered.\n *             NULL if none found.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_get_by_name"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "args", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avfilter_init_str", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_init_str, :raw-comment "/**\n * Initialize a filter with the supplied parameters.\n *\n * @param ctx  uninitialized filter context to initialize\n * @param args Options to initialize the filter with. This must be a\n *             ':'-separated list of options in the 'key=value' form.\n *             May be NULL if the options have been set directly using the\n *             AVOptions API or there are no options that need to be set.\n * @return 0 on success, a negative AVERROR on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_init_str"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avfilter_init_dict", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_init_dict, :raw-comment "/**\n * Initialize a filter with the supplied dictionary of options.\n *\n * @param ctx     uninitialized filter context to initialize\n * @param options An AVDictionary filled with options for this filter. On\n *                return this parameter will be destroyed and replaced with\n *                a dict containing options that were not found. This dictionary\n *                must be freed by the caller.\n *                May be NULL, then this function is equivalent to\n *                avfilter_init_str() with the second parameter set to NULL.\n * @return 0 on success, a negative AVERROR on failure\n *\n * @note This function and avfilter_init_str() do essentially the same thing,\n * the difference is in manner in which the options are passed. It is up to the\n * calling code to choose whichever is more preferable. The two functions also\n * behave differently when some of the provided options are not declared as\n * supported by the filter. In such a case, avfilter_init_str() will fail, but\n * this function will leave those extra options in the options AVDictionary and\n * continue as usual.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_init_dict"} {:args [{:spelling "filter", :type "struct AVFilterContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "avfilter_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_free, :raw-comment "/**\n * Free a filter context. This will also remove the filter from its\n * filtergraph's list of filters.\n *\n * @param filter the filter to free\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_free"} {:args [{:spelling "link", :type "struct AVFilterLink *"} {:spelling "filt", :type "struct AVFilterContext *"} {:spelling "filt_srcpad_idx", :type "unsigned int"} {:spelling "filt_dstpad_idx", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterLink] [:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/int :coffi.mem/int], :symbol "avfilter_insert_filter", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_insert_filter, :raw-comment "/**\n * Insert a filter in the middle of an existing link.\n *\n * @param link the link into which the filter should be inserted\n * @param filt the filter to be inserted\n * @param filt_srcpad_idx the input pad on the filter to connect\n * @param filt_dstpad_idx the output pad on the filter to connect\n * @return     zero on success\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_insert_filter"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avfilter_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_get_class, :raw-comment "/**\n * @return AVClass for AVFilterContext.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_get_class"} {:args [], :ret {:spelling "struct AVFilterGraph *"}, :function/args [], :symbol "avfilter_graph_alloc", :function/ret [:coffi.mem/pointer :clong/AVFilterGraph], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_alloc, :raw-comment "/**\n * Allocate a filter graph.\n *\n * @return the allocated filter graph on success or NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_alloc"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "filter", :type "const struct AVFilter *"} {:spelling "name", :type "const char *"}], :ret {:spelling "struct AVFilterContext *"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :clong/AVFilter] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avfilter_graph_alloc_filter", :function/ret [:coffi.mem/pointer :clong/AVFilterContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_alloc_filter, :raw-comment "/**\n * Create a new filter instance in a filter graph.\n *\n * @param graph graph in which the new filter will be used\n * @param filter the filter to create an instance of\n * @param name Name to give to the new instance (will be copied to\n *             AVFilterContext.name). This may be used by the caller to identify\n *             different filters, libavfilter itself assigns no semantics to\n *             this parameter. May be NULL.\n *\n * @return the context of the newly created filter instance (note that it is\n *         also retrievable directly through AVFilterGraph.filters or with\n *         avfilter_graph_get_filter()) on success or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_alloc_filter"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "name", :type "const char *"}], :ret {:spelling "struct AVFilterContext *"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avfilter_graph_get_filter", :function/ret [:coffi.mem/pointer :clong/AVFilterContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_get_filter, :raw-comment "/**\n * Get a filter instance identified by instance name from graph.\n *\n * @param graph filter graph to search through.\n * @param name filter instance name (should be unique in the graph).\n * @return the pointer to the found filter instance or NULL if it\n * cannot be found.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_get_filter"} {:args [{:spelling "filt_ctx", :type "struct AVFilterContext **"} {:spelling "filt", :type "const struct AVFilter *"} {:spelling "name", :type "const char *"} {:spelling "args", :type "const char *"} {:spelling "opaque", :type "void *"} {:spelling "graph_ctx", :type "struct AVFilterGraph *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterContext]] [:coffi.mem/pointer :clong/AVFilter] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterGraph]], :symbol "avfilter_graph_create_filter", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_create_filter, :raw-comment "/**\n * Create and add a filter instance into an existing graph.\n * The filter instance is created from the filter filt and inited\n * with the parameter args. opaque is currently ignored.\n *\n * In case of success put in *filt_ctx the pointer to the created\n * filter instance, otherwise set *filt_ctx to NULL.\n *\n * @param name the instance name to give to the created filter instance\n * @param graph_ctx the filter graph\n * @return a negative AVERROR error code in case of failure, a non\n * negative value otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_create_filter"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] :coffi.mem/int], :symbol "avfilter_graph_set_auto_convert", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_set_auto_convert, :raw-comment "/**\n * Enable or disable automatic format conversion inside the graph.\n *\n * Note that format conversion can still happen inside explicitly inserted\n * scale and aresample filters.\n *\n * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_set_auto_convert"} {:args [{:spelling "graphctx", :type "struct AVFilterGraph *"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] :coffi.mem/pointer], :symbol "avfilter_graph_config", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_config, :raw-comment "/**\n * Check validity and configure all the links and formats in the graph.\n *\n * @param graphctx the filter graph\n * @param log_ctx context used for logging\n * @return >= 0 in case of success, a negative AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_config"} {:args [{:spelling "graph", :type "struct AVFilterGraph **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterGraph]]], :symbol "avfilter_graph_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_free, :raw-comment "/**\n * Free a graph, destroy its links, and set *graph to NULL.\n * If *graph is NULL, do nothing.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_free"} {:args [], :ret {:spelling "struct AVFilterInOut *"}, :function/args [], :symbol "avfilter_inout_alloc", :function/ret [:coffi.mem/pointer :clong/AVFilterInOut], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_inout_alloc, :raw-comment "/**\n * Allocate a single AVFilterInOut entry.\n * Must be freed with avfilter_inout_free().\n * @return allocated AVFilterInOut on success, NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_inout_alloc"} {:args [{:spelling "inout", :type "struct AVFilterInOut **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterInOut]]], :symbol "avfilter_inout_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_inout_free, :raw-comment "/**\n * Free the supplied list of AVFilterInOut and set *inout to NULL.\n * If *inout is NULL, do nothing.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_inout_free"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "filters", :type "const char *"} {:spelling "inputs", :type "struct AVFilterInOut *"} {:spelling "outputs", :type "struct AVFilterInOut *"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVFilterInOut] [:coffi.mem/pointer :clong/AVFilterInOut] :coffi.mem/pointer], :symbol "avfilter_graph_parse", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_parse, :raw-comment "/**\n * Add a graph described by a string to a graph.\n *\n * @note The caller must provide the lists of inputs and outputs,\n * which therefore must be known before calling the function.\n *\n * @note The inputs parameter describes inputs of the already existing\n * part of the graph; i.e. from the point of view of the newly created\n * part, they are outputs. Similarly the outputs parameter describes\n * outputs of the already existing filters, which are provided as\n * inputs to the parsed filters.\n *\n * @param graph   the filter graph where to link the parsed graph context\n * @param filters string to be parsed\n * @param inputs  linked list to the inputs of the graph\n * @param outputs linked list to the outputs of the graph\n * @return zero on success, a negative AVERROR code on error\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_parse"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "filters", :type "const char *"} {:spelling "inputs", :type "struct AVFilterInOut **"} {:spelling "outputs", :type "struct AVFilterInOut **"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterInOut]] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterInOut]] :coffi.mem/pointer], :symbol "avfilter_graph_parse_ptr", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_parse_ptr, :raw-comment "/**\n * Add a graph described by a string to a graph.\n *\n * In the graph filters description, if the input label of the first\n * filter is not specified, \"in\" is assumed; if the output label of\n * the last filter is not specified, \"out\" is assumed.\n *\n * @param graph   the filter graph where to link the parsed graph context\n * @param filters string to be parsed\n * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.\n *                If non-NULL, *inputs is updated to contain the list of open inputs\n *                after the parsing, should be freed with avfilter_inout_free().\n * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.\n *                If non-NULL, *outputs is updated to contain the list of open outputs\n *                after the parsing, should be freed with avfilter_inout_free().\n * @return non negative on success, a negative AVERROR code on error\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_parse_ptr"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "filters", :type "const char *"} {:spelling "inputs", :type "struct AVFilterInOut **"} {:spelling "outputs", :type "struct AVFilterInOut **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterInOut]] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterInOut]]], :symbol "avfilter_graph_parse2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_parse2, :raw-comment "/**\n * Add a graph described by a string to a graph.\n *\n * @param[in]  graph   the filter graph where to link the parsed graph context\n * @param[in]  filters string to be parsed\n * @param[out] inputs  a linked list of all free (unlinked) inputs of the\n *                     parsed graph will be returned here. It is to be freed\n *                     by the caller using avfilter_inout_free().\n * @param[out] outputs a linked list of all free (unlinked) outputs of the\n *                     parsed graph will be returned here. It is to be freed by the\n *                     caller using avfilter_inout_free().\n * @return zero on success, a negative AVERROR code on error\n *\n * @note This function returns the inputs and outputs that are left\n * unlinked after parsing the graph and the caller then deals with\n * them.\n * @note This function makes no reference whatsoever to already\n * existing parts of the graph and the inputs parameter will on return\n * contain inputs of the newly parsed part of the graph.  Analogously\n * the outputs parameter will contain outputs of the newly created\n * filters.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_parse2"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "target", :type "const char *"} {:spelling "cmd", :type "const char *"} {:spelling "arg", :type "const char *"} {:spelling "res", :type "char *"} {:spelling "res_len", :type "int"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "avfilter_graph_send_command", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_send_command, :raw-comment "/**\n * Send a command to one or more filter instances.\n *\n * @param graph  the filter graph\n * @param target the filter(s) to which the command should be sent\n *               \"all\" sends to all filters\n *               otherwise it can be a filter or filter instance name\n *               which will send the command to all matching filters.\n * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only\n * @param arg    the argument for the command\n * @param res    a buffer with size res_size where the filter(s) can return a response.\n *\n * @returns >=0 on success otherwise an error code.\n *              AVERROR(ENOSYS) on unsupported commands\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_send_command"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "target", :type "const char *"} {:spelling "cmd", :type "const char *"} {:spelling "arg", :type "const char *"} {:spelling "flags", :type "int"} {:spelling "ts", :type "double"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/double], :symbol "avfilter_graph_queue_command", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_queue_command, :raw-comment "/**\n * Queue a command for one or more filter instances.\n *\n * @param graph  the filter graph\n * @param target the filter(s) to which the command should be sent\n *               \"all\" sends to all filters\n *               otherwise it can be a filter or filter instance name\n *               which will send the command to all matching filters.\n * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only\n * @param arg    the argument for the command\n * @param ts     time at which the command should be sent to the filter\n *\n * @note As this executes commands after this function returns, no return code\n *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_queue_command"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"} {:spelling "options", :type "const char *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avfilter_graph_dump", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_dump, :raw-comment "/**\n * Dump a graph into a human-readable string representation.\n *\n * @param graph    the graph to dump\n * @param options  formatting options; currently ignored\n * @return  a string, or NULL in case of memory allocation failure;\n *          the string must be freed using av_free\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_dump"} {:args [{:spelling "graph", :type "struct AVFilterGraph *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterGraph]], :symbol "avfilter_graph_request_oldest", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avfilter_graph_request_oldest, :raw-comment "/**\n * Request a frame on the oldest sink link.\n *\n * If the request returns AVERROR_EOF, try the next.\n *\n * Note that this function is not meant to be the sole scheduling mechanism\n * of a filtergraph, only a convenience function to help drain a filtergraph\n * in a balanced way under normal circumstances.\n *\n * Also note that AVERROR_EOF does not mean that frames did not arrive on\n * some of the sinks during the process.\n * When there are multiple sink links, in case the requested link\n * returns an EOF, this may cause a filter to flush pending frames\n * which are sent to another sink link, although unrequested.\n *\n * @return  the return value of ff_request_frame(),\n *          or AVERROR_EOF if all links returned AVERROR_EOF\n */", :kind "CXCursor_FunctionDecl", :spelling "avfilter_graph_request_oldest"} {:args [{:spelling "buffer_src", :type "struct AVFilterContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersrc_get_nb_failed_requests", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_get_nb_failed_requests, :raw-comment "/**\n * Get the number of failed requests.\n *\n * A failed request is when the request_frame method is called while no\n * frame is present in the buffer.\n * The number is reset when a frame is added.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_get_nb_failed_requests"} {:args [], :ret {:spelling "struct AVBufferSrcParameters *"}, :function/args [], :symbol "av_buffersrc_parameters_alloc", :function/ret [:coffi.mem/pointer :clong/AVBufferSrcParameters], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_parameters_alloc, :raw-comment "/**\n * Allocate a new AVBufferSrcParameters instance. It should be freed by the\n * caller with av_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_parameters_alloc"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "param", :type "struct AVBufferSrcParameters *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVBufferSrcParameters]], :symbol "av_buffersrc_parameters_set", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_parameters_set, :raw-comment "/**\n * Initialize the buffersrc or abuffersrc filter with the provided parameters.\n * This function may be called multiple times, the later calls override the\n * previous ones. Some of the parameters may also be set through AVOptions, then\n * whatever method is used last takes precedence.\n *\n * @param ctx an instance of the buffersrc or abuffersrc filter\n * @param param the stream parameters. The frames later passed to this filter\n *              must conform to those parameters. All the allocated fields in\n *              param remain owned by the caller, libavfilter will make internal\n *              copies or references when necessary.\n * @return 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_parameters_set"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_buffersrc_write_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_write_frame, :raw-comment "/**\n * Add a frame to the buffer source.\n *\n * @param ctx   an instance of the buffersrc filter\n * @param frame frame to be added. If the frame is reference counted, this\n * function will make a new reference to it. Otherwise the frame data will be\n * copied.\n *\n * @return 0 on success, a negative AVERROR on error\n *\n * This function is equivalent to av_buffersrc_add_frame_flags() with the\n * AV_BUFFERSRC_FLAG_KEEP_REF flag.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_write_frame"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_buffersrc_add_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_add_frame, :raw-comment "/**\n * Add a frame to the buffer source.\n *\n * @param ctx   an instance of the buffersrc filter\n * @param frame frame to be added. If the frame is reference counted, this\n * function will take ownership of the reference(s) and reset the frame.\n * Otherwise the frame data will be copied. If this function returns an error,\n * the input frame is not touched.\n *\n * @return 0 on success, a negative AVERROR on error.\n *\n * @note the difference between this function and av_buffersrc_write_frame() is\n * that av_buffersrc_write_frame() creates a new reference to the input frame,\n * while this function takes ownership of the reference passed to it.\n *\n * This function is equivalent to av_buffersrc_add_frame_flags() without the\n * AV_BUFFERSRC_FLAG_KEEP_REF flag.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_add_frame"} {:args [{:spelling "buffer_src", :type "struct AVFilterContext *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_buffersrc_add_frame_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_add_frame_flags, :raw-comment "/**\n * Add a frame to the buffer source.\n *\n * By default, if the frame is reference-counted, this function will take\n * ownership of the reference(s) and reset the frame. This can be controlled\n * using the flags.\n *\n * If this function returns an error, the input frame is not touched.\n *\n * @param buffer_src  pointer to a buffer source context\n * @param frame       a frame, or NULL to mark EOF\n * @param flags       a combination of AV_BUFFERSRC_FLAG_*\n * @return            >= 0 in case of success, a negative AVERROR code\n *                    in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_add_frame_flags"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "pts", :type "long long"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/long :coffi.mem/int], :symbol "av_buffersrc_close", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersrc_close, :raw-comment "/**\n * Close the buffer source after EOF.\n *\n * This is similar to passing NULL to av_buffersrc_add_frame_flags()\n * except it takes the timestamp of the EOF, i.e. the timestamp of the end\n * of the last frame.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersrc_close"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_buffersink_get_frame_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_frame_flags, :raw-comment "/**\n * Get a frame with filtered data from sink and put it in frame.\n *\n * @param ctx    pointer to a buffersink or abuffersink filter context.\n * @param frame  pointer to an allocated frame that will be filled with data.\n *               The data must be freed using av_frame_unref() / av_frame_free()\n * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags\n *\n * @return  >= 0 in for success, a negative AVERROR code for failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_frame_flags"} {:args [], :ret {:spelling "struct AVBufferSinkParams *"}, :function/args [], :symbol "av_buffersink_params_alloc", :function/ret [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_params_alloc, :raw-comment "/**\n * Create an AVBufferSinkParams structure.\n *\n * Must be freed with av_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_params_alloc"} {:args [], :ret {:spelling "struct AVABufferSinkParams *"}, :function/args [], :symbol "av_abuffersink_params_alloc", :function/ret [:coffi.mem/pointer :clong/AVABufferSinkParams], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_abuffersink_params_alloc, :raw-comment "/**\n * Create an AVABufferSinkParams structure.\n *\n * Must be freed with av_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_abuffersink_params_alloc"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame_size", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/int], :symbol "av_buffersink_set_frame_size", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_set_frame_size, :raw-comment "/**\n * Set the frame size for an audio buffer sink.\n *\n * All calls to av_buffersink_get_buffer_ref will return a buffer with\n * exactly the specified number of samples, or AVERROR(EAGAIN) if there is\n * not enough. The last buffer at EOF will be padded with 0.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_set_frame_size"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "enum AVMediaType"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_type", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_type, :raw-comment "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_type"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_time_base", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_time_base, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_time_base"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_format", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_format, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_format"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_frame_rate", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_frame_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_frame_rate"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_w", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_w, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_w"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_h", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_h, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_h"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_sample_aspect_ratio", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_sample_aspect_ratio, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_sample_aspect_ratio"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_channels", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_channels, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_channels"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "unsigned long long"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_channel_layout", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_channel_layout, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_channel_layout"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_sample_rate", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_sample_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_sample_rate"} {:args [{:spelling "ctx", :type "const struct AVFilterContext *"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext]], :symbol "av_buffersink_get_hw_frames_ctx", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_hw_frames_ctx, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_hw_frames_ctx"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_buffersink_get_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_frame, :raw-comment "/**\n * Get a frame with filtered data from sink and put it in frame.\n *\n * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.\n * @param frame pointer to an allocated frame that will be filled with data.\n *              The data must be freed using av_frame_unref() / av_frame_free()\n *\n * @return\n *         - >= 0 if a frame was successfully returned.\n *         - AVERROR(EAGAIN) if no frames are available at this point; more\n *           input frames must be added to the filtergraph to get more output.\n *         - AVERROR_EOF if there will be no more output frames on this sink.\n *         - A different negative AVERROR code in other failure cases.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_frame"} {:args [{:spelling "ctx", :type "struct AVFilterContext *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "nb_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_buffersink_get_samples", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_buffersink_get_samples, :raw-comment "/**\n * Same as av_buffersink_get_frame(), but with the ability to specify the number\n * of samples read. This function is less efficient than\n * av_buffersink_get_frame(), because it copies the data around.\n *\n * @param ctx pointer to a context of the abuffersink AVFilter.\n * @param frame pointer to an allocated frame that will be filled with data.\n *              The data must be freed using av_frame_unref() / av_frame_free()\n *              frame will contain exactly nb_samples audio samples, except at\n *              the end of stream, when it can contain less than nb_samples.\n *\n * @return The return codes have the same meaning as for\n *         av_buffersink_get_frame().\n *\n * @warning do not mix this function with av_buffersink_get_frame(). Use only one or\n * the other with a single sink, not both.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_buffersink_get_samples"} {:args [{:spelling "url", :type "const char *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_find_protocol_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_find_protocol_name, :raw-comment "/**\n * Return the name of the protocol that will handle the passed URL.\n *\n * NULL is returned if no protocol could be found for the given URL.\n *\n * @return Name of the protocol or NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_find_protocol_name"} {:args [{:spelling "url", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_check", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_check, :raw-comment "/**\n * Return AVIO_FLAG_* access flags corresponding to the access permissions\n * of the resource in url, or a negative value corresponding to an\n * AVERROR code in case of failure. The returned access flags are\n * masked by the value in flags.\n *\n * @note This function is intrinsically unsafe, in the sense that the\n * checked resource may change its existence or permission status from\n * one call to another. Thus you should not trust the returned value,\n * unless you are sure that no other processes are accessing the\n * checked resource.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_check"} {:args [{:spelling "url_src", :type "const char *"} {:spelling "url_dst", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avpriv_io_move", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpriv_io_move, :raw-comment "/**\n * Move or rename a resource.\n *\n * @note url_src and url_dst should share the same protocol and authority.\n *\n * @param url_src url to resource to be moved\n * @param url_dst new url to resource if the operation succeeded\n * @return >=0 on success or negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avpriv_io_move"} {:args [{:spelling "url", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avpriv_io_delete", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpriv_io_delete, :raw-comment "/**\n * Delete a resource.\n *\n * @param url resource to be deleted.\n * @return >=0 on success or negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avpriv_io_delete"} {:args [{:spelling "s", :type "struct AVIODirContext **"} {:spelling "url", :type "const char *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avio_open_dir", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_open_dir, :raw-comment "/**\n * Open directory for reading.\n *\n * @param s       directory read context. Pointer to a NULL pointer must be passed.\n * @param url     directory to be listed.\n * @param options A dictionary filled with protocol-private options. On return\n *                this parameter will be destroyed and replaced with a dictionary\n *                containing options that were not found. May be NULL.\n * @return >=0 on success or negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_open_dir"} {:args [{:spelling "s", :type "struct AVIODirContext *"} {:spelling "next", :type "struct AVIODirEntry **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIODirEntry]]], :symbol "avio_read_dir", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_read_dir, :raw-comment "/**\n * Get next directory entry.\n *\n * Returned entry must be freed with avio_free_directory_entry(). In particular\n * it may outlive AVIODirContext.\n *\n * @param s         directory read context.\n * @param[out] next next entry or NULL when no more entries.\n * @return >=0 on success or negative on error. End of list is not considered an\n *             error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_read_dir"} {:args [{:spelling "s", :type "struct AVIODirContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]]]], :symbol "avio_close_dir", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_close_dir, :raw-comment "/**\n * Close directory.\n *\n * @note Entries created using avio_read_dir() are not deleted and must be\n * freeded with avio_free_directory_entry().\n *\n * @param s         directory read context.\n * @return >=0 on success or negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_close_dir"} {:args [{:spelling "entry", :type "struct AVIODirEntry **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIODirEntry]]], :symbol "avio_free_directory_entry", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_free_directory_entry, :raw-comment "/**\n * Free entry allocated by avio_read_dir().\n *\n * @param entry entry to be freed.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_free_directory_entry"} {:args [{:spelling "buffer", :type "unsigned char *"} {:spelling "buffer_size", :type "int"} {:spelling "write_flag", :type "int"} {:spelling "opaque", :type "void *"} {:spelling "read_packet", :type "int (*)(void *, unsigned char *, int)"} {:spelling "write_packet", :type "int (*)(void *, unsigned char *, int)"} {:spelling "seek", :type "long long (*)(void *, long long, int)"}], :ret {:spelling "struct AVIOContext *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/pointer [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int] [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int] [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/long :coffi.mem/int] :coffi.mem/long]], :symbol "avio_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVIOContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_alloc_context, :raw-comment "/**\n * Allocate and initialize an AVIOContext for buffered I/O. It must be later\n * freed with avio_context_free().\n *\n * @param buffer Memory block for input/output operations via AVIOContext.\n *        The buffer must be allocated with av_malloc() and friends.\n *        It may be freed and replaced with a new buffer by libavformat.\n *        AVIOContext.buffer holds the buffer currently in use,\n *        which must be later freed with av_free().\n * @param buffer_size The buffer size is very important for performance.\n *        For protocols with fixed blocksize it should be set to this blocksize.\n *        For others a typical size is a cache page, e.g. 4kb.\n * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.\n * @param opaque An opaque pointer to user-specific data.\n * @param read_packet  A function for refilling the buffer, may be NULL.\n *                     For stream protocols, must never return 0 but rather\n *                     a proper AVERROR code.\n * @param write_packet A function for writing the buffer contents, may be NULL.\n *        The function may not change the input buffers content.\n * @param seek A function for seeking to specified byte position, may be NULL.\n *\n * @return Allocated AVIOContext or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_alloc_context"} {:args [{:spelling "s", :type "struct AVIOContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]]], :symbol "avio_context_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_context_free, :raw-comment "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_context_free"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "b", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_w8", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_w8, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_w8"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_write", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_write, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_write"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/long], :symbol "avio_wl64", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wl64, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wl64"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned long long"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/long], :symbol "avio_wb64", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wb64, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wb64"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wl32", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wl32, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wl32"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wb32", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wb32, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wb32"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wl24", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wl24, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wl24"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wb24", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wb24, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wb24"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wl16", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wl16, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wl16"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "val", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_wb16", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_wb16, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_wb16"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "str", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_put_str", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_put_str, :raw-comment "/**\n * Write a NULL-terminated string.\n * @return number of bytes written.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_put_str"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "str", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_put_str16le", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_put_str16le, :raw-comment "/**\n * Convert an UTF-8 string to UTF-16LE and write it.\n * @param s the AVIOContext\n * @param str NULL-terminated UTF-8 string\n *\n * @return number of bytes written.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_put_str16le"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "str", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_put_str16be", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_put_str16be, :raw-comment "/**\n * Convert an UTF-8 string to UTF-16BE and write it.\n * @param s the AVIOContext\n * @param str NULL-terminated UTF-8 string\n *\n * @return number of bytes written.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_put_str16be"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "time", :type "long long"} {:spelling "type", :type "enum AVIODataMarkerType"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/long :coffi.mem/int], :symbol "avio_write_marker", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_write_marker, :raw-comment "/**\n * Mark the written bytestream as a specific type.\n *\n * Zero-length ranges are omitted from the output.\n *\n * @param time the stream time the current bytestream pos corresponds to\n *             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not\n *             applicable\n * @param type the kind of data written starting at the current pos\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_write_marker"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "offset", :type "long long"} {:spelling "whence", :type "int"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/long :coffi.mem/int], :symbol "avio_seek", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_seek, :raw-comment "/**\n * fseek() equivalent for AVIOContext.\n * @return new position or AVERROR.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_seek"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "offset", :type "long long"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/long], :symbol "avio_skip", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_skip, :raw-comment "/**\n * Skip given number of bytes forward\n * @return new position or AVERROR.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_skip"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_size", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_size, :raw-comment "/**\n * Get the filesize.\n * @return filesize or AVERROR\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_size"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_feof", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_feof, :raw-comment "/**\n * Similar to feof() but also returns nonzero on read errors.\n * @return non zero if and only if at end of file or a read error happened when reading.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_feof"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "fmt", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_printf", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_printf, :raw-comment "/**\n * Writes a formatted string to the context.\n * @return number of bytes written, < 0 on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_printf"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "strings", :type "const char *[]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/pointer], :symbol "avio_print_string_array", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_print_string_array, :raw-comment "/**\n * Write a NULL terminated array of strings to the context.\n * Usually you don't need to use this function directly but its macro wrapper,\n * avio_print.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_print_string_array"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_flush", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_flush, :raw-comment "/**\n * Force flushing of buffered data.\n *\n * For write streams, force the buffered data to be immediately written to the output,\n * without to wait to fill the internal buffer.\n *\n * For read streams, discard all currently buffered data, and advance the\n * reported file position to that of the underlying stream. This does not\n * read new data, and does not perform any seeks.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_flush"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "buf", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_read", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_read, :raw-comment "/**\n * Read size bytes from AVIOContext into buf.\n * @return number of bytes read or AVERROR\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_read"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "buf", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_read_partial", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_read_partial, :raw-comment "/**\n * Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed\n * to read fewer bytes than requested. The missing bytes can be read in the next\n * call. This always tries to read at least 1 byte.\n * Useful to reduce latency in certain cases.\n * @return number of bytes read or AVERROR\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_read_partial"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_r8", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_r8, :raw-comment "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_r8"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rl16", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rl16, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rl16"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rl24", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rl24, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rl24"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rl32", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rl32, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rl32"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rl64", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rl64, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rl64"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rb16", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rb16, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rb16"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rb24", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rb24, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rb24"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rb32", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rb32, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rb32"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "unsigned long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_rb64", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_rb64, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_rb64"} {:args [{:spelling "pb", :type "struct AVIOContext *"} {:spelling "maxlen", :type "int"} {:spelling "buf", :type "char *"} {:spelling "buflen", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_get_str", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_get_str, :raw-comment "/**\n * Read a string from pb into buf. The reading will terminate when either\n * a NULL character was encountered, maxlen bytes have been read, or nothing\n * more can be read from pb. The result is guaranteed to be NULL-terminated, it\n * will be truncated if buf is too small.\n * Note that the string is not interpreted or validated in any way, it\n * might get truncated in the middle of a sequence for multi-byte encodings.\n *\n * @return number of bytes read (is always <= maxlen).\n * If reading ends on EOF or error, the return value will be one more than\n * bytes actually read.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_get_str"} {:args [{:spelling "pb", :type "struct AVIOContext *"} {:spelling "maxlen", :type "int"} {:spelling "buf", :type "char *"} {:spelling "buflen", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_get_str16le", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_get_str16le, :raw-comment "/**\n * Read a UTF-16 string from pb and convert it to UTF-8.\n * The reading will terminate when either a null or invalid character was\n * encountered or maxlen bytes have been read.\n * @return number of bytes read (is always <= maxlen)\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_get_str16le"} {:args [{:spelling "pb", :type "struct AVIOContext *"} {:spelling "maxlen", :type "int"} {:spelling "buf", :type "char *"} {:spelling "buflen", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_get_str16be", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_get_str16be, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avio_get_str16be"} {:args [{:spelling "s", :type "struct AVIOContext **"} {:spelling "url", :type "const char *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avio_open", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_open, :raw-comment "/**\n * Create and initialize a AVIOContext for accessing the\n * resource indicated by url.\n * @note When the resource indicated by url has been opened in\n * read+write mode, the AVIOContext can be used only for writing.\n *\n * @param s Used to return the pointer to the created AVIOContext.\n * In case of failure the pointed to value is set to NULL.\n * @param url resource to access\n * @param flags flags which control how the resource indicated by url\n * is to be opened\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_open"} {:args [{:spelling "s", :type "struct AVIOContext **"} {:spelling "url", :type "const char *"} {:spelling "flags", :type "int"} {:spelling "int_cb", :type "const struct AVIOInterruptCB *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVIOInterruptCB] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avio_open2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_open2, :raw-comment "/**\n * Create and initialize a AVIOContext for accessing the\n * resource indicated by url.\n * @note When the resource indicated by url has been opened in\n * read+write mode, the AVIOContext can be used only for writing.\n *\n * @param s Used to return the pointer to the created AVIOContext.\n * In case of failure the pointed to value is set to NULL.\n * @param url resource to access\n * @param flags flags which control how the resource indicated by url\n * is to be opened\n * @param int_cb an interrupt callback to be used at the protocols level\n * @param options  A dictionary filled with protocol-private options. On return\n * this parameter will be destroyed and replaced with a dict containing options\n * that were not found. May be NULL.\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_open2"} {:args [{:spelling "s", :type "struct AVIOContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_close", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_close, :raw-comment "/**\n * Close the resource accessed by the AVIOContext s and free it.\n * This function can only be used if s was opened by avio_open().\n *\n * The internal buffer is automatically flushed before closing the\n * resource.\n *\n * @return 0 on success, an AVERROR < 0 on error.\n * @see avio_closep\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_close"} {:args [{:spelling "s", :type "struct AVIOContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]]], :symbol "avio_closep", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_closep, :raw-comment "/**\n * Close the resource accessed by the AVIOContext *s, free it\n * and set the pointer pointing to it to NULL.\n * This function can only be used if s was opened by avio_open().\n *\n * The internal buffer is automatically flushed before closing the\n * resource.\n *\n * @return 0 on success, an AVERROR < 0 on error.\n * @see avio_close\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_closep"} {:args [{:spelling "s", :type "struct AVIOContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]]], :symbol "avio_open_dyn_buf", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_open_dyn_buf, :raw-comment "/**\n * Open a write only memory stream.\n *\n * @param s new IO context\n * @return zero if no error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_open_dyn_buf"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "pbuffer", :type "unsigned char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "avio_get_dyn_buf", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_get_dyn_buf, :raw-comment "/**\n * Return the written size and a pointer to the buffer.\n * The AVIOContext stream is left intact.\n * The buffer must NOT be freed.\n * No padding is added to the buffer.\n *\n * @param s IO context\n * @param pbuffer pointer to a byte buffer\n * @return the length of the byte buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_get_dyn_buf"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "pbuffer", :type "unsigned char **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]]], :symbol "avio_close_dyn_buf", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_close_dyn_buf, :raw-comment "/**\n * Return the written size and a pointer to the buffer. The buffer\n * must be freed with av_free().\n * Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.\n *\n * @param s IO context\n * @param pbuffer pointer to a byte buffer\n * @return the length of the byte buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_close_dyn_buf"} {:args [{:spelling "opaque", :type "void **"} {:spelling "output", :type "int"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :symbol "avio_enum_protocols", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_enum_protocols, :raw-comment "/**\n * Iterate through names of available protocols.\n *\n * @param opaque A private pointer representing current protocol.\n *        It must be a pointer to NULL on first iteration and will\n *        be updated by successive calls to avio_enum_protocols.\n * @param output If set to 1, iterate over output protocols,\n *               otherwise over input protocols.\n *\n * @return A static string containing the name of current protocol or NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_enum_protocols"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "const struct AVClass *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avio_protocol_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_protocol_get_class, :raw-comment "/**\n * Get AVClass by names of available protocols.\n *\n * @return A AVClass of input protocol name or NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_protocol_get_class"} {:args [{:spelling "h", :type "struct AVIOContext *"} {:spelling "pause", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int], :symbol "avio_pause", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_pause, :raw-comment "/**\n * Pause and resume playing - only meaningful if using a network streaming\n * protocol (e.g. MMS).\n *\n * @param h     IO context from which to call the read_pause function pointer\n * @param pause 1 for pause, 0 for resume\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_pause"} {:args [{:spelling "h", :type "struct AVIOContext *"} {:spelling "stream_index", :type "int"} {:spelling "timestamp", :type "long long"} {:spelling "flags", :type "int"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] :coffi.mem/int :coffi.mem/long :coffi.mem/int], :symbol "avio_seek_time", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_seek_time, :raw-comment "/**\n * Seek to a given timestamp relative to some component stream.\n * Only meaningful if using a network streaming protocol (e.g. MMS.).\n *\n * @param h IO context from which to call the seek function pointers\n * @param stream_index The stream index that the timestamp is relative to.\n *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE\n *        units from the beginning of the presentation.\n *        If a stream_index >= 0 is used and the protocol does not support\n *        seeking based on component streams, the call will fail.\n * @param timestamp timestamp in AVStream.time_base units\n *        or if there is no stream specified then in AV_TIME_BASE units.\n * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE\n *        and AVSEEK_FLAG_ANY. The protocol may silently ignore\n *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will\n *        fail if used and not supported.\n * @return >= 0 on success\n * @see AVInputFormat::read_seek\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_seek_time"} {:args [{:spelling "h", :type "struct AVIOContext *"} {:spelling "pb", :type "struct AVBPrint *"} {:spelling "max_size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :clong/AVBPrint] :coffi.mem/long], :symbol "avio_read_to_bprint", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_read_to_bprint, :raw-comment "/**\n * Read contents of h into print buffer, up to max_size bytes, or up to EOF.\n *\n * @return 0 for success (max_size bytes read or EOF reached), negative error\n * code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_read_to_bprint"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "c", :type "struct AVIOContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]]], :symbol "avio_accept", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_accept, :raw-comment "/**\n * Accept and allocate a client context on a server context.\n * @param  s the server context\n * @param  c the client context, must be unallocated\n * @return   >= 0 on success or a negative value corresponding\n *           to an AVERROR on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_accept"} {:args [{:spelling "c", :type "struct AVIOContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext]], :symbol "avio_handshake", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avio_handshake, :raw-comment "/**\n * Perform one step of the protocol handshake to accept a new client.\n * This function must be called on a client returned by avio_accept() before\n * using it as a read/write context.\n * It is separate from avio_accept() because it may block.\n * A step of the handshake is defined by places where the application may\n * decide to change the proceedings.\n * For example, on a protocol with a request header and a reply header, each\n * one can constitute a step because the application may use the parameters\n * from the request to change parameters in the reply; or each individual\n * chunk of the request can constitute a step.\n * If the handshake is already finished, avio_handshake() does nothing and\n * returns 0 immediately.\n *\n * @param  c the client context to perform the handshake on\n * @return   0   on a complete and successful handshake\n *           > 0 if the handshake progressed, but is not complete\n *           < 0 for an AVERROR code\n */", :kind "CXCursor_FunctionDecl", :spelling "avio_handshake"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "enum AVHWDeviceType"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_hwdevice_find_type_by_name", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_find_type_by_name, :raw-comment "/**\n * Look up an AVHWDeviceType by name.\n *\n * @param name String name of the device type (case-insensitive).\n * @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if\n *         not found.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_find_type_by_name"} {:args [{:spelling "type", :type "enum AVHWDeviceType"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_hwdevice_get_type_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_get_type_name, :raw-comment "/** Get the string name of an AVHWDeviceType.\n *\n * @param type Type from enum AVHWDeviceType.\n * @return Pointer to a static string containing the name, or NULL if the type\n *         is not valid.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_get_type_name"} {:args [{:spelling "prev", :type "enum AVHWDeviceType"}], :ret {:spelling "enum AVHWDeviceType"}, :function/args [:coffi.mem/int], :symbol "av_hwdevice_iterate_types", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_iterate_types, :raw-comment "/**\n * Iterate over supported device types.\n *\n * @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type\n *             returned by this function in subsequent iterations.\n * @return The next usable device type from enum AVHWDeviceType, or\n *         AV_HWDEVICE_TYPE_NONE if there are no more.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_iterate_types"} {:args [{:spelling "type", :type "enum AVHWDeviceType"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [:coffi.mem/int], :symbol "av_hwdevice_ctx_alloc", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_ctx_alloc, :raw-comment "/**\n * Allocate an AVHWDeviceContext for a given hardware type.\n *\n * @param type the type of the hardware device to allocate.\n * @return a reference to the newly created AVHWDeviceContext on success or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_ctx_alloc"} {:args [{:spelling "ref", :type "struct AVBufferRef *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_hwdevice_ctx_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_ctx_init, :raw-comment "/**\n * Finalize the device context before use. This function must be called after\n * the context is filled with all the required information and before it is\n * used in any way.\n *\n * @param ref a reference to the AVHWDeviceContext\n * @return 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_ctx_init"} {:args [{:spelling "device_ctx", :type "struct AVBufferRef **"} {:spelling "type", :type "enum AVHWDeviceType"} {:spelling "device", :type "const char *"} {:spelling "opts", :type "struct AVDictionary *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVDictionary] :coffi.mem/int], :symbol "av_hwdevice_ctx_create", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_ctx_create, :raw-comment "/**\n * Open a device of the specified type and create an AVHWDeviceContext for it.\n *\n * This is a convenience function intended to cover the simple cases. Callers\n * who need to fine-tune device creation/management should open the device\n * manually and then wrap it in an AVHWDeviceContext using\n * av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().\n *\n * The returned context is already initialized and ready for use, the caller\n * should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of\n * the created AVHWDeviceContext are set by this function and should not be\n * touched by the caller.\n *\n * @param device_ctx On success, a reference to the newly-created device context\n *                   will be written here. The reference is owned by the caller\n *                   and must be released with av_buffer_unref() when no longer\n *                   needed. On failure, NULL will be written to this pointer.\n * @param type The type of the device to create.\n * @param device A type-specific string identifying the device to open.\n * @param opts A dictionary of additional (type-specific) options to use in\n *             opening the device. The dictionary remains owned by the caller.\n * @param flags currently unused\n *\n * @return 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_ctx_create"} {:args [{:spelling "dst_ctx", :type "struct AVBufferRef **"} {:spelling "type", :type "enum AVHWDeviceType"} {:spelling "src_ctx", :type "struct AVBufferRef *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int [:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/int], :symbol "av_hwdevice_ctx_create_derived", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_ctx_create_derived, :raw-comment "/**\n * Create a new device of the specified type from an existing device.\n *\n * If the source device is a device of the target type or was originally\n * derived from such a device (possibly through one or more intermediate\n * devices of other types), then this will return a reference to the\n * existing device of the same type as is requested.\n *\n * Otherwise, it will attempt to derive a new device from the given source\n * device.  If direct derivation to the new type is not implemented, it will\n * attempt the same derivation from each ancestor of the source device in\n * turn looking for an implemented derivation method.\n *\n * @param dst_ctx On success, a reference to the newly-created\n *                AVHWDeviceContext.\n * @param type    The type of the new device to create.\n * @param src_ctx A reference to an existing AVHWDeviceContext which will be\n *                used to create the new device.\n * @param flags   Currently unused; should be set to zero.\n * @return        Zero on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_ctx_create_derived"} {:args [{:spelling "dst_ctx", :type "struct AVBufferRef **"} {:spelling "type", :type "enum AVHWDeviceType"} {:spelling "src_ctx", :type "struct AVBufferRef *"} {:spelling "options", :type "struct AVDictionary *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int [:coffi.mem/pointer :clong/AVBufferRef] [:coffi.mem/pointer :clong/AVDictionary] :coffi.mem/int], :symbol "av_hwdevice_ctx_create_derived_opts", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_ctx_create_derived_opts, :raw-comment "/**\n * Create a new device of the specified type from an existing device.\n *\n * This function performs the same action as av_hwdevice_ctx_create_derived,\n * however, it is able to set options for the new device to be derived.\n *\n * @param dst_ctx On success, a reference to the newly-created\n *                AVHWDeviceContext.\n * @param type    The type of the new device to create.\n * @param src_ctx A reference to an existing AVHWDeviceContext which will be\n *                used to create the new device.\n * @param options Options for the new device to create, same format as in\n *                av_hwdevice_ctx_create.\n * @param flags   Currently unused; should be set to zero.\n * @return        Zero on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_ctx_create_derived_opts"} {:args [{:spelling "device_ctx", :type "struct AVBufferRef *"}], :ret {:spelling "struct AVBufferRef *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_hwframe_ctx_alloc", :function/ret [:coffi.mem/pointer :clong/AVBufferRef], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_ctx_alloc, :raw-comment "/**\n * Allocate an AVHWFramesContext tied to a given device context.\n *\n * @param device_ctx a reference to a AVHWDeviceContext. This function will make\n *                   a new reference for internal use, the one passed to the\n *                   function remains owned by the caller.\n * @return a reference to the newly created AVHWFramesContext on success or NULL\n *         on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_ctx_alloc"} {:args [{:spelling "ref", :type "struct AVBufferRef *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_hwframe_ctx_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_ctx_init, :raw-comment "/**\n * Finalize the context before use. This function must be called after the\n * context is filled with all the required information and before it is attached\n * to any frames.\n *\n * @param ref a reference to the AVHWFramesContext\n * @return 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_ctx_init"} {:args [{:spelling "hwframe_ctx", :type "struct AVBufferRef *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_hwframe_get_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_get_buffer, :raw-comment "/**\n * Allocate a new frame attached to the given AVHWFramesContext.\n *\n * @param hwframe_ctx a reference to an AVHWFramesContext\n * @param frame an empty (freshly allocated or unreffed) frame to be filled with\n *              newly allocated buffers.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_get_buffer"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "const struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_hwframe_transfer_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_transfer_data, :raw-comment "/**\n * Copy data to or from a hw surface. At least one of dst/src must have an\n * AVHWFramesContext attached.\n *\n * If src has an AVHWFramesContext attached, then the format of dst (if set)\n * must use one of the formats returned by av_hwframe_transfer_get_formats(src,\n * AV_HWFRAME_TRANSFER_DIRECTION_FROM).\n * If dst has an AVHWFramesContext attached, then the format of src must use one\n * of the formats returned by av_hwframe_transfer_get_formats(dst,\n * AV_HWFRAME_TRANSFER_DIRECTION_TO)\n *\n * dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the\n * data buffers will be allocated by this function using av_frame_get_buffer().\n * If dst->format is set, then this format will be used, otherwise (when\n * dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.\n *\n * The two frames must have matching allocated dimensions (i.e. equal to\n * AVHWFramesContext.width/height), since not all device types support\n * transferring a sub-rectangle of the whole surface. The display dimensions\n * (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but\n * also have to be equal for both frames. When the display dimensions are\n * smaller than the allocated dimensions, the content of the padding in the\n * destination frame is unspecified.\n *\n * @param dst the destination frame. dst is not touched on failure.\n * @param src the source frame.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR error code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_transfer_data"} {:args [{:spelling "hwframe_ctx", :type "struct AVBufferRef *"} {:spelling "dir", :type "enum AVHWFrameTransferDirection"} {:spelling "formats", :type "enum AVPixelFormat **"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]] :coffi.mem/int], :symbol "av_hwframe_transfer_get_formats", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_transfer_get_formats, :raw-comment "/**\n * Get a list of possible source or target formats usable in\n * av_hwframe_transfer_data().\n *\n * @param hwframe_ctx the frame context to obtain the information for\n * @param dir the direction of the transfer\n * @param formats the pointer to the output format list will be written here.\n *                The list is terminated with AV_PIX_FMT_NONE and must be freed\n *                by the caller when no longer needed using av_free().\n *                If this function returns successfully, the format list will\n *                have at least one item (not counting the terminator).\n *                On failure, the contents of this pointer are unspecified.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_transfer_get_formats"} {:args [{:spelling "device_ctx", :type "struct AVBufferRef *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef]], :symbol "av_hwdevice_hwconfig_alloc", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_hwconfig_alloc, :raw-comment "/**\n * Allocate a HW-specific configuration structure for a given HW device.\n * After use, the user must free all members as required by the specific\n * hardware structure being used, then free the structure itself with\n * av_free().\n *\n * @param device_ctx a reference to the associated AVHWDeviceContext.\n * @return The newly created HW-specific configuration structure on\n *         success or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_hwconfig_alloc"} {:args [{:spelling "ref", :type "struct AVBufferRef *"} {:spelling "hwconfig", :type "const void *"}], :ret {:spelling "struct AVHWFramesConstraints *"}, :function/args [[:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/pointer], :symbol "av_hwdevice_get_hwframe_constraints", :function/ret [:coffi.mem/pointer :clong/AVHWFramesConstraints], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwdevice_get_hwframe_constraints, :raw-comment "/**\n * Get the constraints on HW frames given a device and the HW-specific\n * configuration to be used with that device.  If no HW-specific\n * configuration is provided, returns the maximum possible capabilities\n * of the device.\n *\n * @param ref a reference to the associated AVHWDeviceContext.\n * @param hwconfig a filled HW-specific configuration structure, or NULL\n *        to return the maximum possible capabilities of the device.\n * @return AVHWFramesConstraints structure describing the constraints\n *         on the device, or NULL if not available.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwdevice_get_hwframe_constraints"} {:args [{:spelling "constraints", :type "struct AVHWFramesConstraints **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVHWFramesConstraints]]], :symbol "av_hwframe_constraints_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_constraints_free, :raw-comment "/**\n * Free an AVHWFrameConstraints structure.\n *\n * @param constraints The (filled or unfilled) AVHWFrameConstraints structure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_constraints_free"} {:args [{:spelling "dst", :type "struct AVFrame *"} {:spelling "src", :type "const struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "av_hwframe_map", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_map, :raw-comment "/**\n * Map a hardware frame.\n *\n * This has a number of different possible effects, depending on the format\n * and origin of the src and dst frames.  On input, src should be a usable\n * frame with valid buffers and dst should be blank (typically as just created\n * by av_frame_alloc()).  src should have an associated hwframe context, and\n * dst may optionally have a format and associated hwframe context.\n *\n * If src was created by mapping a frame from the hwframe context of dst,\n * then this function undoes the mapping - dst is replaced by a reference to\n * the frame that src was originally mapped from.\n *\n * If both src and dst have an associated hwframe context, then this function\n * attempts to map the src frame from its hardware context to that of dst and\n * then fill dst with appropriate data to be usable there.  This will only be\n * possible if the hwframe contexts and associated devices are compatible -\n * given compatible devices, av_hwframe_ctx_create_derived() can be used to\n * create a hwframe context for dst in which mapping should be possible.\n *\n * If src has a hwframe context but dst does not, then the src frame is\n * mapped to normal memory and should thereafter be usable as a normal frame.\n * If the format is set on dst, then the mapping will attempt to create dst\n * with that format and fail if it is not possible.  If format is unset (is\n * AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate\n * format to use is (probably the sw_format of the src hwframe context).\n *\n * A return value of AVERROR(ENOSYS) indicates that the mapping is not\n * possible with the given arguments and hwframe setup, while other return\n * values indicate that it failed somehow.\n *\n * @param dst Destination frame, to contain the mapping.\n * @param src Source frame, to be mapped.\n * @param flags Some combination of AV_HWFRAME_MAP_* flags.\n * @return Zero on success, negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_map"} {:args [{:spelling "derived_frame_ctx", :type "struct AVBufferRef **"} {:spelling "format", :type "enum AVPixelFormat"} {:spelling "derived_device_ctx", :type "struct AVBufferRef *"} {:spelling "source_frame_ctx", :type "struct AVBufferRef *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int [:coffi.mem/pointer :clong/AVBufferRef] [:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/int], :symbol "av_hwframe_ctx_create_derived", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwframe_ctx_create_derived, :raw-comment "/**\n * Create and initialise an AVHWFramesContext as a mapping of another existing\n * AVHWFramesContext on a different device.\n *\n * av_hwframe_ctx_init() should not be called after this.\n *\n * @param derived_frame_ctx  On success, a reference to the newly created\n *                           AVHWFramesContext.\n * @param derived_device_ctx A reference to the device to create the new\n *                           AVHWFramesContext on.\n * @param source_frame_ctx   A reference to an existing AVHWFramesContext\n *                           which will be mapped to the derived context.\n * @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the\n *               mapping parameters to apply to frames which are allocated\n *               in the derived device.\n * @return       Zero on success, negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwframe_ctx_create_derived"} {:args [{:spelling "codec_id", :type "enum AVCodecID"}], :ret {:spelling "enum AVMediaType"}, :function/args [:coffi.mem/int], :symbol "avcodec_get_type", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_type, :raw-comment "/**\n * Get the type of the given codec.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_type"} {:args [{:spelling "id", :type "enum AVCodecID"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "avcodec_get_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_name, :raw-comment "/**\n * Get the name of a codec.\n * @return  a static string identifying the codec; never NULL\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_name"} {:args [], :ret {:spelling "struct AVCodecParameters *"}, :function/args [], :symbol "avcodec_parameters_alloc", :function/ret [:coffi.mem/pointer :clong/AVCodecParameters], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_parameters_alloc, :raw-comment "/**\n * Allocate a new AVCodecParameters and set its fields to default values\n * (unknown/invalid/0). The returned struct must be freed with\n * avcodec_parameters_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_parameters_alloc"} {:args [{:spelling "par", :type "struct AVCodecParameters **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecParameters]]], :symbol "avcodec_parameters_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_parameters_free, :raw-comment "/**\n * Free an AVCodecParameters instance and everything associated with it and\n * write NULL to the supplied pointer.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_parameters_free"} {:args [{:spelling "dst", :type "struct AVCodecParameters *"} {:spelling "src", :type "const struct AVCodecParameters *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParameters] [:coffi.mem/pointer :clong/AVCodecParameters]], :symbol "avcodec_parameters_copy", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_parameters_copy, :raw-comment "/**\n * Copy the contents of src to dst. Any allocated fields in dst are freed and\n * replaced with newly allocated duplicates of the corresponding fields in src.\n *\n * @return >= 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_parameters_copy"} {:args [], :ret {:spelling "struct AVPacket *"}, :function/args [], :symbol "av_packet_alloc", :function/ret [:coffi.mem/pointer :clong/AVPacket], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_alloc, :raw-comment "/**\n * Allocate an AVPacket and set its fields to default values.  The resulting\n * struct must be freed using av_packet_free().\n *\n * @return An AVPacket filled with default values or NULL on failure.\n *\n * @note this only allocates the AVPacket itself, not the data buffers. Those\n * must be allocated through other means such as av_new_packet.\n *\n * @see av_new_packet\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_alloc"} {:args [{:spelling "src", :type "const struct AVPacket *"}], :ret {:spelling "struct AVPacket *"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_clone", :function/ret [:coffi.mem/pointer :clong/AVPacket], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_clone, :raw-comment "/**\n * Create a new packet that references the same data as src.\n *\n * This is a shortcut for av_packet_alloc()+av_packet_ref().\n *\n * @return newly created AVPacket on success, NULL on error.\n *\n * @see av_packet_alloc\n * @see av_packet_ref\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_clone"} {:args [{:spelling "pkt", :type "struct AVPacket **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVPacket]]], :symbol "av_packet_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_free, :raw-comment "/**\n * Free the packet, if the packet is reference counted, it will be\n * unreferenced first.\n *\n * @param pkt packet to be freed. The pointer will be set to NULL.\n * @note passing NULL is a no-op.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_free"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_init_packet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_init_packet, :raw-comment "/**\n * Initialize optional fields of a packet with default values.\n *\n * Note, this does not touch the data and size members, which have to be\n * initialized separately.\n *\n * @param pkt packet\n *\n * @see av_packet_alloc\n * @see av_packet_unref\n *\n * @deprecated This function is deprecated. Once it's removed,\n               sizeof(AVPacket) will not be a part of the ABI anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_init_packet"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "av_new_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_new_packet, :raw-comment "/**\n * Allocate the payload of a packet and initialize its fields with\n * default values.\n *\n * @param pkt packet\n * @param size wanted payload size\n * @return 0 if OK, AVERROR_xxx otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_new_packet"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "av_shrink_packet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_shrink_packet, :raw-comment "/**\n * Reduce packet size, correctly zeroing padding\n *\n * @param pkt packet\n * @param size new size\n */", :kind "CXCursor_FunctionDecl", :spelling "av_shrink_packet"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "grow_by", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "av_grow_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_grow_packet, :raw-comment "/**\n * Increase packet size, correctly zeroing padding\n *\n * @param pkt packet\n * @param grow_by number of bytes by which to increase the size of the packet\n */", :kind "CXCursor_FunctionDecl", :spelling "av_grow_packet"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "data", :type "unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_packet_from_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_from_data, :raw-comment "/**\n * Initialize a reference-counted packet from av_malloc()ed data.\n *\n * @param pkt packet to be initialized. This function will set the data, size,\n *        and buf fields, all others are left untouched.\n * @param data Data allocated by av_malloc() to be used as packet data. If this\n *        function returns successfully, the data is owned by the underlying AVBuffer.\n *        The caller may not access the data through other means.\n * @param size size of data in bytes, without the padding. I.e. the full buffer\n *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.\n *\n * @return 0 on success, a negative AVERROR on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_from_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_dup_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dup_packet, :raw-comment "/**\n * @warning This is a hack - the packet memory allocation stuff is broken. The\n * packet is allocated if it was not really allocated.\n *\n * @deprecated Use av_packet_ref or av_packet_make_refcounted\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dup_packet"} {:args [{:spelling "dst", :type "struct AVPacket *"} {:spelling "src", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_copy_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_copy_packet, :raw-comment "/**\n * Copy packet, including contents\n *\n * @return 0 on success, negative AVERROR on fail\n *\n * @deprecated Use av_packet_ref\n */", :kind "CXCursor_FunctionDecl", :spelling "av_copy_packet"} {:args [{:spelling "dst", :type "struct AVPacket *"} {:spelling "src", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_copy_packet_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_copy_packet_side_data, :raw-comment "/**\n * Copy packet side data\n *\n * @return 0 on success, negative AVERROR on fail\n *\n * @deprecated Use av_packet_copy_props\n */", :kind "CXCursor_FunctionDecl", :spelling "av_copy_packet_side_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_free_packet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_free_packet, :raw-comment "/**\n * Free a packet.\n *\n * @deprecated Use av_packet_unref\n *\n * @param pkt packet to free\n */", :kind "CXCursor_FunctionDecl", :spelling "av_free_packet"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "size", :type "int"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int :coffi.mem/int], :symbol "av_packet_new_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_new_side_data, :raw-comment "/**\n * Allocate new information of a packet.\n *\n * @param pkt packet\n * @param type side information type\n * @param size side information size\n * @return pointer to fresh allocated data or NULL otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_new_side_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "data", :type "unsigned char *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_packet_add_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_add_side_data, :raw-comment "/**\n * Wrap an existing array as a packet side data.\n *\n * @param pkt packet\n * @param type side information type\n * @param data the side data array. It must be allocated with the av_malloc()\n *             family of functions. The ownership of the data is transferred to\n *             pkt.\n * @param size side information size\n * @return a non-negative number on success, a negative AVERROR code on\n *         failure. On failure, the packet is unchanged and the data remains\n *         owned by the caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_add_side_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int :coffi.mem/int], :symbol "av_packet_shrink_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_shrink_side_data, :raw-comment "/**\n * Shrink the already allocated side data buffer\n *\n * @param pkt packet\n * @param type side information type\n * @param size new side information size\n * @return 0 on success, < 0 on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_shrink_side_data"} {:args [{:spelling "pkt", :type "const struct AVPacket *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "size", :type "int *"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_packet_get_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_get_side_data, :raw-comment "/**\n * Get side information from packet.\n *\n * @param pkt packet\n * @param type desired side information type\n * @param size If supplied, *size will be set to the size of the side data\n *             or to zero if the desired side data is not present.\n * @return pointer to data if present or NULL otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_get_side_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_merge_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_merge_side_data, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_packet_merge_side_data"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_split_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_split_side_data, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_packet_split_side_data"} {:args [{:spelling "type", :type "enum AVPacketSideDataType"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "av_packet_side_data_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_side_data_name, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_packet_side_data_name"} {:args [{:spelling "dict", :type "struct AVDictionary *"} {:spelling "size", :type "int *"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVDictionary] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_packet_pack_dictionary", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_pack_dictionary, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_packet_pack_dictionary"} {:args [{:spelling "data", :type "const unsigned char *"} {:spelling "size", :type "int"} {:spelling "dict", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "av_packet_unpack_dictionary", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_unpack_dictionary, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_packet_unpack_dictionary"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_free_side_data", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_free_side_data, :raw-comment "/**\n * Convenience function to free all the side data stored.\n * All the other fields stay untouched.\n *\n * @param pkt packet\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_free_side_data"} {:args [{:spelling "dst", :type "struct AVPacket *"} {:spelling "src", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_ref", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_ref, :raw-comment "/**\n * Setup a new reference to the data described by a given packet\n *\n * If src is reference-counted, setup dst as a new reference to the\n * buffer in src. Otherwise allocate a new buffer in dst and copy the\n * data from src into it.\n *\n * All the other fields are copied from src.\n *\n * @see av_packet_unref\n *\n * @param dst Destination packet. Will be completely overwritten.\n * @param src Source packet\n *\n * @return 0 on success, a negative AVERROR on error. On error, dst\n *         will be blank (as if returned by av_packet_alloc()).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_ref"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_unref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_unref, :raw-comment "/**\n * Wipe the packet.\n *\n * Unreference the buffer referenced by the packet and reset the\n * remaining packet fields to their default values.\n *\n * @param pkt The packet to be unreferenced.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_unref"} {:args [{:spelling "dst", :type "struct AVPacket *"} {:spelling "src", :type "struct AVPacket *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_move_ref", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_move_ref, :raw-comment "/**\n * Move every field in src to dst and reset src.\n *\n * @see av_packet_unref\n *\n * @param src Source packet, will be reset\n * @param dst Destination packet\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_move_ref"} {:args [{:spelling "dst", :type "struct AVPacket *"} {:spelling "src", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_copy_props", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_copy_props, :raw-comment "/**\n * Copy only \"properties\" fields from src to dst.\n *\n * Properties for the purpose of this function are all the fields\n * beside those related to the packet data (buf, data, size)\n *\n * @param dst Destination packet\n * @param src Source packet\n *\n * @return 0 on success AVERROR on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_copy_props"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_make_refcounted", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_make_refcounted, :raw-comment "/**\n * Ensure the data described by a given packet is reference counted.\n *\n * @note This function does not ensure that the reference will be writable.\n *       Use av_packet_make_writable instead for that purpose.\n *\n * @see av_packet_ref\n * @see av_packet_make_writable\n *\n * @param pkt packet whose data should be made reference counted.\n *\n * @return 0 on success, a negative AVERROR on error. On failure, the\n *         packet is unchanged.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_make_refcounted"} {:args [{:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPacket]], :symbol "av_packet_make_writable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_make_writable, :raw-comment "/**\n * Create a writable reference for the data described by a given packet,\n * avoiding data copy if possible.\n *\n * @param pkt Packet whose data should be made writable.\n *\n * @return 0 on success, a negative AVERROR on failure. On failure, the\n *         packet is unchanged.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_make_writable"} {:args [{:spelling "pkt", :type "struct AVPacket *"} {:spelling "tb_src", :type "struct AVRational"} {:spelling "tb_dst", :type "struct AVRational"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPacket] :clong/AVRational :clong/AVRational], :symbol "av_packet_rescale_ts", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_packet_rescale_ts, :raw-comment "/**\n * Convert valid timing fields (timestamps / durations) in a packet from one\n * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be\n * ignored.\n *\n * @param pkt packet on which the conversion will be performed\n * @param tb_src source timebase, in which the timing fields in pkt are\n *               expressed\n * @param tb_dst destination timebase, to which the timing fields will be\n *               converted\n */", :kind "CXCursor_FunctionDecl", :spelling "av_packet_rescale_ts"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "const struct AVBitStreamFilter *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_bsf_get_by_name", :function/ret [:coffi.mem/pointer :clong/AVBitStreamFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_get_by_name, :raw-comment "/**\n * @return a bitstream filter with the specified name or NULL if no such\n *         bitstream filter exists.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_get_by_name"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVBitStreamFilter *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_bsf_iterate", :function/ret [:coffi.mem/pointer :clong/AVBitStreamFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_iterate, :raw-comment "/**\n * Iterate over all registered bitstream filters.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered bitstream filter or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_iterate"} {:args [{:spelling "filter", :type "const struct AVBitStreamFilter *"} {:spelling "ctx", :type "struct AVBSFContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBitStreamFilter] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFContext]]], :symbol "av_bsf_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_alloc, :raw-comment "/**\n * Allocate a context for a given bitstream filter. The caller must fill in the\n * context parameters as described in the documentation and then call\n * av_bsf_init() before sending any data to the filter.\n *\n * @param filter the filter for which to allocate an instance.\n * @param ctx a pointer into which the pointer to the newly-allocated context\n *            will be written. It must be freed with av_bsf_free() after the\n *            filtering is done.\n *\n * @return 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_alloc"} {:args [{:spelling "ctx", :type "struct AVBSFContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBSFContext]], :symbol "av_bsf_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_init, :raw-comment "/**\n * Prepare the filter for use, after all the parameters and options have been\n * set.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_init"} {:args [{:spelling "ctx", :type "struct AVBSFContext *"} {:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBSFContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_bsf_send_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_send_packet, :raw-comment "/**\n * Submit a packet for filtering.\n *\n * After sending each packet, the filter must be completely drained by calling\n * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or\n * AVERROR_EOF.\n *\n * @param pkt the packet to filter. The bitstream filter will take ownership of\n * the packet and reset the contents of pkt. pkt is not touched if an error occurs.\n * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),\n * it signals the end of the stream (i.e. no more non-empty packets will be sent;\n * sending more empty packets does nothing) and will cause the filter to output\n * any packets it may have buffered internally.\n *\n * @return 0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the\n * filter (using av_bsf_receive_packet()) before new input can be consumed. Another\n * negative AVERROR value if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_send_packet"} {:args [{:spelling "ctx", :type "struct AVBSFContext *"} {:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBSFContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_bsf_receive_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_receive_packet, :raw-comment "/**\n * Retrieve a filtered packet.\n *\n * @param[out] pkt this struct will be filled with the contents of the filtered\n *                 packet. It is owned by the caller and must be freed using\n *                 av_packet_unref() when it is no longer needed.\n *                 This parameter should be \"clean\" (i.e. freshly allocated\n *                 with av_packet_alloc() or unreffed with av_packet_unref())\n *                 when this function is called. If this function returns\n *                 successfully, the contents of pkt will be completely\n *                 overwritten by the returned data. On failure, pkt is not\n *                 touched.\n *\n * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the\n * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there\n * will be no further output from the filter. Another negative AVERROR value if\n * an error occurs.\n *\n * @note one input packet may result in several output packets, so after sending\n * a packet with av_bsf_send_packet(), this function needs to be called\n * repeatedly until it stops returning 0. It is also possible for a filter to\n * output fewer packets than were sent to it, so this function may return\n * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_receive_packet"} {:args [{:spelling "ctx", :type "struct AVBSFContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBSFContext]], :symbol "av_bsf_flush", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_flush, :raw-comment "/**\n * Reset the internal bitstream filter state. Should be called e.g. when seeking.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_flush"} {:args [{:spelling "ctx", :type "struct AVBSFContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFContext]]], :symbol "av_bsf_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_free, :raw-comment "/**\n * Free a bitstream filter context and everything associated with it; write NULL\n * into the supplied pointer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_free"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "av_bsf_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_get_class, :raw-comment "/**\n * Get the AVClass for AVBSFContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_get_class"} {:args [], :ret {:spelling "struct AVBSFList *"}, :function/args [], :symbol "av_bsf_list_alloc", :function/ret [:coffi.mem/pointer :clong/AVBSFList], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_alloc, :raw-comment "/**\n * Allocate empty list of bitstream filters.\n * The list must be later freed by av_bsf_list_free()\n * or finalized by av_bsf_list_finalize().\n *\n * @return Pointer to @ref AVBSFList on success, NULL in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_alloc"} {:args [{:spelling "lst", :type "struct AVBSFList **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFList]]], :symbol "av_bsf_list_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_free, :raw-comment "/**\n * Free list of bitstream filters.\n *\n * @param lst Pointer to pointer returned by av_bsf_list_alloc()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_free"} {:args [{:spelling "lst", :type "struct AVBSFList *"} {:spelling "bsf", :type "struct AVBSFContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBSFList] [:coffi.mem/pointer :clong/AVBSFContext]], :symbol "av_bsf_list_append", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_append, :raw-comment "/**\n * Append bitstream filter to the list of bitstream filters.\n *\n * @param lst List to append to\n * @param bsf Filter context to be appended\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_append"} {:args [{:spelling "lst", :type "struct AVBSFList *"} {:spelling "bsf_name", :type "const char *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBSFList] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "av_bsf_list_append2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_append2, :raw-comment "/**\n * Construct new bitstream filter context given it's name and options\n * and append it to the list of bitstream filters.\n *\n * @param lst      List to append to\n * @param bsf_name Name of the bitstream filter\n * @param options  Options for the bitstream filter, can be set to NULL\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_append2"} {:args [{:spelling "lst", :type "struct AVBSFList **"} {:spelling "bsf", :type "struct AVBSFContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFList]] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFContext]]], :symbol "av_bsf_list_finalize", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_finalize, :raw-comment "/**\n * Finalize list of bitstream filters.\n *\n * This function will transform @ref AVBSFList to single @ref AVBSFContext,\n * so the whole chain of bitstream filters can be treated as single filter\n * freshly allocated by av_bsf_alloc().\n * If the call is successful, @ref AVBSFList structure is freed and lst\n * will be set to NULL. In case of failure, caller is responsible for\n * freeing the structure by av_bsf_list_free()\n *\n * @param      lst Filter list structure to be transformed\n * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n *                 representing the chain of bitstream filters\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_finalize"} {:args [{:spelling "str", :type "const char *"} {:spelling "bsf", :type "struct AVBSFContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFContext]]], :symbol "av_bsf_list_parse_str", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_list_parse_str, :raw-comment "/**\n * Parse string describing list of bitstream filters and create single\n * @ref AVBSFContext describing the whole chain of bitstream filters.\n * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly\n * allocated by av_bsf_alloc().\n *\n * @param      str String describing chain of bitstream filters in format\n *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`\n * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n *                 representing the chain of bitstream filters\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_list_parse_str"} {:args [{:spelling "bsf", :type "struct AVBSFContext **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBSFContext]]], :symbol "av_bsf_get_null_filter", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_get_null_filter, :raw-comment "/**\n * Get null/pass-through bitstream filter.\n *\n * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter\n *\n * @return\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bsf_get_null_filter"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVCodec *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_codec_iterate", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_iterate, :raw-comment "/**\n * Iterate over all registered codecs.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered codec or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_iterate"} {:args [{:spelling "id", :type "enum AVCodecID"}], :ret {:spelling "struct AVCodec *"}, :function/args [:coffi.mem/int], :symbol "avcodec_find_decoder", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_decoder, :raw-comment "/**\n * Find a registered decoder with a matching codec ID.\n *\n * @param id AVCodecID of the requested decoder\n * @return A decoder if one was found, NULL otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_decoder"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avcodec_find_decoder_by_name", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_decoder_by_name, :raw-comment "/**\n * Find a registered decoder with the specified name.\n *\n * @param name name of the requested decoder\n * @return A decoder if one was found, NULL otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_decoder_by_name"} {:args [{:spelling "id", :type "enum AVCodecID"}], :ret {:spelling "struct AVCodec *"}, :function/args [:coffi.mem/int], :symbol "avcodec_find_encoder", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_encoder, :raw-comment "/**\n * Find a registered encoder with a matching codec ID.\n *\n * @param id AVCodecID of the requested encoder\n * @return An encoder if one was found, NULL otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_encoder"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avcodec_find_encoder_by_name", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_encoder_by_name, :raw-comment "/**\n * Find a registered encoder with the specified name.\n *\n * @param name name of the requested encoder\n * @return An encoder if one was found, NULL otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_encoder_by_name"} {:args [{:spelling "codec", :type "const struct AVCodec *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "av_codec_is_encoder", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_is_encoder, :raw-comment "/**\n * @return a non-zero number if codec is an encoder, zero otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_is_encoder"} {:args [{:spelling "codec", :type "const struct AVCodec *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "av_codec_is_decoder", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_is_decoder, :raw-comment "/**\n * @return a non-zero number if codec is a decoder, zero otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_is_decoder"} {:args [{:spelling "codec", :type "const struct AVCodec *"} {:spelling "index", :type "int"}], :ret {:spelling "const struct AVCodecHWConfig *"}, :function/args [[:coffi.mem/pointer :clong/AVCodec] :coffi.mem/int], :symbol "avcodec_get_hw_config", :function/ret [:coffi.mem/pointer :clong/AVCodecHWConfig], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_hw_config, :raw-comment "/**\n * Retrieve supported hardware configurations for a codec.\n *\n * Values of index from zero to some maximum return the indexed configuration\n * descriptor; all other values return NULL.  If the codec does not support\n * any hardware configurations then it will always return NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_hw_config"} {:args [{:spelling "id", :type "enum AVCodecID"}], :ret {:spelling "const struct AVCodecDescriptor *"}, :function/args [:coffi.mem/int], :symbol "avcodec_descriptor_get", :function/ret [:coffi.mem/pointer :clong/AVCodecDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_descriptor_get, :raw-comment "/**\n * @return descriptor for given codec ID or NULL if no descriptor exists.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_descriptor_get"} {:args [{:spelling "prev", :type "const struct AVCodecDescriptor *"}], :ret {:spelling "const struct AVCodecDescriptor *"}, :function/args [[:coffi.mem/pointer :clong/AVCodecDescriptor]], :symbol "avcodec_descriptor_next", :function/ret [:coffi.mem/pointer :clong/AVCodecDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_descriptor_next, :raw-comment "/**\n * Iterate over all codec descriptors known to libavcodec.\n *\n * @param prev previous descriptor. NULL to get the first descriptor.\n *\n * @return next descriptor or NULL after the last descriptor\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_descriptor_next"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "const struct AVCodecDescriptor *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "avcodec_descriptor_get_by_name", :function/ret [:coffi.mem/pointer :clong/AVCodecDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_descriptor_get_by_name, :raw-comment "/**\n * @return codec descriptor with the given name or NULL if no such descriptor\n *         exists.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_descriptor_get_by_name"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_pkt_timebase", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_pkt_timebase, :raw-comment "/**\n * Accessors for some AVCodecContext fields. These used to be provided for ABI\n * compatibility, and do not need to be used anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_pkt_timebase"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "val", :type "struct AVRational"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] :clong/AVRational], :symbol "av_codec_set_pkt_timebase", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_set_pkt_timebase, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_set_pkt_timebase"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "const struct AVCodecDescriptor *"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_codec_descriptor", :function/ret [:coffi.mem/pointer :clong/AVCodecDescriptor], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_codec_descriptor, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_codec_descriptor"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "desc", :type "const struct AVCodecDescriptor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodecDescriptor]], :symbol "av_codec_set_codec_descriptor", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_set_codec_descriptor, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_set_codec_descriptor"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_codec_properties", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_codec_properties, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_codec_properties"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_lowres", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_lowres, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_lowres"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int], :symbol "av_codec_set_lowres", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_set_lowres, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_set_lowres"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_seek_preroll", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_seek_preroll, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_seek_preroll"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "val", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int], :symbol "av_codec_set_seek_preroll", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_set_seek_preroll, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_set_seek_preroll"} {:args [{:spelling "avctx", :type "const struct AVCodecContext *"}], :ret {:spelling "unsigned short *"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_codec_get_chroma_intra_matrix", :function/ret [:coffi.mem/pointer :coffi.mem/short], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_chroma_intra_matrix, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_chroma_intra_matrix"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "val", :type "unsigned short *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/short]], :symbol "av_codec_set_chroma_intra_matrix", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_set_chroma_intra_matrix, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_set_chroma_intra_matrix"} {:args [{:spelling "codec", :type "const struct AVCodec *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "av_codec_get_max_lowres", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_max_lowres, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_max_lowres"} {:args [{:spelling "c", :type "const struct AVCodec *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "av_codec_next", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_next, :raw-comment "/**\n * If c is NULL, returns the first registered codec,\n * if c is non-NULL, returns the next registered codec after c,\n * or NULL if c is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_next"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avcodec_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_version, :raw-comment "/**\n * Return the LIBAVCODEC_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avcodec_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_configuration, :raw-comment "/**\n * Return the libavcodec build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avcodec_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_license, :raw-comment "/**\n * Return the libavcodec license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_license"} {:args [{:spelling "codec", :type "struct AVCodec *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "avcodec_register", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_register, :raw-comment "/**\n * @deprecated Calling this function is unnecessary.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_register"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "avcodec_register_all", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_register_all, :raw-comment "/**\n * @deprecated Calling this function is unnecessary.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_register_all"} {:args [{:spelling "codec", :type "const struct AVCodec *"}], :ret {:spelling "struct AVCodecContext *"}, :function/args [[:coffi.mem/pointer :clong/AVCodec]], :symbol "avcodec_alloc_context3", :function/ret [:coffi.mem/pointer :clong/AVCodecContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_alloc_context3, :raw-comment "/**\n * Allocate an AVCodecContext and set its fields to default values. The\n * resulting struct should be freed with avcodec_free_context().\n *\n * @param codec if non-NULL, allocate private data and initialize defaults\n *              for the given codec. It is illegal to then call avcodec_open2()\n *              with a different codec.\n *              If NULL, then the codec-specific defaults won't be initialized,\n *              which may result in suboptimal default settings (this is\n *              important mainly for encoders, e.g. libx264).\n *\n * @return An AVCodecContext filled with default values or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_alloc_context3"} {:args [{:spelling "avctx", :type "struct AVCodecContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecContext]]], :symbol "avcodec_free_context", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_free_context, :raw-comment "/**\n * Free the codec context and everything associated with it and write NULL to\n * the provided pointer.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_free_context"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "codec", :type "const struct AVCodec *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "avcodec_get_context_defaults3", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_context_defaults3, :raw-comment "/**\n * @deprecated This function should not be used, as closing and opening a codec\n * context multiple time is not supported. A new codec context should be\n * allocated for each new use.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_context_defaults3"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avcodec_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_class, :raw-comment "/**\n * Get the AVClass for AVCodecContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_class"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avcodec_get_frame_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_frame_class, :raw-comment "/**\n * @deprecated This function should not be used.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_frame_class"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avcodec_get_subtitle_rect_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_subtitle_rect_class, :raw-comment "/**\n * Get the AVClass for AVSubtitleRect. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_subtitle_rect_class"} {:args [{:spelling "dest", :type "struct AVCodecContext *"} {:spelling "src", :type "const struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodecContext]], :symbol "avcodec_copy_context", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_copy_context, :raw-comment "/**\n * Copy the settings of the source AVCodecContext into the destination\n * AVCodecContext. The resulting destination codec context will be\n * unopened, i.e. you are required to call avcodec_open2() before you\n * can use this AVCodecContext to decode/encode video/audio data.\n *\n * @param dest target codec context, should be initialized with\n *             avcodec_alloc_context3(NULL), but otherwise uninitialized\n * @param src source codec context\n * @return AVERROR() on error (e.g. memory allocation error), 0 on success\n *\n * @deprecated The semantics of this function are ill-defined and it should not\n * be used. If you need to transfer the stream parameters from one codec context\n * to another, use an intermediate AVCodecParameters instance and the\n * avcodec_parameters_from_context() / avcodec_parameters_to_context()\n * functions.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_copy_context"} {:args [{:spelling "par", :type "struct AVCodecParameters *"} {:spelling "codec", :type "const struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParameters] [:coffi.mem/pointer :clong/AVCodecContext]], :symbol "avcodec_parameters_from_context", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_parameters_from_context, :raw-comment "/**\n * Fill the parameters struct based on the values from the supplied codec\n * context. Any allocated fields in par are freed and replaced with duplicates\n * of the corresponding fields in codec.\n *\n * @return >= 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_parameters_from_context"} {:args [{:spelling "codec", :type "struct AVCodecContext *"} {:spelling "par", :type "const struct AVCodecParameters *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodecParameters]], :symbol "avcodec_parameters_to_context", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_parameters_to_context, :raw-comment "/**\n * Fill the codec context based on the values from the supplied codec\n * parameters. Any allocated fields in codec that have a corresponding field in\n * par are freed and replaced with duplicates of the corresponding field in par.\n * Fields in codec that do not have a counterpart in par are not touched.\n *\n * @return >= 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_parameters_to_context"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "codec", :type "const struct AVCodec *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodec] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avcodec_open2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_open2, :raw-comment "/**\n * Initialize the AVCodecContext to use the given AVCodec. Prior to using this\n * function the context has to be allocated with avcodec_alloc_context3().\n *\n * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),\n * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for\n * retrieving a codec.\n *\n * @warning This function is not thread safe!\n *\n * @note Always call this function before using decoding routines (such as\n * @ref avcodec_receive_frame()).\n *\n * @code\n * av_dict_set(&opts, \"b\", \"2.5M\", 0);\n * codec = avcodec_find_decoder(AV_CODEC_ID_H264);\n * if (!codec)\n *     exit(1);\n *\n * context = avcodec_alloc_context3(codec);\n *\n * if (avcodec_open2(context, codec, opts) < 0)\n *     exit(1);\n * @endcode\n *\n * @param avctx The context to initialize.\n * @param codec The codec to open this context for. If a non-NULL codec has been\n *              previously passed to avcodec_alloc_context3() or\n *              for this context, then this parameter MUST be either NULL or\n *              equal to the previously passed codec.\n * @param options A dictionary filled with AVCodecContext and codec-private options.\n *                On return this object will be filled with options that were not found.\n *\n * @return zero on success, a negative value on error\n * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),\n *      av_dict_set(), av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_open2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "avcodec_close", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_close, :raw-comment "/**\n * Close a given AVCodecContext and free all the data associated with it\n * (but not the AVCodecContext itself).\n *\n * Calling this function on an AVCodecContext that hasn't been opened will free\n * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL\n * codec. Subsequent calls will do nothing.\n *\n * @note Do not use this function. Use avcodec_free_context() to destroy a\n * codec context (either open or closed). Opening and closing a codec context\n * multiple times is not supported anymore -- use multiple codec contexts\n * instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_close"} {:args [{:spelling "sub", :type "struct AVSubtitle *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVSubtitle]], :symbol "avsubtitle_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avsubtitle_free, :raw-comment "/**\n * Free all allocated data in the given subtitle struct.\n *\n * @param sub AVSubtitle to free.\n */", :kind "CXCursor_FunctionDecl", :spelling "avsubtitle_free"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int], :symbol "avcodec_default_get_buffer2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_default_get_buffer2, :raw-comment "/**\n * The default callback for AVCodecContext.get_buffer2(). It is made public so\n * it can be called by custom get_buffer2() implementations for decoders without\n * AV_CODEC_CAP_DR1 set.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_default_get_buffer2"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "pkt", :type "struct AVPacket *"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "avcodec_default_get_encode_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_default_get_encode_buffer, :raw-comment "/**\n * The default callback for AVCodecContext.get_encode_buffer(). It is made public so\n * it can be called by custom get_encode_buffer() implementations for encoders without\n * AV_CODEC_CAP_DR1 set.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_default_get_encode_buffer"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "width", :type "int *"} {:spelling "height", :type "int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_align_dimensions", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_align_dimensions, :raw-comment "/**\n * Modify width and height values so that they will result in a memory\n * buffer that is acceptable for the codec if you do not use any horizontal\n * padding.\n *\n * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_align_dimensions"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "width", :type "int *"} {:spelling "height", :type "int *"} {:spelling "linesize_align", :type "int [8]"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/array :coffi.mem/int 8]], :symbol "avcodec_align_dimensions2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_align_dimensions2, :raw-comment "/**\n * Modify width and height values so that they will result in a memory\n * buffer that is acceptable for the codec if you also ensure that all\n * line sizes are a multiple of the respective linesize_align[i].\n *\n * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_align_dimensions2"} {:args [{:spelling "xpos", :type "int *"} {:spelling "ypos", :type "int *"} {:spelling "pos", :type "enum AVChromaLocation"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "avcodec_enum_to_chroma_pos", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_enum_to_chroma_pos, :raw-comment "/**\n * Converts AVChromaLocation to swscale x/y chroma position.\n *\n * The positions represent the chroma (0,0) position in a coordinates system\n * with luma (0,0) representing the origin and luma(1,1) representing 256,256\n *\n * @param xpos  horizontal chroma sample position\n * @param ypos  vertical   chroma sample position\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_enum_to_chroma_pos"} {:args [{:spelling "xpos", :type "int"} {:spelling "ypos", :type "int"}], :ret {:spelling "enum AVChromaLocation"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "avcodec_chroma_pos_to_enum", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_chroma_pos_to_enum, :raw-comment "/**\n * Converts swscale x/y chroma position to AVChromaLocation.\n *\n * The positions represent the chroma (0,0) position in a coordinates system\n * with luma (0,0) representing the origin and luma(1,1) representing 256,256\n *\n * @param xpos  horizontal chroma sample position\n * @param ypos  vertical   chroma sample position\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_chroma_pos_to_enum"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "frame", :type "struct AVFrame *"} {:spelling "got_frame_ptr", :type "int *"} {:spelling "avpkt", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clong/AVPacket]], :symbol "avcodec_decode_audio4", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_decode_audio4, :raw-comment "/**\n * Decode the audio frame of size avpkt->size from avpkt->data into frame.\n *\n * Some decoders may support multiple frames in a single AVPacket. Such\n * decoders would then just decode the first frame and the return value would be\n * less than the packet size. In this case, avcodec_decode_audio4 has to be\n * called again with an AVPacket containing the remaining data in order to\n * decode the second frame, etc...  Even if no frames are returned, the packet\n * needs to be fed to the decoder with remaining data until it is completely\n * consumed or an error occurs.\n *\n * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n * and output. This means that for some packets they will not immediately\n * produce decoded output and need to be flushed at the end of decoding to get\n * all the decoded data. Flushing is done by calling this function with packets\n * with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n * returning samples. It is safe to flush even those decoders that are not\n * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.\n *\n * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n *          larger than the actual read bytes because some optimized bitstream\n *          readers read 32 or 64 bits at once and could read over the end.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n * before packets may be fed to the decoder.\n *\n * @param      avctx the codec context\n * @param[out] frame The AVFrame in which to store decoded audio samples.\n *                   The decoder will allocate a buffer for the decoded frame by\n *                   calling the AVCodecContext.get_buffer2() callback.\n *                   When AVCodecContext.refcounted_frames is set to 1, the frame is\n *                   reference counted and the returned reference belongs to the\n *                   caller. The caller must release the frame using av_frame_unref()\n *                   when the frame is no longer needed. The caller may safely write\n *                   to the frame if av_frame_is_writable() returns 1.\n *                   When AVCodecContext.refcounted_frames is set to 0, the returned\n *                   reference belongs to the decoder and is valid only until the\n *                   next call to this function or until closing or flushing the\n *                   decoder. The caller may not write to it.\n * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is\n *                           non-zero. Note that this field being set to zero\n *                           does not mean that an error has occurred. For\n *                           decoders with AV_CODEC_CAP_DELAY set, no given decode\n *                           call is guaranteed to produce a frame.\n * @param[in]  avpkt The input AVPacket containing the input buffer.\n *                   At least avpkt->data and avpkt->size should be set. Some\n *                   decoders might also require additional fields to be set.\n * @return A negative error code is returned if an error occurred during\n *         decoding, otherwise the number of bytes consumed from the input\n *         AVPacket is returned.\n *\n* @deprecated Use avcodec_send_packet() and avcodec_receive_frame().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_decode_audio4"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "picture", :type "struct AVFrame *"} {:spelling "got_picture_ptr", :type "int *"} {:spelling "avpkt", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clong/AVPacket]], :symbol "avcodec_decode_video2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_decode_video2, :raw-comment "/**\n * Decode the video frame of size avpkt->size from avpkt->data into picture.\n * Some decoders may support multiple frames in a single AVPacket, such\n * decoders would then just decode the first frame.\n *\n * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than\n * the actual read bytes because some optimized bitstream readers read 32 or 64\n * bits at once and could read over the end.\n *\n * @warning The end of the input buffer buf should be set to 0 to ensure that\n * no overreading happens for damaged MPEG streams.\n *\n * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay\n * between input and output, these need to be fed with avpkt->data=NULL,\n * avpkt->size=0 at the end to return the remaining frames.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n * before packets may be fed to the decoder.\n *\n * @param avctx the codec context\n * @param[out] picture The AVFrame in which the decoded video frame will be stored.\n *             Use av_frame_alloc() to get an AVFrame. The codec will\n *             allocate memory for the actual bitmap by calling the\n *             AVCodecContext.get_buffer2() callback.\n *             When AVCodecContext.refcounted_frames is set to 1, the frame is\n *             reference counted and the returned reference belongs to the\n *             caller. The caller must release the frame using av_frame_unref()\n *             when the frame is no longer needed. The caller may safely write\n *             to the frame if av_frame_is_writable() returns 1.\n *             When AVCodecContext.refcounted_frames is set to 0, the returned\n *             reference belongs to the decoder and is valid only until the\n *             next call to this function or until closing or flushing the\n *             decoder. The caller may not write to it.\n *\n * @param[in] avpkt The input AVPacket containing the input buffer.\n *            You can create such packet with av_init_packet() and by then setting\n *            data and size, some decoders might in addition need other fields like\n *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least\n *            fields possible.\n * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.\n * @return On error a negative value is returned, otherwise the number of bytes\n * used or zero if no frame could be decompressed.\n *\n * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_decode_video2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "sub", :type "struct AVSubtitle *"} {:spelling "got_sub_ptr", :type "int *"} {:spelling "avpkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVSubtitle] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clong/AVPacket]], :symbol "avcodec_decode_subtitle2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_decode_subtitle2, :raw-comment "/**\n * Decode a subtitle message.\n * Return a negative value on error, otherwise return the number of bytes used.\n * If no subtitle could be decompressed, got_sub_ptr is zero.\n * Otherwise, the subtitle is stored in *sub.\n * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for\n * simplicity, because the performance difference is expected to be negligible\n * and reusing a get_buffer written for video codecs would probably perform badly\n * due to a potentially very different allocation pattern.\n *\n * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n * and output. This means that for some packets they will not immediately\n * produce decoded output and need to be flushed at the end of decoding to get\n * all the decoded data. Flushing is done by calling this function with packets\n * with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n * returning subtitles. It is safe to flush even those decoders that are not\n * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n * before packets may be fed to the decoder.\n *\n * @param avctx the codec context\n * @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,\n *                 must be freed with avsubtitle_free if *got_sub_ptr is set.\n * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.\n * @param[in] avpkt The input AVPacket containing the input buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_decode_subtitle2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "avpkt", :type "const struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "avcodec_send_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_send_packet, :raw-comment "/**\n * Supply raw packet data as input to a decoder.\n *\n * Internally, this call will copy relevant AVCodecContext fields, which can\n * influence decoding per-packet, and apply them when the packet is actually\n * decoded. (For example AVCodecContext.skip_frame, which might direct the\n * decoder to drop the frame contained by the packet sent with this function.)\n *\n * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n *          larger than the actual read bytes because some optimized bitstream\n *          readers read 32 or 64 bits at once and could read over the end.\n *\n * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())\n *          on the same AVCodecContext. It will return unexpected results now\n *          or in future libavcodec versions.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n *       before packets may be fed to the decoder.\n *\n * @param avctx codec context\n * @param[in] avpkt The input AVPacket. Usually, this will be a single video\n *                  frame, or several complete audio frames.\n *                  Ownership of the packet remains with the caller, and the\n *                  decoder will not write to the packet. The decoder may create\n *                  a reference to the packet data (or copy it if the packet is\n *                  not reference-counted).\n *                  Unlike with older APIs, the packet is always fully consumed,\n *                  and if it contains multiple frames (e.g. some audio codecs),\n *                  will require you to call avcodec_receive_frame() multiple\n *                  times afterwards before you can send a new packet.\n *                  It can be NULL (or an AVPacket with data set to NULL and\n *                  size set to 0); in this case, it is considered a flush\n *                  packet, which signals the end of the stream. Sending the\n *                  first flush packet will return success. Subsequent ones are\n *                  unnecessary and will return AVERROR_EOF. If the decoder\n *                  still has frames buffered, it will return them after sending\n *                  a flush packet.\n *\n * @return 0 on success, otherwise negative error code:\n *      AVERROR(EAGAIN):   input is not accepted in the current state - user\n *                         must read output with avcodec_receive_frame() (once\n *                         all output is read, the packet should be resent, and\n *                         the call will not fail with EAGAIN).\n *      AVERROR_EOF:       the decoder has been flushed, and no new packets can\n *                         be sent to it (also returned if more than 1 flush\n *                         packet is sent)\n *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush\n *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n *      other errors: legitimate decoding errors\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_send_packet"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame]], :symbol "avcodec_receive_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_receive_frame, :raw-comment "/**\n * Return decoded output data from a decoder.\n *\n * @param avctx codec context\n * @param frame This will be set to a reference-counted video or audio\n *              frame (depending on the decoder type) allocated by the\n *              decoder. Note that the function will always call\n *              av_frame_unref(frame) before doing anything else.\n *\n * @return\n *      0:                 success, a frame was returned\n *      AVERROR(EAGAIN):   output is not available in this state - user must try\n *                         to send new input\n *      AVERROR_EOF:       the decoder has been fully flushed, and there will be\n *                         no more output frames\n *      AVERROR(EINVAL):   codec not opened, or it is an encoder\n *      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters\n *                               with respect to first decoded frame. Applicable\n *                               when flag AV_CODEC_FLAG_DROPCHANGED is set.\n *      other negative values: legitimate decoding errors\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_receive_frame"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "frame", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame]], :symbol "avcodec_send_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_send_frame, :raw-comment "/**\n * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()\n * to retrieve buffered output packets.\n *\n * @param avctx     codec context\n * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.\n *                  Ownership of the frame remains with the caller, and the\n *                  encoder will not write to the frame. The encoder may create\n *                  a reference to the frame data (or copy it if the frame is\n *                  not reference-counted).\n *                  It can be NULL, in which case it is considered a flush\n *                  packet.  This signals the end of the stream. If the encoder\n *                  still has packets buffered, it will return them after this\n *                  call. Once flushing mode has been entered, additional flush\n *                  packets are ignored, and sending frames will return\n *                  AVERROR_EOF.\n *\n *                  For audio:\n *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n *                  can have any number of samples.\n *                  If it is not set, frame->nb_samples must be equal to\n *                  avctx->frame_size for all frames except the last.\n *                  The final frame may be smaller than avctx->frame_size.\n * @return 0 on success, otherwise negative error code:\n *      AVERROR(EAGAIN):   input is not accepted in the current state - user\n *                         must read output with avcodec_receive_packet() (once\n *                         all output is read, the packet should be resent, and\n *                         the call will not fail with EAGAIN).\n *      AVERROR_EOF:       the encoder has been flushed, and no new frames can\n *                         be sent to it\n *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a\n *                         decoder, or requires flush\n *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar\n *      other errors: legitimate encoding errors\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_send_frame"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "avpkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "avcodec_receive_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_receive_packet, :raw-comment "/**\n * Read encoded data from the encoder.\n *\n * @param avctx codec context\n * @param avpkt This will be set to a reference-counted packet allocated by the\n *              encoder. Note that the function will always call\n *              av_packet_unref(avpkt) before doing anything else.\n * @return 0 on success, otherwise negative error code:\n *      AVERROR(EAGAIN):   output is not available in the current state - user\n *                         must try to send input\n *      AVERROR_EOF:       the encoder has been fully flushed, and there will be\n *                         no more output packets\n *      AVERROR(EINVAL):   codec not opened, or it is a decoder\n *      other errors: legitimate encoding errors\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_receive_packet"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "device_ref", :type "struct AVBufferRef *"} {:spelling "hw_pix_fmt", :type "enum AVPixelFormat"} {:spelling "out_frames_ref", :type "struct AVBufferRef **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVBufferRef] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]]], :symbol "avcodec_get_hw_frames_parameters", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_hw_frames_parameters, :raw-comment "/**\n * Create and return a AVHWFramesContext with values adequate for hardware\n * decoding. This is meant to get called from the get_format callback, and is\n * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.\n * This API is for decoding with certain hardware acceleration modes/APIs only.\n *\n * The returned AVHWFramesContext is not initialized. The caller must do this\n * with av_hwframe_ctx_init().\n *\n * Calling this function is not a requirement, but makes it simpler to avoid\n * codec or hardware API specific details when manually allocating frames.\n *\n * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,\n * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes\n * it unnecessary to call this function or having to care about\n * AVHWFramesContext initialization at all.\n *\n * There are a number of requirements for calling this function:\n *\n * - It must be called from get_format with the same avctx parameter that was\n *   passed to get_format. Calling it outside of get_format is not allowed, and\n *   can trigger undefined behavior.\n * - The function is not always supported (see description of return values).\n *   Even if this function returns successfully, hwaccel initialization could\n *   fail later. (The degree to which implementations check whether the stream\n *   is actually supported varies. Some do this check only after the user's\n *   get_format callback returns.)\n * - The hw_pix_fmt must be one of the choices suggested by get_format. If the\n *   user decides to use a AVHWFramesContext prepared with this API function,\n *   the user must return the same hw_pix_fmt from get_format.\n * - The device_ref passed to this function must support the given hw_pix_fmt.\n * - After calling this API function, it is the user's responsibility to\n *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),\n *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done\n *   before returning from get_format (this is implied by the normal\n *   AVCodecContext.hw_frames_ctx API rules).\n * - The AVHWFramesContext parameters may change every time time get_format is\n *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So\n *   you are inherently required to go through this process again on every\n *   get_format call.\n * - It is perfectly possible to call this function without actually using\n *   the resulting AVHWFramesContext. One use-case might be trying to reuse a\n *   previously initialized AVHWFramesContext, and calling this API function\n *   only to test whether the required frame parameters have changed.\n * - Fields that use dynamically allocated values of any kind must not be set\n *   by the user unless setting them is explicitly allowed by the documentation.\n *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,\n *   the new free callback must call the potentially set previous free callback.\n *   This API call may set any dynamically allocated fields, including the free\n *   callback.\n *\n * The function will set at least the following fields on AVHWFramesContext\n * (potentially more, depending on hwaccel API):\n *\n * - All fields set by av_hwframe_ctx_alloc().\n * - Set the format field to hw_pix_fmt.\n * - Set the sw_format field to the most suited and most versatile format. (An\n *   implication is that this will prefer generic formats over opaque formats\n *   with arbitrary restrictions, if possible.)\n * - Set the width/height fields to the coded frame size, rounded up to the\n *   API-specific minimum alignment.\n * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size\n *   field to the number of maximum reference surfaces possible with the codec,\n *   plus 1 surface for the user to work (meaning the user can safely reference\n *   at most 1 decoded surface at a time), plus additional buffering introduced\n *   by frame threading. If the hwaccel does not require pre-allocation, the\n *   field is left to 0, and the decoder will allocate new surfaces on demand\n *   during decoding.\n * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying\n *   hardware API.\n *\n * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but\n * with basic frame parameters set.\n *\n * The function is stateless, and does not change the AVCodecContext or the\n * device_ref AVHWDeviceContext.\n *\n * @param avctx The context which is currently calling get_format, and which\n *              implicitly contains all state needed for filling the returned\n *              AVHWFramesContext properly.\n * @param device_ref A reference to the AVHWDeviceContext describing the device\n *                   which will be used by the hardware decoder.\n * @param hw_pix_fmt The hwaccel format you are going to return from get_format.\n * @param out_frames_ref On success, set to a reference to an _uninitialized_\n *                       AVHWFramesContext, created from the given device_ref.\n *                       Fields will be set to values required for decoding.\n *                       Not changed if an error is returned.\n * @return zero on success, a negative value on error. The following error codes\n *         have special semantics:\n *      AVERROR(ENOENT): the decoder does not support this functionality. Setup\n *                       is always manual, or it is a decoder which does not\n *                       support setting AVCodecContext.hw_frames_ctx at all,\n *                       or it is a software format.\n *      AVERROR(EINVAL): it is known that hardware decoding is not supported for\n *                       this configuration, or the device_ref is not supported\n *                       for the hwaccel referenced by hw_pix_fmt.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_hw_frames_parameters"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVCodecParser *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_parser_iterate", :function/ret [:coffi.mem/pointer :clong/AVCodecParser], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_iterate, :raw-comment "/**\n * Iterate over all registered codec parsers.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered codec parser or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parser_iterate"} {:args [{:spelling "c", :type "const struct AVCodecParser *"}], :ret {:spelling "struct AVCodecParser *"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParser]], :symbol "av_parser_next", :function/ret [:coffi.mem/pointer :clong/AVCodecParser], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_next, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_parser_next"} {:args [{:spelling "parser", :type "struct AVCodecParser *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParser]], :symbol "av_register_codec_parser", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_codec_parser, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_register_codec_parser"} {:args [{:spelling "codec_id", :type "int"}], :ret {:spelling "struct AVCodecParserContext *"}, :function/args [:coffi.mem/int], :symbol "av_parser_init", :function/ret [:coffi.mem/pointer :clong/AVCodecParserContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_init, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_parser_init"} {:args [{:spelling "s", :type "struct AVCodecParserContext *"} {:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "poutbuf", :type "unsigned char **"} {:spelling "poutbuf_size", :type "int *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "pts", :type "long long"} {:spelling "dts", :type "long long"} {:spelling "pos", :type "long long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParserContext] [:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/long :coffi.mem/long :coffi.mem/long], :symbol "av_parser_parse2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_parse2, :raw-comment "/**\n * Parse a packet.\n *\n * @param s             parser context.\n * @param avctx         codec context.\n * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n * @param buf           input buffer.\n * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\n                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\n                        To signal EOF, this should be 0 (so that the last frame\n                        can be output).\n * @param pts           input presentation timestamp.\n * @param dts           input decoding timestamp.\n * @param pos           input byte position in stream.\n * @return the number of bytes of the input bitstream used.\n *\n * Example:\n * @code\n *   while(in_len){\n *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n *                                        in_data, in_len,\n *                                        pts, dts, pos);\n *       in_data += len;\n *       in_len  -= len;\n *\n *       if(size)\n *          decode_frame(data, size);\n *   }\n * @endcode\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parser_parse2"} {:args [{:spelling "s", :type "struct AVCodecParserContext *"} {:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "poutbuf", :type "unsigned char **"} {:spelling "poutbuf_size", :type "int *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "keyframe", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParserContext] [:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_parser_change", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_change, :raw-comment "/**\n * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed\n * @deprecated Use dump_extradata, remove_extra or extract_extradata\n *             bitstream filters instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_parser_change"} {:args [{:spelling "s", :type "struct AVCodecParserContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParserContext]], :symbol "av_parser_close", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_parser_close, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_parser_close"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "avpkt", :type "struct AVPacket *"} {:spelling "frame", :type "const struct AVFrame *"} {:spelling "got_packet_ptr", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_encode_audio2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_encode_audio2, :raw-comment "/**\n * Encode a frame of audio.\n *\n * Takes input samples from frame and writes the next output packet, if\n * available, to avpkt. The output packet does not necessarily contain data for\n * the most recent frame, as encoders can delay, split, and combine input frames\n * internally as needed.\n *\n * @param avctx     codec context\n * @param avpkt     output AVPacket.\n *                  The user can supply an output buffer by setting\n *                  avpkt->data and avpkt->size prior to calling the\n *                  function, but if the size of the user-provided data is not\n *                  large enough, encoding will fail. If avpkt->data and\n *                  avpkt->size are set, avpkt->destruct must also be set. All\n *                  other AVPacket fields will be reset by the encoder using\n *                  av_init_packet(). If avpkt->data is NULL, the encoder will\n *                  allocate it. The encoder will set avpkt->size to the size\n *                  of the output packet.\n *\n *                  If this function fails or produces no output, avpkt will be\n *                  freed using av_packet_unref().\n * @param[in] frame AVFrame containing the raw audio data to be encoded.\n *                  May be NULL when flushing an encoder that has the\n *                  AV_CODEC_CAP_DELAY capability set.\n *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n *                  can have any number of samples.\n *                  If it is not set, frame->nb_samples must be equal to\n *                  avctx->frame_size for all frames except the last.\n *                  The final frame may be smaller than avctx->frame_size.\n * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the\n *                            output packet is non-empty, and to 0 if it is\n *                            empty. If the function returns an error, the\n *                            packet can be assumed to be invalid, and the\n *                            value of got_packet_ptr is undefined and should\n *                            not be used.\n * @return          0 on success, negative error code on failure\n *\n * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.\n *             If allowed and required, set AVCodecContext.get_encode_buffer to\n *             a custom function to pass user supplied output buffers.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_encode_audio2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "avpkt", :type "struct AVPacket *"} {:spelling "frame", :type "const struct AVFrame *"} {:spelling "got_packet_ptr", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_encode_video2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_encode_video2, :raw-comment "/**\n * Encode a frame of video.\n *\n * Takes input raw video data from frame and writes the next output packet, if\n * available, to avpkt. The output packet does not necessarily contain data for\n * the most recent frame, as encoders can delay and reorder input frames\n * internally as needed.\n *\n * @param avctx     codec context\n * @param avpkt     output AVPacket.\n *                  The user can supply an output buffer by setting\n *                  avpkt->data and avpkt->size prior to calling the\n *                  function, but if the size of the user-provided data is not\n *                  large enough, encoding will fail. All other AVPacket fields\n *                  will be reset by the encoder using av_init_packet(). If\n *                  avpkt->data is NULL, the encoder will allocate it.\n *                  The encoder will set avpkt->size to the size of the\n *                  output packet. The returned data (if any) belongs to the\n *                  caller, he is responsible for freeing it.\n *\n *                  If this function fails or produces no output, avpkt will be\n *                  freed using av_packet_unref().\n * @param[in] frame AVFrame containing the raw video data to be encoded.\n *                  May be NULL when flushing an encoder that has the\n *                  AV_CODEC_CAP_DELAY capability set.\n * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the\n *                            output packet is non-empty, and to 0 if it is\n *                            empty. If the function returns an error, the\n *                            packet can be assumed to be invalid, and the\n *                            value of got_packet_ptr is undefined and should\n *                            not be used.\n * @return          0 on success, negative error code on failure\n *\n * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.\n *             If allowed and required, set AVCodecContext.get_encode_buffer to\n *             a custom function to pass user supplied output buffers.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_encode_video2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "buf", :type "unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "sub", :type "const struct AVSubtitle *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVSubtitle]], :symbol "avcodec_encode_subtitle", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_encode_subtitle, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_encode_subtitle"} {:args [{:spelling "picture", :type "struct AVPicture *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "avpicture_alloc", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpicture_alloc, :raw-comment "/**\n * @deprecated unused\n */", :kind "CXCursor_FunctionDecl", :spelling "avpicture_alloc"} {:args [{:spelling "picture", :type "struct AVPicture *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPicture]], :symbol "avpicture_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpicture_free, :raw-comment "/**\n * @deprecated unused\n */", :kind "CXCursor_FunctionDecl", :spelling "avpicture_free"} {:args [{:spelling "picture", :type "struct AVPicture *"} {:spelling "ptr", :type "const unsigned char *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "avpicture_fill", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpicture_fill, :raw-comment "/**\n * @deprecated use av_image_fill_arrays() instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "avpicture_fill"} {:args [{:spelling "src", :type "const struct AVPicture *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "dest", :type "unsigned char *"} {:spelling "dest_size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "avpicture_layout", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpicture_layout, :raw-comment "/**\n * @deprecated use av_image_copy_to_buffer() instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "avpicture_layout"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "avpicture_get_size", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avpicture_get_size, :raw-comment "/**\n * @deprecated use av_image_get_buffer_size() instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "avpicture_get_size"} {:args [{:spelling "dst", :type "struct AVPicture *"} {:spelling "src", :type "const struct AVPicture *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "width", :type "int"} {:spelling "height", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] [:coffi.mem/pointer :clong/AVPicture] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_picture_copy", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_picture_copy, :raw-comment "/**\n * @deprecated av_image_copy() instead.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_picture_copy"} {:args [{:spelling "dst", :type "struct AVPicture *"} {:spelling "src", :type "const struct AVPicture *"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "top_band", :type "int"} {:spelling "left_band", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] [:coffi.mem/pointer :clong/AVPicture] :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_picture_crop", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_picture_crop, :raw-comment "/**\n * @deprecated unused\n */", :kind "CXCursor_FunctionDecl", :spelling "av_picture_crop"} {:args [{:spelling "dst", :type "struct AVPicture *"} {:spelling "src", :type "const struct AVPicture *"} {:spelling "height", :type "int"} {:spelling "width", :type "int"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "padtop", :type "int"} {:spelling "padbottom", :type "int"} {:spelling "padleft", :type "int"} {:spelling "padright", :type "int"} {:spelling "color", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVPicture] [:coffi.mem/pointer :clong/AVPicture] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_picture_pad", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_picture_pad, :raw-comment "/**\n * @deprecated unused\n */", :kind "CXCursor_FunctionDecl", :spelling "av_picture_pad"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "h_shift", :type "int *"} {:spelling "v_shift", :type "int *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_get_chroma_sub_sample", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_chroma_sub_sample, :raw-comment "/**\n * @deprecated Use av_pix_fmt_get_chroma_sub_sample\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_chroma_sub_sample"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "avcodec_pix_fmt_to_codec_tag", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_pix_fmt_to_codec_tag, :raw-comment "/**\n * Return a value representing the fourCC code associated to the\n * pixel format pix_fmt, or 0 if no associated fourCC code can be\n * found.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_pix_fmt_to_codec_tag"} {:args [{:spelling "pix_fmt_list", :type "const enum AVPixelFormat *"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"} {:spelling "loss_ptr", :type "int *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [[:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_find_best_pix_fmt_of_list", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_best_pix_fmt_of_list, :raw-comment "/**\n * Find the best pixel format to convert to given a certain source pixel\n * format.  When converting from one pixel format to another, information loss\n * may occur.  For example, when converting from RGB24 to GRAY, the color\n * information will be lost. Similarly, other losses occur when converting from\n * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n * the given pixel formats should be used to suffer the least amount of loss.\n * The pixel formats from which it chooses one, are determined by the\n * pix_fmt_list parameter.\n *\n *\n * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n * @return The best pixel format to convert to or -1 if none was found.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_best_pix_fmt_of_list"} {:args [{:spelling "dst_pix_fmt", :type "enum AVPixelFormat"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "avcodec_get_pix_fmt_loss", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_get_pix_fmt_loss, :raw-comment "/**\n * @deprecated see av_get_pix_fmt_loss()\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_get_pix_fmt_loss"} {:args [{:spelling "dst_pix_fmt1", :type "enum AVPixelFormat"} {:spelling "dst_pix_fmt2", :type "enum AVPixelFormat"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"} {:spelling "loss_ptr", :type "int *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_find_best_pix_fmt_of_2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_best_pix_fmt_of_2, :raw-comment "/**\n * @deprecated see av_find_best_pix_fmt_of_2()\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_best_pix_fmt_of_2"} {:args [{:spelling "dst_pix_fmt1", :type "enum AVPixelFormat"} {:spelling "dst_pix_fmt2", :type "enum AVPixelFormat"} {:spelling "src_pix_fmt", :type "enum AVPixelFormat"} {:spelling "has_alpha", :type "int"} {:spelling "loss_ptr", :type "int *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_find_best_pix_fmt2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_find_best_pix_fmt2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_find_best_pix_fmt2"} {:args [{:spelling "s", :type "struct AVCodecContext *"} {:spelling "fmt", :type "const enum AVPixelFormat *"}], :ret {:spelling "enum AVPixelFormat"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int]], :symbol "avcodec_default_get_format", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_default_get_format, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_default_get_format"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "unsigned long"} {:spelling "codec_tag", :type "unsigned int"}], :ret {:spelling "unsigned long"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long :coffi.mem/int], :symbol "av_get_codec_tag_string", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_codec_tag_string, :raw-comment "/**\n * Put a string representing the codec tag codec_tag in buf.\n *\n * @param buf       buffer to place codec tag in\n * @param buf_size size in bytes of buf\n * @param codec_tag codec tag to assign\n * @return the length of the string that would have been generated if\n * enough space had been available, excluding the trailing null\n *\n * @deprecated see av_fourcc_make_string() and av_fourcc2str().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_codec_tag_string"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "enc", :type "struct AVCodecContext *"} {:spelling "encode", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int], :symbol "avcodec_string", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_string, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_string"} {:args [{:spelling "codec", :type "const struct AVCodec *"} {:spelling "profile", :type "int"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clong/AVCodec] :coffi.mem/int], :symbol "av_get_profile_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_profile_name, :raw-comment "/**\n * Return a name for the specified profile, if available.\n *\n * @param codec the codec that is searched for the given profile\n * @param profile the profile value for which a name is requested\n * @return A name for the profile if found, NULL otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_profile_name"} {:args [{:spelling "codec_id", :type "enum AVCodecID"} {:spelling "profile", :type "int"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "avcodec_profile_name", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_profile_name, :raw-comment "/**\n * Return a name for the specified profile, if available.\n *\n * @param codec_id the ID of the codec to which the requested profile belongs\n * @param profile the profile value for which a name is requested\n * @return A name for the profile if found, NULL otherwise.\n *\n * @note unlike av_get_profile_name(), which searches a list of profiles\n *       supported by a specific decoder or encoder implementation, this\n *       function searches the list of profiles from the AVCodecDescriptor\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_profile_name"} {:args [{:spelling "c", :type "struct AVCodecContext *"} {:spelling "func", :type "int (*)(struct AVCodecContext *, void *)"} {:spelling "arg", :type "void *"} {:spelling "ret", :type "int *"} {:spelling "count", :type "int"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int], :symbol "avcodec_default_execute", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_default_execute, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_default_execute"} {:args [{:spelling "c", :type "struct AVCodecContext *"} {:spelling "func", :type "int (*)(struct AVCodecContext *, void *, int, int)"} {:spelling "arg", :type "void *"} {:spelling "ret", :type "int *"} {:spelling "count", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int] :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "avcodec_default_execute2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_default_execute2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_default_execute2"} {:args [{:spelling "frame", :type "struct AVFrame *"} {:spelling "nb_channels", :type "int"} {:spelling "sample_fmt", :type "enum AVSampleFormat"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "align", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "avcodec_fill_audio_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_fill_audio_frame, :raw-comment "/**\n * Fill AVFrame audio data and linesize pointers.\n *\n * The buffer buf must be a preallocated buffer with a size big enough\n * to contain the specified samples amount. The filled AVFrame data\n * pointers will point to this buffer.\n *\n * AVFrame extended_data channel pointers are allocated if necessary for\n * planar audio.\n *\n * @param frame       the AVFrame\n *                    frame->nb_samples must be set prior to calling the\n *                    function. This function fills in frame->data,\n *                    frame->extended_data, frame->linesize[0].\n * @param nb_channels channel count\n * @param sample_fmt  sample format\n * @param buf         buffer to use for frame data\n * @param buf_size    size of buffer\n * @param align       plane size sample alignment (0 = default)\n * @return            >=0 on success, negative error code on failure\n * @todo return the size in bytes required to store the samples in\n * case of success, at the next libavutil bump\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_fill_audio_frame"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "avcodec_flush_buffers", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_flush_buffers, :raw-comment "/**\n * Reset the internal codec state / flush internal buffers. Should be called\n * e.g. when seeking or when switching to a different stream.\n *\n * @note for decoders, when refcounted frames are not used\n * (i.e. avctx->refcounted_frames is 0), this invalidates the frames previously\n * returned from the decoder. When refcounted frames are used, the decoder just\n * releases any references it might keep internally, but the caller's reference\n * remains valid.\n *\n * @note for encoders, this function will only do something if the encoder\n * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder\n * will drain any remaining packets, and can then be re-used for a different\n * stream (as opposed to sending a null frame which will leave the encoder\n * in a permanent EOF state after draining). This can be desirable if the\n * cost of tearing down and replacing the encoder instance is high.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_flush_buffers"} {:args [{:spelling "codec_id", :type "enum AVCodecID"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_get_bits_per_sample", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_bits_per_sample, :raw-comment "/**\n * Return codec bits per sample.\n *\n * @param[in] codec_id the codec\n * @return Number of bits per sample or zero if unknown for the given codec.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_bits_per_sample"} {:args [{:spelling "fmt", :type "enum AVSampleFormat"} {:spelling "be", :type "int"}], :ret {:spelling "enum AVCodecID"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_get_pcm_codec", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_pcm_codec, :raw-comment "/**\n * Return the PCM codec associated with a sample format.\n * @param be  endianness, 0 for little, 1 for big,\n *            -1 (or anything else) for native\n * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_pcm_codec"} {:args [{:spelling "codec_id", :type "enum AVCodecID"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "av_get_exact_bits_per_sample", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_exact_bits_per_sample, :raw-comment "/**\n * Return codec bits per sample.\n * Only return non-zero if the bits per sample is exactly correct, not an\n * approximation.\n *\n * @param[in] codec_id the codec\n * @return Number of bits per sample or zero if unknown for the given codec.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_exact_bits_per_sample"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "frame_bytes", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int], :symbol "av_get_audio_frame_duration", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_audio_frame_duration, :raw-comment "/**\n * Return audio frame duration.\n *\n * @param avctx        codec context\n * @param frame_bytes  size of the frame, or 0 if unknown\n * @return             frame duration, in samples, if known. 0 if not able to\n *                     determine.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_audio_frame_duration"} {:args [{:spelling "par", :type "struct AVCodecParameters *"} {:spelling "frame_bytes", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecParameters] :coffi.mem/int], :symbol "av_get_audio_frame_duration2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_audio_frame_duration2, :raw-comment "/**\n * This function is the same as av_get_audio_frame_duration(), except it works\n * with AVCodecParameters instead of an AVCodecContext.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_audio_frame_duration2"} {:args [{:spelling "bsf", :type "struct AVBitStreamFilter *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBitStreamFilter]], :symbol "av_register_bitstream_filter", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_bitstream_filter, :raw-comment "/**\n * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n * is deprecated. Use the new bitstream filtering API (using AVBSFContext).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_register_bitstream_filter"} {:args [{:spelling "name", :type "const char *"}], :ret {:spelling "struct AVBitStreamFilterContext *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_bitstream_filter_init", :function/ret [:coffi.mem/pointer :clong/AVBitStreamFilterContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bitstream_filter_init, :raw-comment "/**\n * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n * is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()\n * from the new bitstream filtering API (using AVBSFContext).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bitstream_filter_init"} {:args [{:spelling "bsfc", :type "struct AVBitStreamFilterContext *"} {:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "args", :type "const char *"} {:spelling "poutbuf", :type "unsigned char **"} {:spelling "poutbuf_size", :type "int *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "keyframe", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVBitStreamFilterContext] [:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_bitstream_filter_filter", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bitstream_filter_filter, :raw-comment "/**\n * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n * is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the\n * new bitstream filtering API (using AVBSFContext).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bitstream_filter_filter"} {:args [{:spelling "bsf", :type "struct AVBitStreamFilterContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVBitStreamFilterContext]], :symbol "av_bitstream_filter_close", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bitstream_filter_close, :raw-comment "/**\n * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n * is deprecated. Use av_bsf_free() from the new bitstream filtering API (using\n * AVBSFContext).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bitstream_filter_close"} {:args [{:spelling "f", :type "const struct AVBitStreamFilter *"}], :ret {:spelling "const struct AVBitStreamFilter *"}, :function/args [[:coffi.mem/pointer :clong/AVBitStreamFilter]], :symbol "av_bitstream_filter_next", :function/ret [:coffi.mem/pointer :clong/AVBitStreamFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bitstream_filter_next, :raw-comment "/**\n * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)\n * is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using\n * AVBSFContext).\n */", :kind "CXCursor_FunctionDecl", :spelling "av_bitstream_filter_next"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVBitStreamFilter *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_bsf_next", :function/ret [:coffi.mem/pointer :clong/AVBitStreamFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_bsf_next, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_bsf_next"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned int *"} {:spelling "min_size", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long], :symbol "av_fast_padded_malloc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fast_padded_malloc, :raw-comment "/**\n * Same behaviour av_fast_malloc but the buffer has additional\n * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n *\n * In addition the whole buffer will initially and after resizes\n * be 0-initialized so that no uninitialized data will ever appear.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fast_padded_malloc"} {:args [{:spelling "ptr", :type "void *"} {:spelling "size", :type "unsigned int *"} {:spelling "min_size", :type "unsigned long"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/long], :symbol "av_fast_padded_mallocz", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fast_padded_mallocz, :raw-comment "/**\n * Same behaviour av_fast_padded_malloc except that buffer will always\n * be 0-initialized after call.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fast_padded_mallocz"} {:args [{:spelling "s", :type "unsigned char *"} {:spelling "v", :type "unsigned int"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_xiphlacing", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_xiphlacing, :raw-comment "/**\n * Encode extradata length to a buffer. Used by xiph codecs.\n *\n * @param s buffer to write to; must be at least (v/255+1) bytes long\n * @param v size of extradata in bytes\n * @return number of bytes written to the buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_xiphlacing"} {:args [{:spelling "hwaccel", :type "struct AVHWAccel *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVHWAccel]], :symbol "av_register_hwaccel", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_hwaccel, :raw-comment "/**\n * Register the hardware accelerator hwaccel.\n *\n * @deprecated  This function doesn't do anything.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_register_hwaccel"} {:args [{:spelling "hwaccel", :type "const struct AVHWAccel *"}], :ret {:spelling "struct AVHWAccel *"}, :function/args [[:coffi.mem/pointer :clong/AVHWAccel]], :symbol "av_hwaccel_next", :function/ret [:coffi.mem/pointer :clong/AVHWAccel], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hwaccel_next, :raw-comment "/**\n * If hwaccel is NULL, returns the first registered hardware accelerator,\n * if hwaccel is non-NULL, returns the next registered hardware accelerator\n * after hwaccel, or NULL if hwaccel is the last one.\n *\n * @deprecated  AVHWaccel structures contain no user-serviceable parts, so\n *              this function should not be used.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hwaccel_next"} {:args [{:spelling "cb", :type "int (*)(void **, enum AVLockOp)"}], :ret {:spelling "int"}, :function/args [[:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/int]], :symbol "av_lockmgr_register", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_lockmgr_register, :raw-comment "/**\n * Register a user provided lock manager supporting the operations\n * specified by AVLockOp. The \"mutex\" argument to the function points\n * to a (void *) where the lockmgr should store/get a pointer to a user\n * allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the\n * value left by the last call for all other ops. If the lock manager is\n * unable to perform the op then it should leave the mutex in the same\n * state as when it was called and return a non-zero value. However,\n * when called with AV_LOCK_DESTROY the mutex will always be assumed to\n * have been successfully destroyed. If av_lockmgr_register succeeds\n * it will return a non-negative value, if it fails it will return a\n * negative value and destroy all mutex and unregister all callbacks.\n * av_lockmgr_register is not thread-safe, it must be called from a\n * single thread before any calls which make use of locking are used.\n *\n * @param cb User defined callback. av_lockmgr_register invokes calls\n *           to this callback and the previously registered callback.\n *           The callback will be used to create more than one mutex\n *           each of which must be backed by its own underlying locking\n *           mechanism (i.e. do not use a single static object to\n *           implement your lock manager). If cb is set to NULL the\n *           lockmgr will be unregistered.\n *\n * @deprecated This function does nothing, and always returns 0. Be sure to\n *             build with thread support to get basic thread safety.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_lockmgr_register"} {:args [{:spelling "s", :type "struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "avcodec_is_open", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_is_open, :raw-comment "/**\n * @return a positive value if s is open (i.e. avcodec_open2() was called on it\n * with no corresponding avcodec_close()), 0 otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_is_open"} {:args [{:spelling "size", :type "unsigned long *"}], :ret {:spelling "struct AVCPBProperties *"}, :function/args [[:coffi.mem/pointer :coffi.mem/long]], :symbol "av_cpb_properties_alloc", :function/ret [:coffi.mem/pointer :clong/AVCPBProperties], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_cpb_properties_alloc, :raw-comment "/**\n * Allocate a CPB properties structure and initialize its fields to default\n * values.\n *\n * @param size if non-NULL, the size of the allocated struct will be written\n *             here. This is useful for embedding it in side data.\n *\n * @return the newly allocated struct or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_cpb_properties_alloc"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "pkt", :type "struct AVPacket *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "av_get_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_packet, :raw-comment "/**\n * Allocate and read the payload of a packet and initialize its\n * fields with default values.\n *\n * @param s    associated IO context\n * @param pkt packet\n * @param size desired payload size\n * @return >0 (read size) if OK, AVERROR_xxx otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_packet"} {:args [{:spelling "s", :type "struct AVIOContext *"} {:spelling "pkt", :type "struct AVPacket *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int], :symbol "av_append_packet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_append_packet, :raw-comment "/**\n * Read data and append it to the current content of the AVPacket.\n * If pkt->size is 0 this is identical to av_get_packet.\n * Note that this uses av_grow_packet and thus involves a realloc\n * which is inefficient. Thus this function should only be used\n * when there is no reasonable way to know (an upper bound of)\n * the final size.\n *\n * @param s    associated IO context\n * @param pkt packet\n * @param size amount of data to read\n * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data\n *         will not be lost even if an error occurs.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_append_packet"} {:args [{:spelling "s", :type "const struct AVStream *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVStream]], :symbol "av_stream_get_r_frame_rate", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_r_frame_rate, :raw-comment "/**\n * Accessors for some AVStream fields. These used to be provided for ABI\n * compatibility, and do not need to be used anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_r_frame_rate"} {:args [{:spelling "s", :type "struct AVStream *"} {:spelling "r", :type "struct AVRational"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :clong/AVRational], :symbol "av_stream_set_r_frame_rate", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_set_r_frame_rate, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_stream_set_r_frame_rate"} {:args [{:spelling "s", :type "const struct AVStream *"}], :ret {:spelling "char *"}, :function/args [[:coffi.mem/pointer :clong/AVStream]], :symbol "av_stream_get_recommended_encoder_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_recommended_encoder_configuration, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_recommended_encoder_configuration"} {:args [{:spelling "s", :type "struct AVStream *"} {:spelling "configuration", :type "char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVStream] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_stream_set_recommended_encoder_configuration", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_set_recommended_encoder_configuration, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_stream_set_recommended_encoder_configuration"} {:args [{:spelling "s", :type "const struct AVStream *"}], :ret {:spelling "struct AVCodecParserContext *"}, :function/args [[:coffi.mem/pointer :clong/AVStream]], :symbol "av_stream_get_parser", :function/ret [:coffi.mem/pointer :clong/AVCodecParserContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_parser, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_parser"} {:args [{:spelling "st", :type "const struct AVStream *"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/AVStream]], :symbol "av_stream_get_end_pts", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_end_pts, :raw-comment "/**\n * Returns the pts of the last muxed packet + its duration\n *\n * the retuned value is undefined when used with a demuxer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_end_pts"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_probe_score", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_probe_score, :raw-comment "/**\n * Accessors for some AVFormatContext fields. These used to be provided for ABI\n * compatibility, and do not need to be used anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_format_get_probe_score"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_video_codec", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_video_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_video_codec"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "struct AVCodec *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "av_format_set_video_codec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_video_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_video_codec"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_audio_codec", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_audio_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_audio_codec"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "struct AVCodec *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "av_format_set_audio_codec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_audio_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_audio_codec"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_subtitle_codec", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_subtitle_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_subtitle_codec"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "struct AVCodec *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "av_format_set_subtitle_codec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_subtitle_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_subtitle_codec"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "struct AVCodec *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_data_codec", :function/ret [:coffi.mem/pointer :clong/AVCodec], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_data_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_data_codec"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "struct AVCodec *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "av_format_set_data_codec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_data_codec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_data_codec"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_metadata_header_padding", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_metadata_header_padding, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_metadata_header_padding"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int], :symbol "av_format_set_metadata_header_padding", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_metadata_header_padding, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_metadata_header_padding"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_opaque", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_opaque, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_opaque"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "opaque", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/pointer], :symbol "av_format_set_opaque", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_opaque, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_opaque"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "int (*)(struct AVFormatContext *, int, void *, unsigned long)"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_control_message_cb", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long] :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_control_message_cb, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_control_message_cb"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "callback", :type "int (*)(struct AVFormatContext *, int, void *, unsigned long)"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long] :coffi.mem/int]], :symbol "av_format_set_control_message_cb", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_control_message_cb, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_control_message_cb"} {:args [{:spelling "s", :type "const struct AVFormatContext *"}], :ret {:spelling "int (*)(struct AVFormatContext *, struct AVIOContext **, const char *, int, const struct AVIOInterruptCB *, struct AVDictionary **)"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_get_open_cb", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVIOInterruptCB] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]] :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_get_open_cb, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_get_open_cb"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "callback", :type "int (*)(struct AVFormatContext *, struct AVIOContext **, const char *, int, const struct AVIOInterruptCB *, struct AVDictionary **)"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVIOInterruptCB] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]] :coffi.mem/int]], :symbol "av_format_set_open_cb", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_set_open_cb, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_format_set_open_cb"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_format_inject_global_side_data", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_format_inject_global_side_data, :raw-comment "/**\n * This function will cause global side data to be injected in the next packet\n * of each stream as well as after any subsequent seek.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_format_inject_global_side_data"} {:args [{:spelling "ctx", :type "const struct AVFormatContext *"}], :ret {:spelling "enum AVDurationEstimationMethod"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_fmt_ctx_get_duration_estimation_method", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fmt_ctx_get_duration_estimation_method, :raw-comment "/**\n * Returns the method used to set ctx->duration.\n *\n * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fmt_ctx_get_duration_estimation_method"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avformat_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_version, :raw-comment "/**\n * Return the LIBAVFORMAT_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avformat_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_configuration, :raw-comment "/**\n * Return the libavformat build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avformat_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_license, :raw-comment "/**\n * Return the libavformat license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_license"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "av_register_all", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_all, :raw-comment "/**\n * Initialize libavformat and register all the muxers, demuxers and\n * protocols. If you do not call this function, then you can select\n * exactly which formats you want to support.\n *\n * @see av_register_input_format()\n * @see av_register_output_format()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_register_all"} {:args [{:spelling "format", :type "struct AVInputFormat *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVInputFormat]], :symbol "av_register_input_format", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_input_format, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_register_input_format"} {:args [{:spelling "format", :type "struct AVOutputFormat *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat]], :symbol "av_register_output_format", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_register_output_format, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_register_output_format"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "avformat_network_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_network_init, :raw-comment "/**\n * Do global initialization of network libraries. This is optional,\n * and not recommended anymore.\n *\n * This functions only exists to work around thread-safety issues\n * with older GnuTLS or OpenSSL libraries. If libavformat is linked\n * to newer versions of those libraries, or if you do not use them,\n * calling this function is unnecessary. Otherwise, you need to call\n * this function before any other threads using them are started.\n *\n * This function will be deprecated once support for older GnuTLS and\n * OpenSSL libraries is removed, and this function has no purpose\n * anymore.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_network_init"} {:args [], :ret {:spelling "int"}, :function/args [], :symbol "avformat_network_deinit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_network_deinit, :raw-comment "/**\n * Undo the initialization done by avformat_network_init. Call it only\n * once for each time you called avformat_network_init.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_network_deinit"} {:args [{:spelling "f", :type "const struct AVInputFormat *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVInputFormat]], :symbol "av_iformat_next", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_iformat_next, :raw-comment "/**\n * If f is NULL, returns the first registered input format,\n * if f is non-NULL, returns the next registered input format after f\n * or NULL if f is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_iformat_next"} {:args [{:spelling "f", :type "const struct AVOutputFormat *"}], :ret {:spelling "struct AVOutputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat]], :symbol "av_oformat_next", :function/ret [:coffi.mem/pointer :clong/AVOutputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_oformat_next, :raw-comment "/**\n * If f is NULL, returns the first registered output format,\n * if f is non-NULL, returns the next registered output format after f\n * or NULL if f is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_oformat_next"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVOutputFormat *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_muxer_iterate", :function/ret [:coffi.mem/pointer :clong/AVOutputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_muxer_iterate, :raw-comment "/**\n * Iterate over all registered muxers.\n *\n * @param opaque a pointer where libavformat will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered muxer or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_muxer_iterate"} {:args [{:spelling "opaque", :type "void **"}], :ret {:spelling "const struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :coffi.mem/pointer]], :symbol "av_demuxer_iterate", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_demuxer_iterate, :raw-comment "/**\n * Iterate over all registered demuxers.\n *\n * @param opaque a pointer where libavformat will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered demuxer or NULL when the iteration is\n *         finished\n */", :kind "CXCursor_FunctionDecl", :spelling "av_demuxer_iterate"} {:args [], :ret {:spelling "struct AVFormatContext *"}, :function/args [], :symbol "avformat_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVFormatContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_alloc_context, :raw-comment "/**\n * Allocate an AVFormatContext.\n * avformat_free_context() can be used to free the context and everything\n * allocated by the framework within it.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_alloc_context"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "avformat_free_context", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_free_context, :raw-comment "/**\n * Free an AVFormatContext and all its streams.\n * @param s context to free\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_free_context"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avformat_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_get_class, :raw-comment "/**\n * Get the AVClass for AVFormatContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_get_class"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "c", :type "const struct AVCodec *"}], :ret {:spelling "struct AVStream *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVCodec]], :symbol "avformat_new_stream", :function/ret [:coffi.mem/pointer :clong/AVStream], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_new_stream, :raw-comment "/**\n * Add a new stream to a media file.\n *\n * When demuxing, it is called by the demuxer in read_header(). If the\n * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n * be called in read_packet().\n *\n * When muxing, should be called by the user before avformat_write_header().\n *\n * User is required to call avcodec_close() and avformat_free_context() to\n * clean up the allocation by avformat_new_stream().\n *\n * @param s media file handle\n * @param c If non-NULL, the AVCodecContext corresponding to the new stream\n * will be initialized to use this codec. This is needed for e.g. codec-specific\n * defaults to be set, so codec should be provided if it is known.\n *\n * @return newly created stream or NULL on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_new_stream"} {:args [{:spelling "st", :type "struct AVStream *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "data", :type "unsigned char *"} {:spelling "size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long], :symbol "av_stream_add_side_data", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_add_side_data, :raw-comment "/**\n * Wrap an existing array as stream side data.\n *\n * @param st stream\n * @param type side information type\n * @param data the side data array. It must be allocated with the av_malloc()\n *             family of functions. The ownership of the data is transferred to\n *             st.\n * @param size side information size\n * @return zero on success, a negative AVERROR code on failure. On failure,\n *         the stream is unchanged and the data remains owned by the caller.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_add_side_data"} {:args [{:spelling "stream", :type "struct AVStream *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "size", :type "int"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :coffi.mem/int :coffi.mem/int], :symbol "av_stream_new_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_new_side_data, :raw-comment "/**\n * Allocate new information from stream.\n *\n * @param stream stream\n * @param type desired side information type\n * @param size side information size\n * @return pointer to fresh allocated data or NULL otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_new_side_data"} {:args [{:spelling "stream", :type "const struct AVStream *"} {:spelling "type", :type "enum AVPacketSideDataType"} {:spelling "size", :type "int *"}], :ret {:spelling "unsigned char *"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_stream_get_side_data", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_side_data, :raw-comment "/**\n * Get side information from stream.\n *\n * @param stream stream\n * @param type desired side information type\n * @param size If supplied, *size will be set to the size of the side data\n *             or to zero if the desired side data is not present.\n * @return pointer to data if present or NULL otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_side_data"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "id", :type "int"}], :ret {:spelling "struct AVProgram *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int], :symbol "av_new_program", :function/ret [:coffi.mem/pointer :clong/AVProgram], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_new_program, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_new_program"} {:args [{:spelling "ctx", :type "struct AVFormatContext **"} {:spelling "oformat", :type "struct AVOutputFormat *"} {:spelling "format_name", :type "const char *"} {:spelling "filename", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFormatContext]] [:coffi.mem/pointer :clong/AVOutputFormat] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avformat_alloc_output_context2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_alloc_output_context2, :raw-comment "/**\n * Allocate an AVFormatContext for an output format.\n * avformat_free_context() can be used to free the context and\n * everything allocated by the framework within it.\n *\n * @param *ctx is set to the created format context, or to NULL in\n * case of failure\n * @param oformat format to use for allocating the context, if NULL\n * format_name and filename are used instead\n * @param format_name the name of output format to use for allocating the\n * context, if NULL filename is used instead\n * @param filename the name of the filename to use for allocating the\n * context, may be NULL\n * @return >= 0 in case of success, a negative AVERROR code in case of\n * failure\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_alloc_output_context2"} {:args [{:spelling "short_name", :type "const char *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_find_input_format", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_input_format, :raw-comment "/**\n * Find AVInputFormat based on the short name of the input format.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_input_format"} {:args [{:spelling "pd", :type "struct AVProbeData *"} {:spelling "is_opened", :type "int"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVProbeData] :coffi.mem/int], :symbol "av_probe_input_format", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_probe_input_format, :raw-comment "/**\n * Guess the file format.\n *\n * @param pd        data to be probed\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_probe_input_format"} {:args [{:spelling "pd", :type "struct AVProbeData *"} {:spelling "is_opened", :type "int"} {:spelling "score_max", :type "int *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVProbeData] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_probe_input_format2", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_probe_input_format2, :raw-comment "/**\n * Guess the file format.\n *\n * @param pd        data to be probed\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n * @param score_max A probe score larger that this is required to accept a\n *                  detection, the variable is set to the actual detection\n *                  score afterwards.\n *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended\n *                  to retry with a larger probe buffer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_probe_input_format2"} {:args [{:spelling "pd", :type "struct AVProbeData *"} {:spelling "is_opened", :type "int"} {:spelling "score_ret", :type "int *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVProbeData] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_probe_input_format3", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_probe_input_format3, :raw-comment "/**\n * Guess the file format.\n *\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n * @param score_ret The score of the best detection.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_probe_input_format3"} {:args [{:spelling "pb", :type "struct AVIOContext *"} {:spelling "fmt", :type "struct AVInputFormat **"} {:spelling "url", :type "const char *"} {:spelling "logctx", :type "void *"} {:spelling "offset", :type "unsigned int"} {:spelling "max_probe_size", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVInputFormat]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "av_probe_input_buffer2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_probe_input_buffer2, :raw-comment "/**\n * Probe a bytestream to determine the input format. Each time a probe returns\n * with a score that is too low, the probe buffer size is increased and another\n * attempt is made. When the maximum probe size is reached, the input format\n * with the highest score is returned.\n *\n * @param pb the bytestream to probe\n * @param fmt the input format is put here\n * @param url the url of the stream\n * @param logctx the log context\n * @param offset the offset within the bytestream to probe from\n * @param max_probe_size the maximum probe buffer size (zero for default)\n * @return the score in case of success, a negative value corresponding to an\n *         the maximal score is AVPROBE_SCORE_MAX\n * AVERROR code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_probe_input_buffer2"} {:args [{:spelling "pb", :type "struct AVIOContext *"} {:spelling "fmt", :type "struct AVInputFormat **"} {:spelling "url", :type "const char *"} {:spelling "logctx", :type "void *"} {:spelling "offset", :type "unsigned int"} {:spelling "max_probe_size", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVIOContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVInputFormat]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "av_probe_input_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_probe_input_buffer, :raw-comment "/**\n * Like av_probe_input_buffer2() but returns 0 on success\n */", :kind "CXCursor_FunctionDecl", :spelling "av_probe_input_buffer"} {:args [{:spelling "ps", :type "struct AVFormatContext **"} {:spelling "url", :type "const char *"} {:spelling "fmt", :type "struct AVInputFormat *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFormatContext]] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVInputFormat] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avformat_open_input", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_open_input, :raw-comment "/**\n * Open an input stream and read the header. The codecs are not opened.\n * The stream must be closed with avformat_close_input().\n *\n * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).\n *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this\n *           function and written into ps.\n *           Note that a user-supplied AVFormatContext will be freed on failure.\n * @param url URL of the stream to open.\n * @param fmt If non-NULL, this parameter forces a specific input format.\n *            Otherwise the format is autodetected.\n * @param options  A dictionary filled with AVFormatContext and demuxer-private options.\n *                 On return this parameter will be destroyed and replaced with a dict containing\n *                 options that were not found. May be NULL.\n *\n * @return 0 on success, a negative AVERROR on failure.\n *\n * @note If you want to use custom IO, preallocate the format context and set its pb field.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_open_input"} {:args [{:spelling "ic", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_demuxer_open", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_demuxer_open, :raw-comment "/**\n * @deprecated Use an AVDictionary to pass options to a demuxer.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_demuxer_open"} {:args [{:spelling "ic", :type "struct AVFormatContext *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avformat_find_stream_info", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_find_stream_info, :raw-comment "/**\n * Read packets of a media file to get stream information. This\n * is useful for file formats with no headers such as MPEG. This\n * function also computes the real framerate in case of MPEG-2 repeat\n * frame mode.\n * The logical file position is not changed by this function;\n * examined packets may be buffered for later processing.\n *\n * @param ic media file handle\n * @param options  If non-NULL, an ic.nb_streams long array of pointers to\n *                 dictionaries, where i-th member contains options for\n *                 codec corresponding to i-th stream.\n *                 On return each dictionary will be filled with options that were not found.\n * @return >=0 if OK, AVERROR_xxx on error\n *\n * @note this function isn't guaranteed to open all the codecs, so\n *       options being non-empty at return is a perfectly normal behavior.\n *\n * @todo Let the user decide somehow what information is needed so that\n *       we do not waste time getting stuff the user does not need.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_find_stream_info"} {:args [{:spelling "ic", :type "struct AVFormatContext *"} {:spelling "last", :type "struct AVProgram *"} {:spelling "s", :type "int"}], :ret {:spelling "struct AVProgram *"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVProgram] :coffi.mem/int], :symbol "av_find_program_from_stream", :function/ret [:coffi.mem/pointer :clong/AVProgram], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_program_from_stream, :raw-comment "/**\n * Find the programs which belong to a given stream.\n *\n * @param ic    media file handle\n * @param last  the last found program, the search will start after this\n *              program, or from the beginning if it is NULL\n * @param s     stream index\n * @return the next program which belongs to s, NULL if no program is found or\n *         the last program is not among the programs of ic.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_program_from_stream"} {:args [{:spelling "ac", :type "struct AVFormatContext *"} {:spelling "progid", :type "int"} {:spelling "idx", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/int], :symbol "av_program_add_stream_index", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_program_add_stream_index, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_program_add_stream_index"} {:args [{:spelling "ic", :type "struct AVFormatContext *"} {:spelling "type", :type "enum AVMediaType"} {:spelling "wanted_stream_nb", :type "int"} {:spelling "related_stream", :type "int"} {:spelling "decoder_ret", :type "struct AVCodec **"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodec]] :coffi.mem/int], :symbol "av_find_best_stream", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_best_stream, :raw-comment "/**\n * Find the \"best\" stream in the file.\n * The best stream is determined according to various heuristics as the most\n * likely to be what the user expects.\n * If the decoder parameter is non-NULL, av_find_best_stream will find the\n * default decoder for the stream's codec; streams for which no decoder can\n * be found are ignored.\n *\n * @param ic                media file handle\n * @param type              stream type: video, audio, subtitles, etc.\n * @param wanted_stream_nb  user-requested stream number,\n *                          or -1 for automatic selection\n * @param related_stream    try to find a stream related (eg. in the same\n *                          program) to this one, or -1 if none\n * @param decoder_ret       if non-NULL, returns the decoder for the\n *                          selected stream\n * @param flags             flags; none are currently defined\n * @return  the non-negative stream number in case of success,\n *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type\n *          could be found,\n *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder\n * @note  If av_find_best_stream returns successfully and decoder_ret is not\n *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_find_best_stream"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_read_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_read_frame, :raw-comment "/**\n * Return the next frame of a stream.\n * This function returns what is stored in the file, and does not validate\n * that what is there are valid frames for the decoder. It will split what is\n * stored in the file into frames and return one for each call. It will not\n * omit invalid data between valid frames so as to give the decoder the maximum\n * information possible for decoding.\n *\n * On success, the returned packet is reference-counted (pkt->buf is set) and\n * valid indefinitely. The packet must be freed with av_packet_unref() when\n * it is no longer needed. For video, the packet contains exactly one frame.\n * For audio, it contains an integer number of frames if each frame has\n * a known fixed size (e.g. PCM or ADPCM data). If the audio frames have\n * a variable size (e.g. MPEG audio), then it contains one frame.\n *\n * pkt->pts, pkt->dts and pkt->duration are always set to correct\n * values in AVStream.time_base units (and guessed if the format cannot\n * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format\n * has B-frames, so it is better to rely on pkt->dts if you do not\n * decompress the payload.\n *\n * @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank\n *         (as if it came from av_packet_alloc()).\n *\n * @note pkt will be initialized, so it may be uninitialized, but it must not\n *       contain data that needs to be freed.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_read_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream_index", :type "int"} {:spelling "timestamp", :type "long long"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/long :coffi.mem/int], :symbol "av_seek_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_seek_frame, :raw-comment "/**\n * Seek to the keyframe at timestamp.\n * 'timestamp' in 'stream_index'.\n *\n * @param s media file handle\n * @param stream_index If stream_index is (-1), a default\n * stream is selected, and timestamp is automatically converted\n * from AV_TIME_BASE units to the stream specific time_base.\n * @param timestamp Timestamp in AVStream.time_base units\n *        or, if no stream is specified, in AV_TIME_BASE units.\n * @param flags flags which select direction and seeking mode\n * @return >= 0 on success\n */", :kind "CXCursor_FunctionDecl", :spelling "av_seek_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream_index", :type "int"} {:spelling "min_ts", :type "long long"} {:spelling "ts", :type "long long"} {:spelling "max_ts", :type "long long"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/long :coffi.mem/long :coffi.mem/long :coffi.mem/int], :symbol "avformat_seek_file", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_seek_file, :raw-comment "/**\n * Seek to timestamp ts.\n * Seeking will be done so that the point from which all active streams\n * can be presented successfully will be closest to ts and within min/max_ts.\n * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.\n *\n * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and\n * are the file position (this may not be supported by all demuxers).\n * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames\n * in the stream with stream_index (this may not be supported by all demuxers).\n * Otherwise all timestamps are in units of the stream selected by stream_index\n * or if stream_index is -1, in AV_TIME_BASE units.\n * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as\n * keyframes (this may not be supported by all demuxers).\n * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.\n *\n * @param s media file handle\n * @param stream_index index of the stream which is used as time base reference\n * @param min_ts smallest acceptable timestamp\n * @param ts target timestamp\n * @param max_ts largest acceptable timestamp\n * @param flags flags\n * @return >=0 on success, error code otherwise\n *\n * @note This is part of the new seek API which is still under construction.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_seek_file"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "avformat_flush", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_flush, :raw-comment "/**\n * Discard all internally buffered data. This can be useful when dealing with\n * discontinuities in the byte stream. Generally works only with formats that\n * can resync. This includes headerless formats like MPEG-TS/TS but should also\n * work with NUT, Ogg and in a limited way AVI for example.\n *\n * The set of streams, the detected duration, stream parameters and codecs do\n * not change when calling this function. If you want a complete reset, it's\n * better to open a new AVFormatContext.\n *\n * This does not flush the AVIOContext (s->pb). If necessary, call\n * avio_flush(s->pb) before calling this function.\n *\n * @param s media file handle\n * @return >=0 on success, error code otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_flush"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_read_play", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_read_play, :raw-comment "/**\n * Start playing a network-based stream (e.g. RTSP stream) at the\n * current position.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_read_play"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_read_pause", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_read_pause, :raw-comment "/**\n * Pause a network-based stream (e.g. RTSP stream).\n *\n * Use av_read_play() to resume it.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_read_pause"} {:args [{:spelling "s", :type "struct AVFormatContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFormatContext]]], :symbol "avformat_close_input", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_close_input, :raw-comment "/**\n * Close an opened input AVFormatContext. Free it and all its contents\n * and set *s to NULL.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_close_input"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avformat_write_header", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_write_header, :raw-comment "/**\n * Allocate the stream private data and write the stream header to\n * an output media file.\n *\n * @param s Media file handle, must be allocated with avformat_alloc_context().\n *          Its oformat field must be set to the desired output format;\n *          Its pb field must be set to an already opened AVIOContext.\n * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n *                 On return this parameter will be destroyed and replaced with a dict containing\n *                 options that were not found. May be NULL.\n *\n * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,\n *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,\n *         negative AVERROR on failure.\n *\n * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_write_header"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avformat_init_output", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_init_output, :raw-comment "/**\n * Allocate the stream private data and initialize the codec, but do not write the header.\n * May optionally be used before avformat_write_header to initialize stream parameters\n * before actually writing the header.\n * If using this function, do not pass the same options to avformat_write_header.\n *\n * @param s Media file handle, must be allocated with avformat_alloc_context().\n *          Its oformat field must be set to the desired output format;\n *          Its pb field must be set to an already opened AVIOContext.\n * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.\n *                 On return this parameter will be destroyed and replaced with a dict containing\n *                 options that were not found. May be NULL.\n *\n * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,\n *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,\n *         negative AVERROR on failure.\n *\n * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_init_output"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_write_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_frame, :raw-comment "/**\n * Write a packet to an output media file.\n *\n * This function passes the packet directly to the muxer, without any buffering\n * or reordering. The caller is responsible for correctly interleaving the\n * packets if the format requires it. Callers that want libavformat to handle\n * the interleaving should call av_interleaved_write_frame() instead of this\n * function.\n *\n * @param s media file handle\n * @param pkt The packet containing the data to be written. Note that unlike\n *            av_interleaved_write_frame(), this function does not take\n *            ownership of the packet passed to it (though some muxers may make\n *            an internal reference to the input packet).\n *            <br>\n *            This parameter can be NULL (at any time, not just at the end), in\n *            order to immediately flush data buffered within the muxer, for\n *            muxers that buffer up data internally before writing it to the\n *            output.\n *            <br>\n *            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n *            set to the index of the corresponding stream in @ref\n *            AVFormatContext.streams \"s->streams\".\n *            <br>\n *            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n *            must be set to correct values in the stream's timebase (unless the\n *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n *            they can be set to AV_NOPTS_VALUE).\n *            The dts for subsequent packets passed to this function must be strictly\n *            increasing when compared in their respective timebases (unless the\n *            output format is flagged with the AVFMT_TS_NONSTRICT, then they\n *            merely have to be nondecreasing).  @ref AVPacket.duration\n *            \"duration\") should also be set if known.\n * @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush\n *\n * @see av_interleaved_write_frame()\n */", :kind "CXCursor_FunctionDecl", :spelling "av_write_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "pkt", :type "struct AVPacket *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]], :symbol "av_interleaved_write_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_interleaved_write_frame, :raw-comment "/**\n * Write a packet to an output media file ensuring correct interleaving.\n *\n * This function will buffer the packets internally as needed to make sure the\n * packets in the output file are properly interleaved in the order of\n * increasing dts. Callers doing their own interleaving should call\n * av_write_frame() instead of this function.\n *\n * Using this function instead of av_write_frame() can give muxers advance\n * knowledge of future packets, improving e.g. the behaviour of the mp4\n * muxer for VFR content in fragmenting mode.\n *\n * @param s media file handle\n * @param pkt The packet containing the data to be written.\n *            <br>\n *            If the packet is reference-counted, this function will take\n *            ownership of this reference and unreference it later when it sees\n *            fit.\n *            The caller must not access the data through this reference after\n *            this function returns. If the packet is not reference-counted,\n *            libavformat will make a copy.\n *            <br>\n *            This parameter can be NULL (at any time, not just at the end), to\n *            flush the interleaving queues.\n *            <br>\n *            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n *            set to the index of the corresponding stream in @ref\n *            AVFormatContext.streams \"s->streams\".\n *            <br>\n *            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n *            must be set to correct values in the stream's timebase (unless the\n *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n *            they can be set to AV_NOPTS_VALUE).\n *            The dts for subsequent packets in one stream must be strictly\n *            increasing (unless the output format is flagged with the\n *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).\n *            @ref AVPacket.duration \"duration\") should also be set if known.\n *\n * @return 0 on success, a negative AVERROR on error. Libavformat will always\n *         take care of freeing the packet, even if this function fails.\n *\n * @see av_write_frame(), AVFormatContext.max_interleave_delta\n */", :kind "CXCursor_FunctionDecl", :spelling "av_interleaved_write_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream_index", :type "int"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_write_uncoded_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_uncoded_frame, :raw-comment "/**\n * Write an uncoded frame to an output media file.\n *\n * The frame must be correctly interleaved according to the container\n * specification; if not, av_interleaved_write_uncoded_frame() must be used.\n *\n * See av_interleaved_write_uncoded_frame() for details.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_write_uncoded_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream_index", :type "int"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_interleaved_write_uncoded_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_interleaved_write_uncoded_frame, :raw-comment "/**\n * Write an uncoded frame to an output media file.\n *\n * If the muxer supports it, this function makes it possible to write an AVFrame\n * structure directly, without encoding it into a packet.\n * It is mostly useful for devices and similar special muxers that use raw\n * video or PCM data and will not serialize it into a byte stream.\n *\n * To test whether it is possible to use it with a given muxer and stream,\n * use av_write_uncoded_frame_query().\n *\n * The caller gives up ownership of the frame and must not access it\n * afterwards.\n *\n * @return  >=0 for success, a negative code on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_interleaved_write_uncoded_frame"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream_index", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int], :symbol "av_write_uncoded_frame_query", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_uncoded_frame_query, :raw-comment "/**\n * Test whether a muxer supports uncoded frame.\n *\n * @return  >=0 if an uncoded frame can be written to that muxer and stream,\n *          <0 if not\n */", :kind "CXCursor_FunctionDecl", :spelling "av_write_uncoded_frame_query"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_write_trailer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_write_trailer, :raw-comment "/**\n * Write the stream trailer to an output media file and free the\n * file private data.\n *\n * May only be called after a successful call to avformat_write_header.\n *\n * @param s media file handle\n * @return 0 if OK, AVERROR_xxx on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_write_trailer"} {:args [{:spelling "short_name", :type "const char *"} {:spelling "filename", :type "const char *"} {:spelling "mime_type", :type "const char *"}], :ret {:spelling "struct AVOutputFormat *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_guess_format", :function/ret [:coffi.mem/pointer :clong/AVOutputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_guess_format, :raw-comment "/**\n * Return the output format in the list of registered output formats\n * which best matches the provided parameters, or return NULL if\n * there is no match.\n *\n * @param short_name if non-NULL checks if short_name matches with the\n * names of the registered formats\n * @param filename if non-NULL checks if filename terminates with the\n * extensions of the registered formats\n * @param mime_type if non-NULL checks if mime_type matches with the\n * MIME type of the registered formats\n */", :kind "CXCursor_FunctionDecl", :spelling "av_guess_format"} {:args [{:spelling "fmt", :type "struct AVOutputFormat *"} {:spelling "short_name", :type "const char *"} {:spelling "filename", :type "const char *"} {:spelling "mime_type", :type "const char *"} {:spelling "type", :type "enum AVMediaType"}], :ret {:spelling "enum AVCodecID"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_guess_codec", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_guess_codec, :raw-comment "/**\n * Guess the codec ID based upon muxer and filename.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_guess_codec"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "stream", :type "int"} {:spelling "dts", :type "long long *"} {:spelling "wall", :type "long long *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/long]], :symbol "av_get_output_timestamp", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_output_timestamp, :raw-comment "/**\n * Get timing information for the data currently output.\n * The exact meaning of \"currently output\" depends on the format.\n * It is mostly relevant for devices that have an internal buffer and/or\n * work in real time.\n * @param s          media file handle\n * @param stream     stream in the media file\n * @param[out] dts   DTS of the last packet output for the stream, in stream\n *                   time_base units\n * @param[out] wall  absolute time when that packet whas output,\n *                   in microsecond\n * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it\n * Note: some formats or devices may not allow to measure dts and wall\n * atomically.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_output_timestamp"} {:args [{:spelling "f", :type "struct __sFILE *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/__sFILE] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hex_dump", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hex_dump, :raw-comment "/**\n * Send a nice hexadecimal dump of a buffer to the specified file stream.\n *\n * @param f The file stream pointer where the dump should be sent to.\n * @param buf buffer\n * @param size buffer size\n *\n * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hex_dump"} {:args [{:spelling "avcl", :type "void *"} {:spelling "level", :type "int"} {:spelling "buf", :type "const unsigned char *"} {:spelling "size", :type "int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_hex_dump_log", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_hex_dump_log, :raw-comment "/**\n * Send a nice hexadecimal dump of a buffer to the log.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n * pointer to an AVClass struct.\n * @param level The importance level of the message, lower values signifying\n * higher importance.\n * @param buf buffer\n * @param size buffer size\n *\n * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2\n */", :kind "CXCursor_FunctionDecl", :spelling "av_hex_dump_log"} {:args [{:spelling "f", :type "struct __sFILE *"} {:spelling "pkt", :type "const struct AVPacket *"} {:spelling "dump_payload", :type "int"} {:spelling "st", :type "const struct AVStream *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/__sFILE] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int [:coffi.mem/pointer :clong/AVStream]], :symbol "av_pkt_dump2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pkt_dump2, :raw-comment "/**\n * Send a nice dump of a packet to the specified file stream.\n *\n * @param f The file stream pointer where the dump should be sent to.\n * @param pkt packet to dump\n * @param dump_payload True if the payload must be displayed, too.\n * @param st AVStream that the packet belongs to\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pkt_dump2"} {:args [{:spelling "avcl", :type "void *"} {:spelling "level", :type "int"} {:spelling "pkt", :type "const struct AVPacket *"} {:spelling "dump_payload", :type "int"} {:spelling "st", :type "const struct AVStream *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int [:coffi.mem/pointer :clong/AVStream]], :symbol "av_pkt_dump_log2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_pkt_dump_log2, :raw-comment "/**\n * Send a nice dump of a packet to the log.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n * pointer to an AVClass struct.\n * @param level The importance level of the message, lower values signifying\n * higher importance.\n * @param pkt packet to dump\n * @param dump_payload True if the payload must be displayed, too.\n * @param st AVStream that the packet belongs to\n */", :kind "CXCursor_FunctionDecl", :spelling "av_pkt_dump_log2"} {:args [{:spelling "tags", :type "const struct AVCodecTag *const *"} {:spelling "tag", :type "unsigned int"}], :ret {:spelling "enum AVCodecID"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecTag]] :coffi.mem/int], :symbol "av_codec_get_id", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_id, :raw-comment "/**\n * Get the AVCodecID for the given codec tag tag.\n * If no codec id is found returns AV_CODEC_ID_NONE.\n *\n * @param tags list of supported codec_id-codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param tag  codec tag to match to a codec ID\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_id"} {:args [{:spelling "tags", :type "const struct AVCodecTag *const *"} {:spelling "id", :type "enum AVCodecID"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecTag]] :coffi.mem/int], :symbol "av_codec_get_tag", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_tag, :raw-comment "/**\n * Get the codec tag for the given codec id id.\n * If no codec tag is found returns 0.\n *\n * @param tags list of supported codec_id-codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param id   codec ID to match to a codec tag\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_tag"} {:args [{:spelling "tags", :type "const struct AVCodecTag *const *"} {:spelling "id", :type "enum AVCodecID"} {:spelling "tag", :type "unsigned int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecTag]] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_codec_get_tag2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_codec_get_tag2, :raw-comment "/**\n * Get the codec tag for the given codec id.\n *\n * @param tags list of supported codec_id - codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param id codec id that should be searched for in the list\n * @param tag A pointer to the found tag\n * @return 0 if id was not found in tags, > 0 if it was found\n */", :kind "CXCursor_FunctionDecl", :spelling "av_codec_get_tag2"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "av_find_default_stream_index", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_find_default_stream_index, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_find_default_stream_index"} {:args [{:spelling "st", :type "struct AVStream *"} {:spelling "timestamp", :type "long long"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :coffi.mem/long :coffi.mem/int], :symbol "av_index_search_timestamp", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_index_search_timestamp, :raw-comment "/**\n * Get the index for a specific timestamp.\n *\n * @param st        stream that the timestamp belongs to\n * @param timestamp timestamp to retrieve the index for\n * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond\n *                 to the timestamp which is <= the requested one, if backward\n *                 is 0, then it will be >=\n *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise\n * @return < 0 if no such timestamp could be found\n */", :kind "CXCursor_FunctionDecl", :spelling "av_index_search_timestamp"} {:args [{:spelling "st", :type "struct AVStream *"} {:spelling "pos", :type "long long"} {:spelling "timestamp", :type "long long"} {:spelling "size", :type "int"} {:spelling "distance", :type "int"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVStream] :coffi.mem/long :coffi.mem/long :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_add_index_entry", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_add_index_entry, :raw-comment "/**\n * Add an index entry into a sorted list. Update the entry if the list\n * already contains it.\n *\n * @param timestamp timestamp in the time base of the given stream\n */", :kind "CXCursor_FunctionDecl", :spelling "av_add_index_entry"} {:args [{:spelling "proto", :type "char *"} {:spelling "proto_size", :type "int"} {:spelling "authorization", :type "char *"} {:spelling "authorization_size", :type "int"} {:spelling "hostname", :type "char *"} {:spelling "hostname_size", :type "int"} {:spelling "port_ptr", :type "int *"} {:spelling "path", :type "char *"} {:spelling "path_size", :type "int"} {:spelling "url", :type "const char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_url_split", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_url_split, :raw-comment "/**\n * Split a URL string into components.\n *\n * The pointers to buffers for storing individual components may be null,\n * in order to ignore that component. Buffers for components not found are\n * set to empty strings. If the port is not found, it is set to a negative\n * value.\n *\n * @param proto the buffer for the protocol\n * @param proto_size the size of the proto buffer\n * @param authorization the buffer for the authorization\n * @param authorization_size the size of the authorization buffer\n * @param hostname the buffer for the host name\n * @param hostname_size the size of the hostname buffer\n * @param port_ptr a pointer to store the port number in\n * @param path the buffer for the path\n * @param path_size the size of the path buffer\n * @param url the URL to split\n */", :kind "CXCursor_FunctionDecl", :spelling "av_url_split"} {:args [{:spelling "ic", :type "struct AVFormatContext *"} {:spelling "index", :type "int"} {:spelling "url", :type "const char *"} {:spelling "is_output", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_dump_format", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dump_format, :raw-comment "/**\n * Print detailed information about the input or output format, such as\n * duration, bitrate, streams, container, programs, metadata, side data,\n * codec and time base.\n *\n * @param ic        the context to analyze\n * @param index     index of the stream to dump information about\n * @param url       the URL to print, such as source or destination file\n * @param is_output Select whether the specified context is an input(0) or output(1)\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dump_format"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "path", :type "const char *"} {:spelling "number", :type "int"} {:spelling "flags", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int], :symbol "av_get_frame_filename2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_frame_filename2, :raw-comment "/**\n * Return in 'buf' the path with '%d' replaced by a number.\n *\n * Also handles the '%0nd' format where 'n' is the total number\n * of digits and '%%'.\n *\n * @param buf destination buffer\n * @param buf_size destination buffer size\n * @param path numbered sequence string\n * @param number frame number\n * @param flags AV_FRAME_FILENAME_FLAGS_*\n * @return 0 if OK, -1 on format error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_get_frame_filename2"} {:args [{:spelling "buf", :type "char *"} {:spelling "buf_size", :type "int"} {:spelling "path", :type "const char *"} {:spelling "number", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_get_frame_filename", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_get_frame_filename, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_get_frame_filename"} {:args [{:spelling "filename", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "av_filename_number_test", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_filename_number_test, :raw-comment "/**\n * Check whether filename actually is a numbered sequence generator.\n *\n * @param filename possible numbered sequence string\n * @return 1 if a valid numbered sequence string, 0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_filename_number_test"} {:args [{:spelling "ac", :type "struct AVFormatContext *[]"} {:spelling "n_files", :type "int"} {:spelling "buf", :type "char *"} {:spelling "size", :type "int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_sdp_create", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_sdp_create, :raw-comment "/**\n * Generate an SDP for an RTP session.\n *\n * Note, this overwrites the id values of AVStreams in the muxer contexts\n * for getting unique dynamic payload types.\n *\n * @param ac array of AVFormatContexts describing the RTP streams. If the\n *           array is composed by only one context, such context can contain\n *           multiple AVStreams (one AVStream per RTP stream). Otherwise,\n *           all the contexts in the array (an AVCodecContext per RTP stream)\n *           must contain only one AVStream.\n * @param n_files number of AVCodecContexts contained in ac\n * @param buf buffer where the SDP will be stored (must be allocated by\n *            the caller)\n * @param size the size of the buffer\n * @return 0 if OK, AVERROR_xxx on error\n */", :kind "CXCursor_FunctionDecl", :spelling "av_sdp_create"} {:args [{:spelling "filename", :type "const char *"} {:spelling "extensions", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_match_ext", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_match_ext, :raw-comment "/**\n * Return a positive value if the given filename has one of the given\n * extensions, 0 otherwise.\n *\n * @param filename   file name to check against the given extensions\n * @param extensions a comma-separated list of filename extensions\n */", :kind "CXCursor_FunctionDecl", :spelling "av_match_ext"} {:args [{:spelling "ofmt", :type "const struct AVOutputFormat *"} {:spelling "codec_id", :type "enum AVCodecID"} {:spelling "std_compliance", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat] :coffi.mem/int :coffi.mem/int], :symbol "avformat_query_codec", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_query_codec, :raw-comment "/**\n * Test if the given container can store a codec.\n *\n * @param ofmt           container to check for compatibility\n * @param codec_id       codec to potentially store in container\n * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*\n *\n * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.\n *         A negative number if this information is not available.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_query_codec"} {:args [], :ret {:spelling "const struct AVCodecTag *"}, :function/args [], :symbol "avformat_get_riff_video_tags", :function/ret [:coffi.mem/pointer :clong/AVCodecTag], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_get_riff_video_tags, :raw-comment "/**\n * @defgroup riff_fourcc RIFF FourCCs\n * @{\n * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are\n * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the\n * following code:\n * @code\n * uint32_t tag = MKTAG('H', '2', '6', '4');\n * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };\n * enum AVCodecID id = av_codec_get_id(table, tag);\n * @endcode\n */\n/**\n * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_get_riff_video_tags"} {:args [], :ret {:spelling "const struct AVCodecTag *"}, :function/args [], :symbol "avformat_get_riff_audio_tags", :function/ret [:coffi.mem/pointer :clong/AVCodecTag], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_get_riff_audio_tags, :raw-comment "/**\n * @return the table mapping RIFF FourCCs for audio to AVCodecID.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_get_riff_audio_tags"} {:args [], :ret {:spelling "const struct AVCodecTag *"}, :function/args [], :symbol "avformat_get_mov_video_tags", :function/ret [:coffi.mem/pointer :clong/AVCodecTag], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_get_mov_video_tags, :raw-comment "/**\n * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_get_mov_video_tags"} {:args [], :ret {:spelling "const struct AVCodecTag *"}, :function/args [], :symbol "avformat_get_mov_audio_tags", :function/ret [:coffi.mem/pointer :clong/AVCodecTag], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_get_mov_audio_tags, :raw-comment "/**\n * @return the table mapping MOV FourCCs for audio to AVCodecID.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_get_mov_audio_tags"} {:args [{:spelling "format", :type "struct AVFormatContext *"} {:spelling "stream", :type "struct AVStream *"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVStream] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_guess_sample_aspect_ratio", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_guess_sample_aspect_ratio, :raw-comment "/**\n * Guess the sample aspect ratio of a frame, based on both the stream and the\n * frame aspect ratio.\n *\n * Since the frame aspect ratio is set by the codec but the stream aspect ratio\n * is set by the demuxer, these two may not be equal. This function tries to\n * return the value that you should use if you would like to display the frame.\n *\n * Basic logic is to use the stream aspect ratio if it is set to something sane\n * otherwise use the frame aspect ratio. This way a container setting, which is\n * usually easy to modify can override the coded value in the frames.\n *\n * @param format the format context which the stream is part of\n * @param stream the stream which the frame is part of\n * @param frame the frame with the aspect ratio to be determined\n * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea\n */", :kind "CXCursor_FunctionDecl", :spelling "av_guess_sample_aspect_ratio"} {:args [{:spelling "ctx", :type "struct AVFormatContext *"} {:spelling "stream", :type "struct AVStream *"} {:spelling "frame", :type "struct AVFrame *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVStream] [:coffi.mem/pointer :clong/AVFrame]], :symbol "av_guess_frame_rate", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_guess_frame_rate, :raw-comment "/**\n * Guess the frame rate, based on both the container and codec information.\n *\n * @param ctx the format context which the stream is part of\n * @param stream the stream which the frame is part of\n * @param frame the frame for which the frame rate should be determined, may be NULL\n * @return the guessed (valid) frame rate, 0/1 if no idea\n */", :kind "CXCursor_FunctionDecl", :spelling "av_guess_frame_rate"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "st", :type "struct AVStream *"} {:spelling "spec", :type "const char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVStream] [:coffi.mem/pointer :coffi.mem/char]], :symbol "avformat_match_stream_specifier", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_match_stream_specifier, :raw-comment "/**\n * Check if the stream st contained in s is matched by the stream specifier\n * spec.\n *\n * See the \"stream specifiers\" chapter in the documentation for the syntax\n * of spec.\n *\n * @return  >0 if st is matched by spec;\n *          0  if st is not matched by spec;\n *          AVERROR code if spec is invalid\n *\n * @note  A stream specifier can match several streams in the format.\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_match_stream_specifier"} {:args [{:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext]], :symbol "avformat_queue_attached_pictures", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_queue_attached_pictures, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avformat_queue_attached_pictures"} {:args [{:spelling "codec", :type "struct AVCodecContext *"} {:spelling "pkt", :type "struct AVPacket *"} {:spelling "bsfc", :type "struct AVBitStreamFilterContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVBitStreamFilterContext]], :symbol "av_apply_bitstream_filters", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_apply_bitstream_filters, :raw-comment "/**\n * Apply a list of bitstream filters to a packet.\n *\n * @param codec AVCodecContext, usually from an AVStream\n * @param pkt the packet to apply filters to. If, on success, the returned\n *        packet has size == 0 and side_data_elems == 0, it indicates that\n *        the packet should be dropped\n * @param bsfc a NULL-terminated list of filters to apply\n * @return  >=0 on success;\n *          AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_apply_bitstream_filters"} {:args [{:spelling "ofmt", :type "const struct AVOutputFormat *"} {:spelling "ost", :type "struct AVStream *"} {:spelling "ist", :type "const struct AVStream *"} {:spelling "copy_tb", :type "enum AVTimebaseSource"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat] [:coffi.mem/pointer :clong/AVStream] [:coffi.mem/pointer :clong/AVStream] :coffi.mem/int], :symbol "avformat_transfer_internal_stream_timing_info", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avformat_transfer_internal_stream_timing_info, :raw-comment "/**\n * Transfer internal timing information from one stream to another.\n *\n * This function is useful when doing stream copy.\n *\n * @param ofmt     target output format for ost\n * @param ost      output stream which needs timings copy and adjustments\n * @param ist      reference input stream to copy timings from\n * @param copy_tb  define from where the stream codec timebase needs to be imported\n */", :kind "CXCursor_FunctionDecl", :spelling "avformat_transfer_internal_stream_timing_info"} {:args [{:spelling "st", :type "const struct AVStream *"}], :ret {:spelling "struct AVRational"}, :function/args [[:coffi.mem/pointer :clong/AVStream]], :symbol "av_stream_get_codec_timebase", :function/ret :clong/AVRational, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_stream_get_codec_timebase, :raw-comment "/**\n * Get the internal codec timebase from a stream.\n *\n * @param st  input stream to extract the timebase from\n */", :kind "CXCursor_FunctionDecl", :spelling "av_stream_get_codec_timebase"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "avdevice_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_version, :raw-comment "/**\n * Return the LIBAVDEVICE_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avdevice_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_configuration, :raw-comment "/**\n * Return the libavdevice build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "avdevice_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_license, :raw-comment "/**\n * Return the libavdevice license.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_license"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "avdevice_register_all", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_register_all, :raw-comment "/**\n * Initialize libavdevice and register all the input and output devices.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_register_all"} {:args [{:spelling "d", :type "struct AVInputFormat *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVInputFormat]], :symbol "av_input_audio_device_next", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_input_audio_device_next, :raw-comment "/**\n * Audio input devices iterator.\n *\n * If d is NULL, returns the first registered input audio/video device,\n * if d is non-NULL, returns the next registered input audio/video device after d\n * or NULL if d is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_input_audio_device_next"} {:args [{:spelling "d", :type "struct AVInputFormat *"}], :ret {:spelling "struct AVInputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVInputFormat]], :symbol "av_input_video_device_next", :function/ret [:coffi.mem/pointer :clong/AVInputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_input_video_device_next, :raw-comment "/**\n * Video input devices iterator.\n *\n * If d is NULL, returns the first registered input audio/video device,\n * if d is non-NULL, returns the next registered input audio/video device after d\n * or NULL if d is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_input_video_device_next"} {:args [{:spelling "d", :type "struct AVOutputFormat *"}], :ret {:spelling "struct AVOutputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat]], :symbol "av_output_audio_device_next", :function/ret [:coffi.mem/pointer :clong/AVOutputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_output_audio_device_next, :raw-comment "/**\n * Audio output devices iterator.\n *\n * If d is NULL, returns the first registered output audio/video device,\n * if d is non-NULL, returns the next registered output audio/video device after d\n * or NULL if d is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_output_audio_device_next"} {:args [{:spelling "d", :type "struct AVOutputFormat *"}], :ret {:spelling "struct AVOutputFormat *"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat]], :symbol "av_output_video_device_next", :function/ret [:coffi.mem/pointer :clong/AVOutputFormat], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_output_video_device_next, :raw-comment "/**\n * Video output devices iterator.\n *\n * If d is NULL, returns the first registered output audio/video device,\n * if d is non-NULL, returns the next registered output audio/video device after d\n * or NULL if d is the last one.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_output_video_device_next"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "type", :type "enum AVAppToDevMessageType"} {:spelling "data", :type "void *"} {:spelling "data_size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long], :symbol "avdevice_app_to_dev_control_message", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_app_to_dev_control_message, :raw-comment "/**\n * Send control message from application to device.\n *\n * @param s         device context.\n * @param type      message type.\n * @param data      message data. Exact type depends on message type.\n * @param data_size size of message data.\n * @return >= 0 on success, negative on error.\n *         AVERROR(ENOSYS) when device doesn't implement handler of the message.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_app_to_dev_control_message"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "type", :type "enum AVDevToAppMessageType"} {:spelling "data", :type "void *"} {:spelling "data_size", :type "unsigned long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long], :symbol "avdevice_dev_to_app_control_message", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_dev_to_app_control_message, :raw-comment "/**\n * Send control message from device to application.\n *\n * @param s         device context.\n * @param type      message type.\n * @param data      message data. Can be NULL.\n * @param data_size size of message data.\n * @return >= 0 on success, negative on error.\n *         AVERROR(ENOSYS) when application doesn't implement handler of the message.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_dev_to_app_control_message"} {:args [{:spelling "caps", :type "struct AVDeviceCapabilitiesQuery **"} {:spelling "s", :type "struct AVFormatContext *"} {:spelling "device_options", :type "struct AVDictionary **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] [:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]], :symbol "avdevice_capabilities_create", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_capabilities_create, :raw-comment "/**\n * Initialize capabilities probing API based on AVOption API.\n *\n * avdevice_capabilities_free() must be called when query capabilities API is\n * not used anymore.\n *\n * @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.\n * @param s              Context of the device.\n * @param device_options An AVDictionary filled with device-private options.\n *                       On return this parameter will be destroyed and replaced with a dict\n *                       containing options that were not found. May be NULL.\n *                       The same options must be passed later to avformat_write_header() for output\n *                       devices or avformat_open_input() for input devices, or at any other place\n *                       that affects device-private options.\n *\n * @return >= 0 on success, negative otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_capabilities_create"} {:args [{:spelling "caps", :type "struct AVDeviceCapabilitiesQuery **"} {:spelling "s", :type "struct AVFormatContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] [:coffi.mem/pointer :clong/AVFormatContext]], :symbol "avdevice_capabilities_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_capabilities_free, :raw-comment "/**\n * Free resources created by avdevice_capabilities_create()\n *\n * @param caps Device capabilities data to be freed.\n * @param s    Context of the device.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_capabilities_free"} {:args [{:spelling "s", :type "struct AVFormatContext *"} {:spelling "device_list", :type "struct AVDeviceInfoList **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceInfoList]]], :symbol "avdevice_list_devices", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_list_devices, :raw-comment "/**\n * List devices.\n *\n * Returns available device names and their parameters.\n *\n * @note: Some devices may accept system-dependent device names that cannot be\n *        autodetected. The list returned by this function cannot be assumed to\n *        be always completed.\n *\n * @param s                device context.\n * @param[out] device_list list of autodetected devices.\n * @return count of autodetected devices, negative on error.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_list_devices"} {:args [{:spelling "device_list", :type "struct AVDeviceInfoList **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceInfoList]]], :symbol "avdevice_free_list_devices", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_free_list_devices, :raw-comment "/**\n * Convenient function to free result of avdevice_list_devices().\n *\n * @param devices device list to be freed.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_free_list_devices"} {:args [{:spelling "device", :type "struct AVInputFormat *"} {:spelling "device_name", :type "const char *"} {:spelling "device_options", :type "struct AVDictionary *"} {:spelling "device_list", :type "struct AVDeviceInfoList **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVInputFormat] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVDictionary] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceInfoList]]], :symbol "avdevice_list_input_sources", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_list_input_sources, :raw-comment "/**\n * List devices.\n *\n * Returns available device names and their parameters.\n * These are convinient wrappers for avdevice_list_devices().\n * Device context is allocated and deallocated internally.\n *\n * @param device           device format. May be NULL if device name is set.\n * @param device_name      device name. May be NULL if device format is set.\n * @param device_options   An AVDictionary filled with device-private options. May be NULL.\n *                         The same options must be passed later to avformat_write_header() for output\n *                         devices or avformat_open_input() for input devices, or at any other place\n *                         that affects device-private options.\n * @param[out] device_list list of autodetected devices\n * @return count of autodetected devices, negative on error.\n * @note device argument takes precedence over device_name when both are set.\n */", :kind "CXCursor_FunctionDecl", :spelling "avdevice_list_input_sources"} {:args [{:spelling "device", :type "struct AVOutputFormat *"} {:spelling "device_name", :type "const char *"} {:spelling "device_options", :type "struct AVDictionary *"} {:spelling "device_list", :type "struct AVDeviceInfoList **"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVOutputFormat] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :clong/AVDictionary] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceInfoList]]], :symbol "avdevice_list_output_sinks", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avdevice_list_output_sinks, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avdevice_list_output_sinks"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "swr_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_get_class, :raw-comment "/**\n * Get the AVClass for SwrContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n * @return the AVClass of SwrContext\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_get_class"} {:args [], :ret {:spelling "struct SwrContext *"}, :function/args [], :symbol "swr_alloc", :function/ret [:coffi.mem/pointer :clong/SwrContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_alloc, :raw-comment "/**\n * Allocate SwrContext.\n *\n * If you use this function you will need to set the parameters (manually or\n * with swr_alloc_set_opts()) before calling swr_init().\n *\n * @see swr_alloc_set_opts(), swr_init(), swr_free()\n * @return NULL on error, allocated context otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_alloc"} {:args [{:spelling "s", :type "struct SwrContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext]], :symbol "swr_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_init, :raw-comment "/**\n * Initialize context after user parameters have been set.\n * @note The context must be configured using the AVOption API.\n *\n * @see av_opt_set_int()\n * @see av_opt_set_dict()\n *\n * @param[in,out]   s Swr context to initialize\n * @return AVERROR error code in case of failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_init"} {:args [{:spelling "s", :type "struct SwrContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext]], :symbol "swr_is_initialized", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_is_initialized, :raw-comment "/**\n * Check whether an swr context has been initialized or not.\n *\n * @param[in]       s Swr context to check\n * @see swr_init()\n * @return positive if it has been initialized, 0 if not initialized\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_is_initialized"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "out_ch_layout", :type "long long"} {:spelling "out_sample_fmt", :type "enum AVSampleFormat"} {:spelling "out_sample_rate", :type "int"} {:spelling "in_ch_layout", :type "long long"} {:spelling "in_sample_fmt", :type "enum AVSampleFormat"} {:spelling "in_sample_rate", :type "int"} {:spelling "log_offset", :type "int"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "struct SwrContext *"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/long :coffi.mem/int :coffi.mem/int :coffi.mem/long :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "swr_alloc_set_opts", :function/ret [:coffi.mem/pointer :clong/SwrContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_alloc_set_opts, :raw-comment "/**\n * Allocate SwrContext if needed and set/reset common parameters.\n *\n * This function does not require s to be allocated with swr_alloc(). On the\n * other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters\n * on the allocated context.\n *\n * @param s               existing Swr context if available, or NULL if not\n * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)\n * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).\n * @param out_sample_rate output sample rate (frequency in Hz)\n * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)\n * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).\n * @param in_sample_rate  input sample rate (frequency in Hz)\n * @param log_offset      logging level offset\n * @param log_ctx         parent logging context, can be NULL\n *\n * @see swr_init(), swr_free()\n * @return NULL on error, allocated context otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_alloc_set_opts"} {:args [{:spelling "s", :type "struct SwrContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/SwrContext]]], :symbol "swr_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_free, :raw-comment "/**\n * Free the given SwrContext and set the pointer to NULL.\n *\n * @param[in] s a pointer to a pointer to Swr context\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_free"} {:args [{:spelling "s", :type "struct SwrContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwrContext]], :symbol "swr_close", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_close, :raw-comment "/**\n * Closes the context so that swr_is_initialized() returns 0.\n *\n * The context can be brought back to life by running swr_init(),\n * swr_init() can also be used without swr_close().\n * This function is mainly provided for simplifying the usecase\n * where one tries to support libavresample and libswresample.\n *\n * @param[in,out] s Swr context to be closed\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_close"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "out", :type "unsigned char **"} {:spelling "out_count", :type "int"} {:spelling "in", :type "const unsigned char **"} {:spelling "in_count", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int], :symbol "swr_convert", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_convert, :raw-comment "/** Convert audio.\n *\n * in and in_count can be set to 0 to flush the last few samples out at the\n * end.\n *\n * If more input is provided than output space, then the input will be buffered.\n * You can avoid this buffering by using swr_get_out_samples() to retrieve an\n * upper bound on the required number of output samples for the given number of\n * input samples. Conversion will run directly without copying whenever possible.\n *\n * @param s         allocated Swr context, with parameters set\n * @param out       output buffers, only the first one need be set in case of packed audio\n * @param out_count amount of space available for output in samples per channel\n * @param in        input buffers, only the first one need to be set in case of packed audio\n * @param in_count  number of input samples available in one channel\n *\n * @return number of samples output per channel, negative value on error\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_convert"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "pts", :type "long long"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/long], :symbol "swr_next_pts", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_next_pts, :raw-comment "/**\n * Convert the next timestamp from input to output\n * timestamps are in 1/(in_sample_rate * out_sample_rate) units.\n *\n * @note There are 2 slightly differently behaving modes.\n *       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)\n *              in this case timestamps will be passed through with delays compensated\n *       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)\n *              in this case the output timestamps will match output sample numbers.\n *              See ffmpeg-resampler(1) for the two modes of compensation.\n *\n * @param s[in]     initialized Swr context\n * @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown\n * @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are\n *      function used internally for timestamp compensation.\n * @return the output timestamp for the next output sample\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_next_pts"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "sample_delta", :type "int"} {:spelling "compensation_distance", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/int :coffi.mem/int], :symbol "swr_set_compensation", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_set_compensation, :raw-comment "/**\n * Activate resampling compensation (\"soft\" compensation). This function is\n * internally called when needed in swr_next_pts().\n *\n * @param[in,out] s             allocated Swr context. If it is not initialized,\n *                              or SWR_FLAG_RESAMPLE is not set, swr_init() is\n *                              called with the flag set.\n * @param[in]     sample_delta  delta in PTS per sample\n * @param[in]     compensation_distance number of samples to compensate for\n * @return    >= 0 on success, AVERROR error codes if:\n *            @li @c s is NULL,\n *            @li @c compensation_distance is less than 0,\n *            @li @c compensation_distance is 0 but sample_delta is not,\n *            @li compensation unsupported by resampler, or\n *            @li swr_init() fails when called.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_set_compensation"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "channel_map", :type "const int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] [:coffi.mem/pointer :coffi.mem/int]], :symbol "swr_set_channel_mapping", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_set_channel_mapping, :raw-comment "/**\n * Set a customized input channel mapping.\n *\n * @param[in,out] s           allocated Swr context, not yet initialized\n * @param[in]     channel_map customized input channel mapping (array of channel\n *                            indexes, -1 for a muted channel)\n * @return >= 0 on success, or AVERROR error code in case of failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_set_channel_mapping"} {:args [{:spelling "in_layout", :type "unsigned long long"} {:spelling "out_layout", :type "unsigned long long"} {:spelling "center_mix_level", :type "double"} {:spelling "surround_mix_level", :type "double"} {:spelling "lfe_mix_level", :type "double"} {:spelling "rematrix_maxval", :type "double"} {:spelling "rematrix_volume", :type "double"} {:spelling "matrix", :type "double *"} {:spelling "stride", :type "int"} {:spelling "matrix_encoding", :type "enum AVMatrixEncoding"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/long :coffi.mem/long :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double :coffi.mem/double [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/int :coffi.mem/int :coffi.mem/pointer], :symbol "swr_build_matrix", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_build_matrix, :raw-comment "/**\n * Generate a channel mixing matrix.\n *\n * This function is the one used internally by libswresample for building the\n * default mixing matrix. It is made public just as a utility function for\n * building custom matrices.\n *\n * @param in_layout           input channel layout\n * @param out_layout          output channel layout\n * @param center_mix_level    mix level for the center channel\n * @param surround_mix_level  mix level for the surround channel(s)\n * @param lfe_mix_level       mix level for the low-frequency effects channel\n * @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent\n *                            overflow. if INT_MAX, coefficients will not be\n *                            normalized.\n * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is\n *                            the weight of input channel i in output channel o.\n * @param stride              distance between adjacent input channels in the\n *                            matrix array\n * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)\n * @param log_ctx             parent logging context, can be NULL\n * @return                    0 on success, negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_build_matrix"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "matrix", :type "const double *"} {:spelling "stride", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] [:coffi.mem/pointer :coffi.mem/double] :coffi.mem/int], :symbol "swr_set_matrix", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_set_matrix, :raw-comment "/**\n * Set a customized remix matrix.\n *\n * @param s       allocated Swr context, not yet initialized\n * @param matrix  remix coefficients; matrix[i + stride * o] is\n *                the weight of input channel i in output channel o\n * @param stride  offset between lines of the matrix\n * @return  >= 0 on success, or AVERROR error code in case of failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_set_matrix"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "count", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/int], :symbol "swr_drop_output", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_drop_output, :raw-comment "/**\n * Drops the specified number of output samples.\n *\n * This function, along with swr_inject_silence(), is called by swr_next_pts()\n * if needed for \"hard\" compensation.\n *\n * @param s     allocated Swr context\n * @param count number of samples to be dropped\n *\n * @return >= 0 on success, or a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_drop_output"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "count", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/int], :symbol "swr_inject_silence", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_inject_silence, :raw-comment "/**\n * Injects the specified number of silence samples.\n *\n * This function, along with swr_drop_output(), is called by swr_next_pts()\n * if needed for \"hard\" compensation.\n *\n * @param s     allocated Swr context\n * @param count number of samples to be dropped\n *\n * @return >= 0 on success, or a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_inject_silence"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "base", :type "long long"}], :ret {:spelling "long long"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/long], :symbol "swr_get_delay", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_get_delay, :raw-comment "/**\n * Gets the delay the next input sample will experience relative to the next output sample.\n *\n * Swresample can buffer data if more input has been provided than available\n * output space, also converting between sample rates needs a delay.\n * This function returns the sum of all such delays.\n * The exact delay is not necessarily an integer value in either input or\n * output sample rate. Especially when downsampling by a large value, the\n * output sample rate may be a poor choice to represent the delay, similarly\n * for upsampling and the input sample rate.\n *\n * @param s     swr context\n * @param base  timebase in which the returned delay will be:\n *              @li if it's set to 1 the returned delay is in seconds\n *              @li if it's set to 1000 the returned delay is in milliseconds\n *              @li if it's set to the input sample rate then the returned\n *                  delay is in input samples\n *              @li if it's set to the output sample rate then the returned\n *                  delay is in output samples\n *              @li if it's the least common multiple of in_sample_rate and\n *                  out_sample_rate then an exact rounding-free delay will be\n *                  returned\n * @returns     the delay in 1 / @c base units.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_get_delay"} {:args [{:spelling "s", :type "struct SwrContext *"} {:spelling "in_samples", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] :coffi.mem/int], :symbol "swr_get_out_samples", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_get_out_samples, :raw-comment "/**\n * Find an upper bound on the number of samples that the next swr_convert\n * call will output, if called with in_samples of input samples. This\n * depends on the internal state, and anything changing the internal state\n * (like further swr_convert() calls) will may change the number of samples\n * swr_get_out_samples() returns for the same number of input samples.\n *\n * @param in_samples    number of input samples.\n * @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()\n *       or swr_set_compensation() invalidates this limit\n * @note it is recommended to pass the correct available buffer size\n *       to all functions like swr_convert() even if swr_get_out_samples()\n *       indicates that less would be used.\n * @returns an upper bound on the number of samples that the next swr_convert\n *          will output or a negative value to indicate an error\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_get_out_samples"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "swresample_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swresample_version, :raw-comment "/**\n * Return the @ref LIBSWRESAMPLE_VERSION_INT constant.\n *\n * This is useful to check if the build-time libswresample has the same version\n * as the run-time one.\n *\n * @returns     the unsigned int-typed version\n */", :kind "CXCursor_FunctionDecl", :spelling "swresample_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "swresample_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swresample_configuration, :raw-comment "/**\n * Return the swr build-time configuration.\n *\n * @returns     the build-time @c ./configure flags\n */", :kind "CXCursor_FunctionDecl", :spelling "swresample_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "swresample_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swresample_license, :raw-comment "/**\n * Return the swr license.\n *\n * @returns     the license of libswresample, determined at build-time\n */", :kind "CXCursor_FunctionDecl", :spelling "swresample_license"} {:args [{:spelling "swr", :type "struct SwrContext *"} {:spelling "output", :type "struct AVFrame *"} {:spelling "input", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "swr_convert_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_convert_frame, :raw-comment "/**\n * Convert the samples in the input AVFrame and write them to the output AVFrame.\n *\n * Input and output AVFrames must have channel_layout, sample_rate and format set.\n *\n * If the output AVFrame does not have the data pointers allocated the nb_samples\n * field will be set using av_frame_get_buffer()\n * is called to allocate the frame.\n *\n * The output AVFrame can be NULL or have fewer allocated samples than required.\n * In this case, any remaining samples not written to the output will be added\n * to an internal FIFO buffer, to be returned at the next call to this function\n * or to swr_convert().\n *\n * If converting sample rate, there may be data remaining in the internal\n * resampling delay buffer. swr_get_delay() tells the number of\n * remaining samples. To get this data as output, call this function or\n * swr_convert() with NULL input.\n *\n * If the SwrContext configuration does not match the output and\n * input AVFrame settings the conversion does not take place and depending on\n * which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED\n * or the result of a bitwise-OR of them is returned.\n *\n * @see swr_delay()\n * @see swr_convert()\n * @see swr_get_delay()\n *\n * @param swr             audio resample context\n * @param output          output AVFrame\n * @param input           input AVFrame\n * @return                0 on success, AVERROR on failure or nonmatching\n *                        configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_convert_frame"} {:args [{:spelling "swr", :type "struct SwrContext *"} {:spelling "out", :type "const struct AVFrame *"} {:spelling "in", :type "const struct AVFrame *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwrContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :clong/AVFrame]], :symbol "swr_config_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swr_config_frame, :raw-comment "/**\n * Configure or reconfigure the SwrContext using the information\n * provided by the AVFrames.\n *\n * The original resampling context is reset even on failure.\n * The function calls swr_close() internally if the context is open.\n *\n * @see swr_close();\n *\n * @param swr             audio resample context\n * @param output          output AVFrame\n * @param input           input AVFrame\n * @return                0 on success, AVERROR on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "swr_config_frame"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "swscale_version", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swscale_version, :raw-comment "/**\n * @defgroup libsws libswscale\n * Color conversion and scaling library.\n *\n * @{\n *\n * Return the LIBSWSCALE_VERSION_INT constant.\n */", :kind "CXCursor_FunctionDecl", :spelling "swscale_version"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "swscale_configuration", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swscale_configuration, :raw-comment "/**\n * Return the libswscale build-time configuration.\n */", :kind "CXCursor_FunctionDecl", :spelling "swscale_configuration"} {:args [], :ret {:spelling "const char *"}, :function/args [], :symbol "swscale_license", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :swscale_license, :raw-comment "/**\n * Return the libswscale license.\n */", :kind "CXCursor_FunctionDecl", :spelling "swscale_license"} {:args [{:spelling "colorspace", :type "int"}], :ret {:spelling "const int *"}, :function/args [:coffi.mem/int], :symbol "sws_getCoefficients", :function/ret [:coffi.mem/pointer :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getCoefficients, :raw-comment "/**\n * Return a pointer to yuv<->rgb coefficients for the given colorspace\n * suitable for sws_setColorspaceDetails().\n *\n * @param colorspace One of the SWS_CS_* macros. If invalid,\n * SWS_CS_DEFAULT is used.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_getCoefficients"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "sws_isSupportedInput", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_isSupportedInput, :raw-comment "/**\n * Return a positive value if pix_fmt is a supported input format, 0\n * otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_isSupportedInput"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "sws_isSupportedOutput", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_isSupportedOutput, :raw-comment "/**\n * Return a positive value if pix_fmt is a supported output format, 0\n * otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_isSupportedOutput"} {:args [{:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "sws_isSupportedEndiannessConversion", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_isSupportedEndiannessConversion, :raw-comment "/**\n * @param[in]  pix_fmt the pixel format\n * @return a positive value if an endianness conversion for pix_fmt is\n * supported, 0 otherwise.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_isSupportedEndiannessConversion"} {:args [], :ret {:spelling "struct SwsContext *"}, :function/args [], :symbol "sws_alloc_context", :function/ret [:coffi.mem/pointer :clong/SwsContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_alloc_context, :raw-comment "/**\n * Allocate an empty SwsContext. This must be filled and passed to\n * sws_init_context(). For filling see AVOptions, options.c and\n * sws_setColorspaceDetails().\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_alloc_context"} {:args [{:spelling "sws_context", :type "struct SwsContext *"} {:spelling "srcFilter", :type "struct SwsFilter *"} {:spelling "dstFilter", :type "struct SwsFilter *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwsContext] [:coffi.mem/pointer :clong/SwsFilter] [:coffi.mem/pointer :clong/SwsFilter]], :symbol "sws_init_context", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_init_context, :raw-comment "/**\n * Initialize the swscaler context sws_context.\n *\n * @return zero or positive value on success, a negative value on\n * error\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_init_context"} {:args [{:spelling "swsContext", :type "struct SwsContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsContext]], :symbol "sws_freeContext", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_freeContext, :raw-comment "/**\n * Free the swscaler context swsContext.\n * If swsContext is NULL, then does nothing.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_freeContext"} {:args [{:spelling "srcW", :type "int"} {:spelling "srcH", :type "int"} {:spelling "srcFormat", :type "enum AVPixelFormat"} {:spelling "dstW", :type "int"} {:spelling "dstH", :type "int"} {:spelling "dstFormat", :type "enum AVPixelFormat"} {:spelling "flags", :type "int"} {:spelling "srcFilter", :type "struct SwsFilter *"} {:spelling "dstFilter", :type "struct SwsFilter *"} {:spelling "param", :type "const double *"}], :ret {:spelling "struct SwsContext *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clong/SwsFilter] [:coffi.mem/pointer :clong/SwsFilter] [:coffi.mem/pointer :coffi.mem/double]], :symbol "sws_getContext", :function/ret [:coffi.mem/pointer :clong/SwsContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getContext, :raw-comment "/**\n * Allocate and return an SwsContext. You need it to perform\n * scaling/conversion operations using sws_scale().\n *\n * @param srcW the width of the source image\n * @param srcH the height of the source image\n * @param srcFormat the source image format\n * @param dstW the width of the destination image\n * @param dstH the height of the destination image\n * @param dstFormat the destination image format\n * @param flags specify which algorithm and options to use for rescaling\n * @param param extra parameters to tune the used scaler\n *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n *              function, param[0] tunes f(1) and param[1] f´(1)\n *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n *              frequency\n *              For SWS_LANCZOS param[0] tunes the width of the window function\n * @return a pointer to an allocated context, or NULL in case of error\n * @note this function is to be removed after a saner alternative is\n *       written\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_getContext"} {:args [{:spelling "c", :type "struct SwsContext *"} {:spelling "srcSlice", :type "const unsigned char *const[]"} {:spelling "srcStride", :type "int const[]"} {:spelling "srcSliceY", :type "int"} {:spelling "srcSliceH", :type "int"} {:spelling "dst", :type "unsigned char *const[]"} {:spelling "dstStride", :type "int const[]"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwsContext] :coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int :coffi.mem/int :coffi.mem/pointer :coffi.mem/pointer], :symbol "sws_scale", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_scale, :raw-comment "/**\n * Scale the image slice in srcSlice and put the resulting scaled\n * slice in the image in dst. A slice is a sequence of consecutive\n * rows in an image.\n *\n * Slices have to be provided in sequential order, either in\n * top-bottom or bottom-top order. If slices are provided in\n * non-sequential order the behavior of the function is undefined.\n *\n * @param c         the scaling context previously created with\n *                  sws_getContext()\n * @param srcSlice  the array containing the pointers to the planes of\n *                  the source slice\n * @param srcStride the array containing the strides for each plane of\n *                  the source image\n * @param srcSliceY the position in the source image of the slice to\n *                  process, that is the number (counted starting from\n *                  zero) in the image of the first row of the slice\n * @param srcSliceH the height of the source slice, that is the number\n *                  of rows in the slice\n * @param dst       the array containing the pointers to the planes of\n *                  the destination image\n * @param dstStride the array containing the strides for each plane of\n *                  the destination image\n * @return          the height of the output slice\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_scale"} {:args [{:spelling "c", :type "struct SwsContext *"} {:spelling "inv_table", :type "int const[4]"} {:spelling "srcRange", :type "int"} {:spelling "table", :type "int const[4]"} {:spelling "dstRange", :type "int"} {:spelling "brightness", :type "int"} {:spelling "contrast", :type "int"} {:spelling "saturation", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwsContext] [:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int [:coffi.mem/array :coffi.mem/int 4] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "sws_setColorspaceDetails", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_setColorspaceDetails, :raw-comment "/**\n * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n * @param brightness 16.16 fixed point brightness correction\n * @param contrast 16.16 fixed point contrast correction\n * @param saturation 16.16 fixed point saturation correction\n * @return -1 if not supported\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_setColorspaceDetails"} {:args [{:spelling "c", :type "struct SwsContext *"} {:spelling "inv_table", :type "int **"} {:spelling "srcRange", :type "int *"} {:spelling "table", :type "int **"} {:spelling "dstRange", :type "int *"} {:spelling "brightness", :type "int *"} {:spelling "contrast", :type "int *"} {:spelling "saturation", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/SwsContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "sws_getColorspaceDetails", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getColorspaceDetails, :raw-comment "/**\n * @return -1 if not supported\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_getColorspaceDetails"} {:args [{:spelling "length", :type "int"}], :ret {:spelling "struct SwsVector *"}, :function/args [:coffi.mem/int], :symbol "sws_allocVec", :function/ret [:coffi.mem/pointer :clong/SwsVector], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_allocVec, :raw-comment "/**\n * Allocate and return an uninitialized vector with length coefficients.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_allocVec"} {:args [{:spelling "variance", :type "double"} {:spelling "quality", :type "double"}], :ret {:spelling "struct SwsVector *"}, :function/args [:coffi.mem/double :coffi.mem/double], :symbol "sws_getGaussianVec", :function/ret [:coffi.mem/pointer :clong/SwsVector], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getGaussianVec, :raw-comment "/**\n * Return a normalized Gaussian curve used to filter stuff\n * quality = 3 is high quality, lower is lower quality.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_getGaussianVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "scalar", :type "double"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] :coffi.mem/double], :symbol "sws_scaleVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_scaleVec, :raw-comment "/**\n * Scale all the coefficients of a by the scalar value.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_scaleVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "height", :type "double"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] :coffi.mem/double], :symbol "sws_normalizeVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_normalizeVec, :raw-comment "/**\n * Scale all the coefficients of a so that their sum equals height.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_normalizeVec"} {:args [{:spelling "c", :type "double"} {:spelling "length", :type "int"}], :ret {:spelling "struct SwsVector *"}, :function/args [:coffi.mem/double :coffi.mem/int], :symbol "sws_getConstVec", :function/ret [:coffi.mem/pointer :clong/SwsVector], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getConstVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_getConstVec"} {:args [], :ret {:spelling "struct SwsVector *"}, :function/args [], :symbol "sws_getIdentityVec", :function/ret [:coffi.mem/pointer :clong/SwsVector], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getIdentityVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_getIdentityVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "b", :type "struct SwsVector *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] [:coffi.mem/pointer :clong/SwsVector]], :symbol "sws_convVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_convVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_convVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "b", :type "struct SwsVector *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] [:coffi.mem/pointer :clong/SwsVector]], :symbol "sws_addVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_addVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_addVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "b", :type "struct SwsVector *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] [:coffi.mem/pointer :clong/SwsVector]], :symbol "sws_subVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_subVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_subVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "shift", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] :coffi.mem/int], :symbol "sws_shiftVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_shiftVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_shiftVec"} {:args [{:spelling "a", :type "struct SwsVector *"}], :ret {:spelling "struct SwsVector *"}, :function/args [[:coffi.mem/pointer :clong/SwsVector]], :symbol "sws_cloneVec", :function/ret [:coffi.mem/pointer :clong/SwsVector], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_cloneVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_cloneVec"} {:args [{:spelling "a", :type "struct SwsVector *"} {:spelling "log_ctx", :type "struct AVClass *"} {:spelling "log_level", :type "int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector] [:coffi.mem/pointer :clong/AVClass] :coffi.mem/int], :symbol "sws_printVec2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_printVec2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_printVec2"} {:args [{:spelling "a", :type "struct SwsVector *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsVector]], :symbol "sws_freeVec", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_freeVec, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_freeVec"} {:args [{:spelling "lumaGBlur", :type "float"} {:spelling "chromaGBlur", :type "float"} {:spelling "lumaSharpen", :type "float"} {:spelling "chromaSharpen", :type "float"} {:spelling "chromaHShift", :type "float"} {:spelling "chromaVShift", :type "float"} {:spelling "verbose", :type "int"}], :ret {:spelling "struct SwsFilter *"}, :function/args [:coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/float :coffi.mem/int], :symbol "sws_getDefaultFilter", :function/ret [:coffi.mem/pointer :clong/SwsFilter], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getDefaultFilter, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_getDefaultFilter"} {:args [{:spelling "filter", :type "struct SwsFilter *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/SwsFilter]], :symbol "sws_freeFilter", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_freeFilter, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "sws_freeFilter"} {:args [{:spelling "context", :type "struct SwsContext *"} {:spelling "srcW", :type "int"} {:spelling "srcH", :type "int"} {:spelling "srcFormat", :type "enum AVPixelFormat"} {:spelling "dstW", :type "int"} {:spelling "dstH", :type "int"} {:spelling "dstFormat", :type "enum AVPixelFormat"} {:spelling "flags", :type "int"} {:spelling "srcFilter", :type "struct SwsFilter *"} {:spelling "dstFilter", :type "struct SwsFilter *"} {:spelling "param", :type "const double *"}], :ret {:spelling "struct SwsContext *"}, :function/args [[:coffi.mem/pointer :clong/SwsContext] :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clong/SwsFilter] [:coffi.mem/pointer :clong/SwsFilter] [:coffi.mem/pointer :coffi.mem/double]], :symbol "sws_getCachedContext", :function/ret [:coffi.mem/pointer :clong/SwsContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_getCachedContext, :raw-comment "/**\n * Check if context can be reused, otherwise reallocate a new one.\n *\n * If context is NULL, just calls sws_getContext() to get a new\n * context. Otherwise, checks if the parameters are the ones already\n * saved in context. If that is the case, returns the current\n * context. Otherwise, frees context and gets a new context with\n * the new parameters.\n *\n * Be warned that srcFilter and dstFilter are not checked, they\n * are assumed to remain the same.\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_getCachedContext"} {:args [{:spelling "src", :type "const unsigned char *"} {:spelling "dst", :type "unsigned char *"} {:spelling "num_pixels", :type "int"} {:spelling "palette", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "sws_convertPalette8ToPacked32", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_convertPalette8ToPacked32, :raw-comment "/**\n * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n *\n * The output frame will have the same packed format as the palette.\n *\n * @param src        source frame buffer\n * @param dst        destination frame buffer\n * @param num_pixels number of pixels to convert\n * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_convertPalette8ToPacked32"} {:args [{:spelling "src", :type "const unsigned char *"} {:spelling "dst", :type "unsigned char *"} {:spelling "num_pixels", :type "int"} {:spelling "palette", :type "const unsigned char *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char]], :symbol "sws_convertPalette8ToPacked24", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_convertPalette8ToPacked24, :raw-comment "/**\n * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n *\n * With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n *\n * @param src        source frame buffer\n * @param dst        destination frame buffer\n * @param num_pixels number of pixels to convert\n * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_convertPalette8ToPacked24"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "sws_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :sws_get_class, :raw-comment "/**\n * Get the AVClass for swsContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */", :kind "CXCursor_FunctionDecl", :spelling "sws_get_class"} {:args [{:spelling "buf", :type "const unsigned char *"} {:spelling "samples", :type "unsigned int *"} {:spelling "frames", :type "unsigned char *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char]], :symbol "av_adts_header_parse", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_adts_header_parse, :raw-comment "/**\n * Extract the number of samples and frames from AAC data.\n * @param[in]  buf     pointer to AAC data buffer\n * @param[out] samples Pointer to where number of samples is written\n * @param[out] frames  Pointer to where number of frames is written\n * @return Returns 0 on success, error code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_adts_header_parse"} {:args [], :ret {:spelling "struct AVVDPAUContext *"}, :function/args [], :symbol "av_alloc_vdpaucontext", :function/ret [:coffi.mem/pointer :clong/AVVDPAUContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_alloc_vdpaucontext, :raw-comment "/**\n * @brief allocation function for AVVDPAUContext\n *\n * Allows extending the struct without breaking API/ABI\n */", :kind "CXCursor_FunctionDecl", :spelling "av_alloc_vdpaucontext"} {:args [{:spelling "", :type "const struct AVVDPAUContext *"}], :ret {:spelling "int (*)(struct AVCodecContext *, struct AVFrame *, const int *, unsigned int, const int *)"}, :function/args [[:coffi.mem/pointer :clong/AVVDPAUContext]], :symbol "av_vdpau_hwaccel_get_render2", :function/ret [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]] :coffi.mem/int], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_hwaccel_get_render2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_hwaccel_get_render2"} {:args [{:spelling "", :type "struct AVVDPAUContext *"} {:spelling "", :type "int (*)(struct AVCodecContext *, struct AVFrame *, const int *, unsigned int, const int *)"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVVDPAUContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]] :coffi.mem/int]], :symbol "av_vdpau_hwaccel_set_render2", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_hwaccel_set_render2, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_hwaccel_set_render2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "device", :type "int"} {:spelling "get_proc_address", :type "int *"} {:spelling "flags", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :symbol "av_vdpau_bind_context", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_bind_context, :raw-comment "/**\n * Associate a VDPAU device with a codec context for hardware acceleration.\n * This function is meant to be called from the get_format() codec callback,\n * or earlier. It can also be called after avcodec_flush_buffers() to change\n * the underlying VDPAU device mid-stream (e.g. to recover from non-transparent\n * display preemption).\n *\n * @note get_format() must return AV_PIX_FMT_VDPAU if this function completes\n * successfully.\n *\n * @param avctx decoding context whose get_format() callback is invoked\n * @param device VDPAU device handle to use for hardware acceleration\n * @param get_proc_address VDPAU device driver\n * @param flags zero of more OR'd AV_HWACCEL_FLAG_* flags\n *\n * @return 0 on success, an AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_bind_context"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "type", :type "int *"} {:spelling "width", :type "unsigned int *"} {:spelling "height", :type "unsigned int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_vdpau_get_surface_parameters", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_get_surface_parameters, :raw-comment "/**\n * Gets the parameters to create an adequate VDPAU video surface for the codec\n * context using VDPAU hardware decoding acceleration.\n *\n * @note Behavior is undefined if the context was not successfully bound to a\n * VDPAU device using av_vdpau_bind_context().\n *\n * @param avctx the codec context being used for decoding the stream\n * @param type storage space for the VDPAU video surface chroma type\n *              (or NULL to ignore)\n * @param width storage space for the VDPAU video surface pixel width\n *              (or NULL to ignore)\n * @param height storage space for the VDPAU video surface pixel height\n *              (or NULL to ignore)\n *\n * @return 0 on success, a negative AVERROR code on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_get_surface_parameters"} {:args [], :ret {:spelling "struct AVVDPAUContext *"}, :function/args [], :symbol "av_vdpau_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVVDPAUContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_alloc_context, :raw-comment "/**\n * Allocate an AVVDPAUContext.\n *\n * @return Newly-allocated AVVDPAUContext or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_alloc_context"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "profile", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_vdpau_get_profile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vdpau_get_profile, :raw-comment "/**\n * Get a decoder profile that should be used for initializing a VDPAU decoder.\n * Should be called from the AVCodecContext.get_format() callback.\n *\n * @deprecated Use av_vdpau_bind_context() instead.\n *\n * @param avctx the codec context being used for decoding the stream\n * @param profile a pointer into which the result will be written on success.\n *                The contents of profile are undefined if this function returns\n *                an error.\n *\n * @return 0 on success (non-negative), a negative AVERROR on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vdpau_get_profile"} {:args [], :ret {:spelling "struct AVQSVContext *"}, :function/args [], :symbol "av_qsv_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVQSVContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_qsv_alloc_context, :raw-comment "/**\n * Allocate a new context.\n *\n * It must be freed by the caller with av_free().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_qsv_alloc_context"} {:args [], :ret {:spelling "struct AVVideotoolboxContext *"}, :function/args [], :symbol "av_videotoolbox_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVVideotoolboxContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_videotoolbox_alloc_context, :raw-comment "/**\n * Allocate and initialize a Videotoolbox context.\n *\n * This function should be called from the get_format() callback when the caller\n * selects the AV_PIX_FMT_VIDETOOLBOX format. The caller must then create\n * the decoder object (using the output callback provided by libavcodec) that\n * will be used for Videotoolbox-accelerated decoding.\n *\n * When decoding with Videotoolbox is finished, the caller must destroy the decoder\n * object and free the Videotoolbox context using av_free().\n *\n * @return the newly allocated context or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_videotoolbox_alloc_context"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_videotoolbox_default_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_videotoolbox_default_init, :raw-comment "/**\n * This is a convenience function that creates and sets up the Videotoolbox context using\n * an internal implementation.\n *\n * @param avctx the corresponding codec context\n *\n * @return >= 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_videotoolbox_default_init"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "vtctx", :type "struct AVVideotoolboxContext *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVVideotoolboxContext]], :symbol "av_videotoolbox_default_init2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_videotoolbox_default_init2, :raw-comment "/**\n * This is a convenience function that creates and sets up the Videotoolbox context using\n * an internal implementation.\n *\n * @param avctx the corresponding codec context\n * @param vtctx the Videotoolbox context to use\n *\n * @return >= 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_videotoolbox_default_init2"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_videotoolbox_default_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_videotoolbox_default_free, :raw-comment "/**\n * This function must be called to free the Videotoolbox context initialized with\n * av_videotoolbox_default_init().\n *\n * @param avctx the corresponding codec context\n */", :kind "CXCursor_FunctionDecl", :spelling "av_videotoolbox_default_free"} {:args [], :ret {:spelling "struct AVMediaCodecContext *"}, :function/args [], :symbol "av_mediacodec_alloc_context", :function/ret [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mediacodec_alloc_context, :raw-comment "/**\n * Allocate and initialize a MediaCodec context.\n *\n * When decoding with MediaCodec is finished, the caller must free the\n * MediaCodec context with av_mediacodec_default_free.\n *\n * @return a pointer to a newly allocated AVMediaCodecContext on success, NULL otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mediacodec_alloc_context"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"} {:spelling "ctx", :type "struct AVMediaCodecContext *"} {:spelling "surface", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 8]] :coffi.mem/pointer], :symbol "av_mediacodec_default_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mediacodec_default_init, :raw-comment "/**\n * Convenience function that sets up the MediaCodec context.\n *\n * @param avctx codec context\n * @param ctx MediaCodec context to initialize\n * @param surface reference to an android/view/Surface\n * @return 0 on success, < 0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mediacodec_default_init"} {:args [{:spelling "avctx", :type "struct AVCodecContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVCodecContext]], :symbol "av_mediacodec_default_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mediacodec_default_free, :raw-comment "/**\n * This function must be called to free the MediaCodec context initialized with\n * av_mediacodec_default_init().\n *\n * @param avctx codec context\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mediacodec_default_free"} {:args [{:spelling "buffer", :type "struct MediaCodecBuffer *"} {:spelling "render", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/MediaCodecBuffer] :coffi.mem/int], :symbol "av_mediacodec_release_buffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mediacodec_release_buffer, :raw-comment "/**\n * Release a MediaCodec buffer and render it to the surface that is associated\n * with the decoder. This function should only be called once on a given\n * buffer, once released the underlying buffer returns to the codec, thus\n * subsequent calls to this function will have no effect.\n *\n * @param buffer the buffer to render\n * @param render 1 to release and render the buffer to the surface or 0 to\n * discard the buffer\n * @return 0 on success, < 0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mediacodec_release_buffer"} {:args [{:spelling "buffer", :type "struct MediaCodecBuffer *"} {:spelling "time", :type "long long"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/MediaCodecBuffer] :coffi.mem/long], :symbol "av_mediacodec_render_buffer_at_time", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mediacodec_render_buffer_at_time, :raw-comment "/**\n * Release a MediaCodec buffer and render it at the given time to the surface\n * that is associated with the decoder. The timestamp must be within one second\n * of the current java/lang/System#nanoTime() (which is implemented using\n * CLOCK_MONOTONIC on Android). See the Android MediaCodec documentation\n * of android/media/MediaCodec#releaseOutputBuffer(int,long) for more details.\n *\n * @param buffer the buffer to render\n * @param time timestamp in nanoseconds of when to render the buffer\n * @return 0 on success, < 0 otherwise\n */", :kind "CXCursor_FunctionDecl", :spelling "av_mediacodec_render_buffer_at_time"} {:args [], :ret {:spelling "struct AVD3D11VAContext *"}, :function/args [], :symbol "av_d3d11va_alloc_context", :function/ret [:coffi.mem/pointer :clong/AVD3D11VAContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_d3d11va_alloc_context, :raw-comment "/**\n * Allocate an AVD3D11VAContext.\n *\n * @return Newly-allocated AVD3D11VAContext or NULL on failure.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_d3d11va_alloc_context"} {:args [{:spelling "nbits", :type "int"} {:spelling "inverse", :type "int"}], :ret {:spelling "struct FFTContext *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_fft_init", :function/ret [:coffi.mem/pointer :clong/FFTContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fft_init, :raw-comment "/**\n * Set up a complex FFT.\n * @param nbits           log2 of the length of the input array\n * @param inverse         if 0 perform the forward transform, if 1 perform the inverse\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fft_init"} {:args [{:spelling "s", :type "struct FFTContext *"} {:spelling "z", :type "struct FFTComplex *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext] [:coffi.mem/pointer :clong/FFTComplex]], :symbol "av_fft_permute", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fft_permute, :raw-comment "/**\n * Do the permutation needed BEFORE calling ff_fft_calc().\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fft_permute"} {:args [{:spelling "s", :type "struct FFTContext *"} {:spelling "z", :type "struct FFTComplex *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext] [:coffi.mem/pointer :clong/FFTComplex]], :symbol "av_fft_calc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fft_calc, :raw-comment "/**\n * Do a complex FFT with the parameters defined in av_fft_init(). The\n * input data must be permuted before. No 1.0/sqrt(n) normalization is done.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_fft_calc"} {:args [{:spelling "s", :type "struct FFTContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext]], :symbol "av_fft_end", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_fft_end, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_fft_end"} {:args [{:spelling "nbits", :type "int"} {:spelling "inverse", :type "int"} {:spelling "scale", :type "double"}], :ret {:spelling "struct FFTContext *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/double], :symbol "av_mdct_init", :function/ret [:coffi.mem/pointer :clong/FFTContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mdct_init, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_mdct_init"} {:args [{:spelling "s", :type "struct FFTContext *"} {:spelling "output", :type "float *"} {:spelling "input", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_imdct_calc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_imdct_calc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_imdct_calc"} {:args [{:spelling "s", :type "struct FFTContext *"} {:spelling "output", :type "float *"} {:spelling "input", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_imdct_half", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_imdct_half, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_imdct_half"} {:args [{:spelling "s", :type "struct FFTContext *"} {:spelling "output", :type "float *"} {:spelling "input", :type "const float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext] [:coffi.mem/pointer :coffi.mem/float] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_mdct_calc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mdct_calc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_mdct_calc"} {:args [{:spelling "s", :type "struct FFTContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/FFTContext]], :symbol "av_mdct_end", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_mdct_end, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_mdct_end"} {:args [{:spelling "nbits", :type "int"} {:spelling "trans", :type "enum RDFTransformType"}], :ret {:spelling "struct RDFTContext *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_rdft_init", :function/ret [:coffi.mem/pointer :clong/RDFTContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rdft_init, :raw-comment "/**\n * Set up a real FFT.\n * @param nbits           log2 of the length of the input array\n * @param trans           the type of transform\n */", :kind "CXCursor_FunctionDecl", :spelling "av_rdft_init"} {:args [{:spelling "s", :type "struct RDFTContext *"} {:spelling "data", :type "float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/RDFTContext] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_rdft_calc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rdft_calc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_rdft_calc"} {:args [{:spelling "s", :type "struct RDFTContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/RDFTContext]], :symbol "av_rdft_end", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_rdft_end, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_rdft_end"} {:args [{:spelling "nbits", :type "int"} {:spelling "type", :type "enum DCTTransformType"}], :ret {:spelling "struct DCTContext *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "av_dct_init", :function/ret [:coffi.mem/pointer :clong/DCTContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dct_init, :raw-comment "/**\n * Set up DCT.\n *\n * @param nbits           size of the input array:\n *                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n *                        (1 << nbits) + 1 for DCT-I\n * @param type            the type of transform\n *\n * @note the first element of the input of DST-I is ignored\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dct_init"} {:args [{:spelling "s", :type "struct DCTContext *"} {:spelling "data", :type "float *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/DCTContext] [:coffi.mem/pointer :coffi.mem/float]], :symbol "av_dct_calc", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dct_calc, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_dct_calc"} {:args [{:spelling "s", :type "struct DCTContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/DCTContext]], :symbol "av_dct_end", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dct_end, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_dct_end"} {:args [{:spelling "vm", :type "void *"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer], :symbol "av_jni_set_java_vm", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_jni_set_java_vm, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_jni_set_java_vm"} {:args [{:spelling "log_ctx", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer], :symbol "av_jni_get_java_vm", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_jni_get_java_vm, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_jni_get_java_vm"} {:args [{:spelling "dsh", :type "struct AVDiracSeqHeader **"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "unsigned long"} {:spelling "log_ctx", :type "void *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDiracSeqHeader]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long :coffi.mem/pointer], :symbol "av_dirac_parse_sequence_header", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dirac_parse_sequence_header, :raw-comment "/**\n * Parse a Dirac sequence header.\n *\n * @param dsh this function will allocate and fill an AVDiracSeqHeader struct\n *            and write it into this pointer. The caller must free it with\n *            av_free().\n * @param buf the data buffer\n * @param buf_size the size of the data buffer in bytes\n * @param log_ctx if non-NULL, this function will log errors here\n * @return 0 on success, a negative AVERROR code on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dirac_parse_sequence_header"} {:args [], :ret {:spelling "struct AVDCT *"}, :function/args [], :symbol "avcodec_dct_alloc", :function/ret [:coffi.mem/pointer :clong/AVDCT], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_dct_alloc, :raw-comment "/**\n * Allocates a AVDCT context.\n * This needs to be initialized with avcodec_dct_init() after optionally\n * configuring it with AVOptions.\n *\n * To free it use av_free()\n */", :kind "CXCursor_FunctionDecl", :spelling "avcodec_dct_alloc"} {:args [{:spelling "", :type "struct AVDCT *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVDCT]], :symbol "avcodec_dct_init", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_dct_init, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_dct_init"} {:args [], :ret {:spelling "const struct AVClass *"}, :function/args [], :symbol "avcodec_dct_get_class", :function/ret [:coffi.mem/pointer :clong/AVClass], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :avcodec_dct_get_class, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "avcodec_dct_get_class"} {:args [{:spelling "buf", :type "const unsigned char *"} {:spelling "size", :type "unsigned long"} {:spelling "bitstream_id", :type "unsigned char *"} {:spelling "frame_size", :type "unsigned short *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/short]], :symbol "av_ac3_parse_header", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_ac3_parse_header, :raw-comment "/**\n * Extract the bitstream ID and the frame size from AC-3 data.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_ac3_parse_header"} {:args [{:spelling "extradata", :type "const unsigned char *"} {:spelling "extradata_size", :type "int"}], :ret {:spelling "struct AVVorbisParseContext *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_vorbis_parse_init", :function/ret [:coffi.mem/pointer :clong/AVVorbisParseContext], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vorbis_parse_init, :raw-comment "/**\n * Allocate and initialize the Vorbis parser using headers in the extradata.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vorbis_parse_init"} {:args [{:spelling "s", :type "struct AVVorbisParseContext **"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVVorbisParseContext]]], :symbol "av_vorbis_parse_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vorbis_parse_free, :raw-comment "/**\n * Free the parser and everything associated with it.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vorbis_parse_free"} {:args [{:spelling "s", :type "struct AVVorbisParseContext *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"} {:spelling "flags", :type "int *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVVorbisParseContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/int]], :symbol "av_vorbis_parse_frame_flags", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vorbis_parse_frame_flags, :raw-comment "/**\n * Get the duration for a Vorbis packet.\n *\n * If @p flags is @c NULL,\n * special frames are considered invalid.\n *\n * @param s        Vorbis parser context\n * @param buf      buffer containing a Vorbis frame\n * @param buf_size size of the buffer\n * @param flags    flags for special frames\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vorbis_parse_frame_flags"} {:args [{:spelling "s", :type "struct AVVorbisParseContext *"} {:spelling "buf", :type "const unsigned char *"} {:spelling "buf_size", :type "int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clong/AVVorbisParseContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_vorbis_parse_frame", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vorbis_parse_frame, :raw-comment "/**\n * Get the duration for a Vorbis packet.\n *\n * @param s        Vorbis parser context\n * @param buf      buffer containing a Vorbis frame\n * @param buf_size size of the buffer\n */", :kind "CXCursor_FunctionDecl", :spelling "av_vorbis_parse_frame"} {:args [{:spelling "s", :type "struct AVVorbisParseContext *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clong/AVVorbisParseContext]], :symbol "av_vorbis_parse_reset", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_vorbis_parse_reset, :raw-comment nil, :kind "CXCursor_FunctionDecl", :spelling "av_vorbis_parse_reset"} {:args [{:spelling "sys", :type "const struct AVDVProfile *"} {:spelling "frame", :type "const unsigned char *"} {:spelling "buf_size", :type "unsigned int"}], :ret {:spelling "const struct AVDVProfile *"}, :function/args [[:coffi.mem/pointer :clong/AVDVProfile] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "av_dv_frame_profile", :function/ret [:coffi.mem/pointer :clong/AVDVProfile], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dv_frame_profile, :raw-comment "/**\n * Get a DV profile for the provided compressed frame.\n *\n * @param sys the profile used for the previous frame, may be NULL\n * @param frame the compressed data buffer\n * @param buf_size size of the buffer in bytes\n * @return the DV profile for the supplied data or NULL on failure\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dv_frame_profile"} {:args [{:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "pix_fmt", :type "enum AVPixelFormat"}], :ret {:spelling "const struct AVDVProfile *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int], :symbol "av_dv_codec_profile", :function/ret [:coffi.mem/pointer :clong/AVDVProfile], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dv_codec_profile, :raw-comment "/**\n * Get a DV profile for the provided stream parameters.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dv_codec_profile"} {:args [{:spelling "width", :type "int"} {:spelling "height", :type "int"} {:spelling "pix_fmt", :type "enum AVPixelFormat"} {:spelling "frame_rate", :type "struct AVRational"}], :ret {:spelling "const struct AVDVProfile *"}, :function/args [:coffi.mem/int :coffi.mem/int :coffi.mem/int :clong/AVRational], :symbol "av_dv_codec_profile2", :function/ret [:coffi.mem/pointer :clong/AVDVProfile], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :av_dv_codec_profile2, :raw-comment "/**\n * Get a DV profile for the provided stream parameters.\n * The frame rate is used as a best-effort parameter.\n */", :kind "CXCursor_FunctionDecl", :spelling "av_dv_codec_profile2"}), :structs ({:kind "CXCursor_StructDecl", :spelling "struct AVBPrint", :type "CXType_Record", :id :clong/AVBPrint, :size-in-bytes 1024, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "str", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "len", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "size", :calculated-offset 96} {:type "unsigned int", :datatype :coffi.mem/int, :name "size_max", :calculated-offset 128} {:type "char [1]", :datatype [:coffi.mem/array :coffi.mem/char 1], :name "reserved_internal_buffer", :calculated-offset 160} {:type "char [1000]", :datatype [:coffi.mem/array :coffi.mem/char 1000], :name "reserved_padding", :calculated-offset 168}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecParserContext", :type "CXType_Record", :id :clong/AVCodecParserContext, :size-in-bytes 352, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 0} {:type "struct AVCodecParser *", :datatype [:coffi.mem/pointer :clong/AVCodecParser], :name "parser", :calculated-offset 64} {:type "long long", :datatype :coffi.mem/long, :name "frame_offset", :calculated-offset 128} {:type "long long", :datatype :coffi.mem/long, :name "cur_offset", :calculated-offset 192} {:type "long long", :datatype :coffi.mem/long, :name "next_frame_offset", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "pict_type", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "repeat_pict", :calculated-offset 352} {:type "long long", :datatype :coffi.mem/long, :name "pts", :calculated-offset 384} {:type "long long", :datatype :coffi.mem/long, :name "dts", :calculated-offset 448} {:type "long long", :datatype :coffi.mem/long, :name "last_pts", :calculated-offset 512} {:type "long long", :datatype :coffi.mem/long, :name "last_dts", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "fetch_timestamp", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "cur_frame_start_index", :calculated-offset 672} {:type "long long [4]", :datatype [:coffi.mem/array :coffi.mem/long 4], :name "cur_frame_offset", :calculated-offset 704} {:type "long long [4]", :datatype [:coffi.mem/array :coffi.mem/long 4], :name "cur_frame_pts", :calculated-offset 960} {:type "long long [4]", :datatype [:coffi.mem/array :coffi.mem/long 4], :name "cur_frame_dts", :calculated-offset 1216} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 1472} {:type "long long", :datatype :coffi.mem/long, :name "offset", :calculated-offset 1536} {:type "long long [4]", :datatype [:coffi.mem/array :coffi.mem/long 4], :name "cur_frame_end", :calculated-offset 1600} {:type "int", :datatype :coffi.mem/int, :name "key_frame", :calculated-offset 1856} {:type "long long", :datatype :coffi.mem/long, :name "convergence_duration", :calculated-offset 1920} {:type "int", :datatype :coffi.mem/int, :name "dts_sync_point", :calculated-offset 1984} {:type "int", :datatype :coffi.mem/int, :name "dts_ref_dts_delta", :calculated-offset 2016} {:type "int", :datatype :coffi.mem/int, :name "pts_dts_delta", :calculated-offset 2048} {:type "long long [4]", :datatype [:coffi.mem/array :coffi.mem/long 4], :name "cur_frame_pos", :calculated-offset 2112} {:type "long long", :datatype :coffi.mem/long, :name "pos", :calculated-offset 2368} {:type "long long", :datatype :coffi.mem/long, :name "last_pos", :calculated-offset 2432} {:type "int", :datatype :coffi.mem/int, :name "duration", :calculated-offset 2496} {:type "enum AVFieldOrder", :datatype :coffi.mem/int, :name "field_order", :calculated-offset 2528} {:type "enum AVPictureStructure", :datatype :coffi.mem/int, :name "picture_structure", :calculated-offset 2560} {:type "int", :datatype :coffi.mem/int, :name "output_picture_number", :calculated-offset 2592} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 2624} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 2656} {:type "int", :datatype :coffi.mem/int, :name "coded_width", :calculated-offset 2688} {:type "int", :datatype :coffi.mem/int, :name "coded_height", :calculated-offset 2720} {:type "int", :datatype :coffi.mem/int, :name "format", :calculated-offset 2752}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPixFmtDescriptor", :type "CXType_Record", :id :clong/AVPixFmtDescriptor, :size-in-bytes 160, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "unsigned char", :datatype :coffi.mem/char, :name "nb_components", :calculated-offset 64} {:type "unsigned char", :datatype :coffi.mem/char, :name "log2_chroma_w", :calculated-offset 72} {:type "unsigned char", :datatype :coffi.mem/char, :name "log2_chroma_h", :calculated-offset 80} {:type "unsigned long long", :datatype :coffi.mem/long, :name "flags", :calculated-offset 128} {:type "struct AVComponentDescriptor [4]", :datatype [:coffi.mem/array :clong/AVComponentDescriptor 4], :name "comp", :calculated-offset 192} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "alias", :calculated-offset 1216}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHWFramesContext", :type "CXType_Record", :id :clong/AVHWFramesContext, :size-in-bytes 88, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "struct AVHWFramesInternal *", :datatype [:coffi.mem/pointer :clong/AVHWFramesInternal], :name "internal", :calculated-offset 64} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "device_ref", :calculated-offset 128} {:type "struct AVHWDeviceContext *", :datatype [:coffi.mem/pointer :clong/AVHWDeviceContext], :name "device_ctx", :calculated-offset 192} {:type "void *", :datatype :coffi.mem/pointer, :name "hwctx", :calculated-offset 256} {:type "void (*)(struct AVHWFramesContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVHWFramesContext]] :coffi.mem/void], :name "free", :calculated-offset 320} {:type "void *", :datatype :coffi.mem/pointer, :name "user_opaque", :calculated-offset 384} {:type "struct AVBufferPool *", :datatype [:coffi.mem/pointer :clong/AVBufferPool], :name "pool", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "initial_pool_size", :calculated-offset 512} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "format", :calculated-offset 544} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "sw_format", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 608} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 640}]} {:kind "CXCursor_StructDecl", :spelling "struct AVMediaCodecDeviceContext", :type "CXType_Record", :id :clong/AVMediaCodecDeviceContext, :size-in-bytes 8, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "surface", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDOVIDecoderConfigurationRecord", :type "CXType_Record", :id :clong/AVDOVIDecoderConfigurationRecord, :size-in-bytes 8, :fields [{:type "unsigned char", :datatype :coffi.mem/char, :name "dv_version_major", :calculated-offset 0} {:type "unsigned char", :datatype :coffi.mem/char, :name "dv_version_minor", :calculated-offset 8} {:type "unsigned char", :datatype :coffi.mem/char, :name "dv_profile", :calculated-offset 16} {:type "unsigned char", :datatype :coffi.mem/char, :name "dv_level", :calculated-offset 24} {:type "unsigned char", :datatype :coffi.mem/char, :name "rpu_present_flag", :calculated-offset 32} {:type "unsigned char", :datatype :coffi.mem/char, :name "el_present_flag", :calculated-offset 40} {:type "unsigned char", :datatype :coffi.mem/char, :name "bl_present_flag", :calculated-offset 48} {:type "unsigned char", :datatype :coffi.mem/char, :name "dv_bl_signal_compatibility_id", :calculated-offset 56}]} {:kind "CXCursor_StructDecl", :spelling "struct AVIOInterruptCB", :type "CXType_Record", :id :clong/AVIOInterruptCB, :size-in-bytes 16, :fields [{:type "int (*)(void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/int], :name "callback", :calculated-offset 0} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDRMObjectDescriptor", :type "CXType_Record", :id :clong/AVDRMObjectDescriptor, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "fd", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "size", :calculated-offset 64} {:type "unsigned long long", :datatype :coffi.mem/long, :name "format_modifier", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVStereo3D", :type "CXType_Record", :id :clong/AVStereo3D, :size-in-bytes 12, :fields [{:type "enum AVStereo3DType", :datatype :coffi.mem/int, :name "type", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 32} {:type "enum AVStereo3DView", :datatype :coffi.mem/int, :name "view", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVRC4", :type "CXType_Record", :id :clong/AVRC4, :size-in-bytes 264, :fields [{:type "unsigned char [256]", :datatype [:coffi.mem/array :coffi.mem/char 256], :name "state", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "x", :calculated-offset 2048} {:type "int", :datatype :coffi.mem/int, :name "y", :calculated-offset 2080}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPacketSideData", :type "CXType_Record", :id :clong/AVPacketSideData, :size-in-bytes 16, :fields [{:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "data", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "size", :calculated-offset 64} {:type "enum AVPacketSideDataType", :datatype :coffi.mem/int, :name "type", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "XvMCSurfaceInfo", :type "CXType_Record", :id :clong/XvMCSurfaceInfo, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "surface_type_id", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "chroma_format", :calculated-offset 32} {:type "unsigned short", :datatype :coffi.mem/short, :name "max_width", :calculated-offset 64} {:type "unsigned short", :datatype :coffi.mem/short, :name "max_height", :calculated-offset 80} {:type "unsigned short", :datatype :coffi.mem/short, :name "subpicture_max_width", :calculated-offset 96} {:type "unsigned short", :datatype :coffi.mem/short, :name "subpicture_max_height", :calculated-offset 112} {:type "int", :datatype :coffi.mem/int, :name "mc_type", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecHWConfig", :type "CXType_Record", :id :clong/AVCodecHWConfig, :size-in-bytes 12, :fields [{:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pix_fmt", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "methods", :calculated-offset 32} {:type "enum AVHWDeviceType", :datatype :coffi.mem/int, :name "device_type", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilter", :type "CXType_Record", :id :clong/AVFilter, :size-in-bytes 128, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "description", :calculated-offset 64} {:type "const struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "inputs", :calculated-offset 128} {:type "const struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "outputs", :calculated-offset 192} {:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "priv_class", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 320} {:type "int (*)(struct AVFilterContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext]] :coffi.mem/int], :name "preinit", :calculated-offset 384} {:type "int (*)(struct AVFilterContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext]] :coffi.mem/int], :name "init", :calculated-offset 448} {:type "int (*)(struct AVFilterContext *, struct AVDictionary **)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]] :coffi.mem/int], :name "init_dict", :calculated-offset 512} {:type "void (*)(struct AVFilterContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext]] :coffi.mem/void], :name "uninit", :calculated-offset 576} {:type "int (*)(struct AVFilterContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext]] :coffi.mem/int], :name "query_formats", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "priv_size", :calculated-offset 704} {:type "int", :datatype :coffi.mem/int, :name "flags_internal", :calculated-offset 736} {:type "struct AVFilter *", :datatype [:coffi.mem/pointer :clong/AVFilter], :name "next", :calculated-offset 768} {:type "int (*)(struct AVFilterContext *, const char *, const char *, char *, int, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int] :coffi.mem/int], :name "process_command", :calculated-offset 832} {:type "int (*)(struct AVFilterContext *, void *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/pointer] :coffi.mem/int], :name "init_opaque", :calculated-offset 896} {:type "int (*)(struct AVFilterContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext]] :coffi.mem/int], :name "activate", :calculated-offset 960}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilmGrainParams", :type "CXType_Record", :id :clong/AVFilmGrainParams, :size-in-bytes 224, :fields [{:type "enum AVFilmGrainParamsType", :datatype :coffi.mem/int, :name "type", :calculated-offset 0} {:type "unsigned long long", :datatype :coffi.mem/long, :name "seed", :calculated-offset 64} {:type "union AVFilmGrainParams::(unnamed at /opt/local/include/libavutil/film_grain_params.h:144:5)", :datatype [:coffi.mem/array :coffi.mem/char 208], :name "codec", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "XvMCContext", :type "CXType_Record", :id :clong/XvMCContext, :size-in-bytes 40, :fields [{:type "unsigned long", :datatype :coffi.mem/long, :name "context_id", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "surface_type_id", :calculated-offset 64} {:type "unsigned short", :datatype :coffi.mem/short, :name "width", :calculated-offset 96} {:type "unsigned short", :datatype :coffi.mem/short, :name "height", :calculated-offset 112} {:type "unsigned long", :datatype :coffi.mem/long, :name "port", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 192} {:type "void *", :datatype :coffi.mem/pointer, :name "privData", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilterContext", :type "CXType_Record", :id :clong/AVFilterContext, :size-in-bytes 168, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "const struct AVFilter *", :datatype [:coffi.mem/pointer :clong/AVFilter], :name "filter", :calculated-offset 64} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 128} {:type "struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "input_pads", :calculated-offset 192} {:type "struct AVFilterLink **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterLink]], :name "inputs", :calculated-offset 256} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_inputs", :calculated-offset 320} {:type "struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "output_pads", :calculated-offset 384} {:type "struct AVFilterLink **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterLink]], :name "outputs", :calculated-offset 448} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_outputs", :calculated-offset 512} {:type "void *", :datatype :coffi.mem/pointer, :name "priv", :calculated-offset 576} {:type "struct AVFilterGraph *", :datatype [:coffi.mem/pointer :clong/AVFilterGraph], :name "graph", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "thread_type", :calculated-offset 704} {:type "struct AVFilterInternal *", :datatype [:coffi.mem/pointer :clong/AVFilterInternal], :name "internal", :calculated-offset 768} {:type "struct AVFilterCommand *", :datatype [:coffi.mem/pointer :clong/AVFilterCommand], :name "command_queue", :calculated-offset 832} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "enable_str", :calculated-offset 896} {:type "void *", :datatype :coffi.mem/pointer, :name "enable", :calculated-offset 960} {:type "double *", :datatype [:coffi.mem/pointer :coffi.mem/double], :name "var_values", :calculated-offset 1024} {:type "int", :datatype :coffi.mem/int, :name "is_disabled", :calculated-offset 1088} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_device_ctx", :calculated-offset 1152} {:type "int", :datatype :coffi.mem/int, :name "nb_threads", :calculated-offset 1216} {:type "unsigned int", :datatype :coffi.mem/int, :name "ready", :calculated-offset 1248} {:type "int", :datatype :coffi.mem/int, :name "extra_hw_frames", :calculated-offset 1280}]} {:kind "CXCursor_StructDecl", :spelling "struct AVProducerReferenceTime", :type "CXType_Record", :id :clong/AVProducerReferenceTime, :size-in-bytes 16, :fields [{:type "long long", :datatype :coffi.mem/long, :name "wallclock", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBitStreamFilter", :type "CXType_Record", :id :clong/AVBitStreamFilter, :size-in-bytes 64, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const enum AVCodecID *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "codec_ids", :calculated-offset 64} {:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "priv_class", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 192} {:type "int (*)(struct AVBSFContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVBSFContext]] :coffi.mem/int], :name "init", :calculated-offset 256} {:type "int (*)(struct AVBSFContext *, struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVBSFContext] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "filter", :calculated-offset 320} {:type "void (*)(struct AVBSFContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVBSFContext]] :coffi.mem/void], :name "close", :calculated-offset 384} {:type "void (*)(struct AVBSFContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVBSFContext]] :coffi.mem/void], :name "flush", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVRational", :type "CXType_Record", :id :clong/AVRational, :size-in-bytes 8, :fields [{:type "int", :datatype :coffi.mem/int, :name "num", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "den", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDeviceCapabilitiesQuery", :type "CXType_Record", :id :clong/AVDeviceCapabilitiesQuery, :size-in-bytes 72, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "struct AVFormatContext *", :datatype [:coffi.mem/pointer :clong/AVFormatContext], :name "device_context", :calculated-offset 64} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "codec", :calculated-offset 128} {:type "enum AVSampleFormat", :datatype :coffi.mem/int, :name "sample_format", :calculated-offset 160} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pixel_format", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 224} {:type "int", :datatype :coffi.mem/int, :name "channels", :calculated-offset 256} {:type "long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "window_width", :calculated-offset 384} {:type "int", :datatype :coffi.mem/int, :name "window_height", :calculated-offset 416} {:type "int", :datatype :coffi.mem/int, :name "frame_width", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "frame_height", :calculated-offset 480} {:type "struct AVRational", :datatype :clong/AVRational, :name "fps", :calculated-offset 512}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBufferSrcParameters", :type "CXType_Record", :id :clong/AVBufferSrcParameters, :size-in-bytes 64, :fields [{:type "int", :datatype :coffi.mem/int, :name "format", :calculated-offset 0} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 128} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 160} {:type "struct AVRational", :datatype :clong/AVRational, :name "frame_rate", :calculated-offset 224} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_frames_ctx", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 384} {:type "unsigned long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHDRPlusPercentile", :type "CXType_Record", :id :clong/AVHDRPlusPercentile, :size-in-bytes 12, :fields [{:type "unsigned char", :datatype :coffi.mem/char, :name "percentage", :calculated-offset 0} {:type "struct AVRational", :datatype :clong/AVRational, :name "percentile", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDeviceInfoList", :type "CXType_Record", :id :clong/AVDeviceInfoList, :size-in-bytes 16, :fields [{:type "struct AVDeviceInfo **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDeviceInfo]], :name "devices", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "nb_devices", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "default_device", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHWAccel", :type "CXType_Record", :id :clong/AVHWAccel, :size-in-bytes 112, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "enum AVMediaType", :datatype :coffi.mem/int, :name "type", :calculated-offset 64} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "id", :calculated-offset 96} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pix_fmt", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "capabilities", :calculated-offset 160} {:type "int (*)(struct AVCodecContext *, struct AVFrame *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame]] :coffi.mem/int], :name "alloc_frame", :calculated-offset 192} {:type "int (*)(struct AVCodecContext *, const unsigned char *, unsigned int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "start_frame", :calculated-offset 256} {:type "int (*)(struct AVCodecContext *, int, const unsigned char *, unsigned int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "decode_params", :calculated-offset 320} {:type "int (*)(struct AVCodecContext *, const unsigned char *, unsigned int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "decode_slice", :calculated-offset 384} {:type "int (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "end_frame", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "frame_priv_data_size", :calculated-offset 512} {:type "void (*)(struct MpegEncContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/MpegEncContext]] :coffi.mem/void], :name "decode_mb", :calculated-offset 576} {:type "int (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "init", :calculated-offset 640} {:type "int (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "uninit", :calculated-offset 704} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 768} {:type "int", :datatype :coffi.mem/int, :name "caps_internal", :calculated-offset 800} {:type "int (*)(struct AVCodecContext *, struct AVBufferRef *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVBufferRef]] :coffi.mem/int], :name "frame_params", :calculated-offset 832}]} {:kind "CXCursor_StructDecl", :spelling "struct AVReplayGain", :type "CXType_Record", :id :clong/AVReplayGain, :size-in-bytes 16, :fields [{:type "int", :datatype :coffi.mem/int, :name "track_gain", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "track_peak", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "album_gain", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "album_peak", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDCT", :type "CXType_Record", :id :clong/AVDCT, :size-in-bytes 120, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "void (*)(short *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/short]] :coffi.mem/void], :name "idct", :calculated-offset 64} {:type "unsigned char [64]", :datatype [:coffi.mem/array :coffi.mem/char 64], :name "idct_permutation", :calculated-offset 128} {:type "void (*)(short *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/short]] :coffi.mem/void], :name "fdct", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "dct_algo", :calculated-offset 704} {:type "int", :datatype :coffi.mem/int, :name "idct_algo", :calculated-offset 736} {:type "void (*)(short *, const unsigned char *, long)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/short] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long] :coffi.mem/void], :name "get_pixels", :calculated-offset 768} {:type "int", :datatype :coffi.mem/int, :name "bits_per_sample", :calculated-offset 832} {:type "void (*)(short *, const unsigned char *, long)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/short] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/long] :coffi.mem/void], :name "get_pixels_unaligned", :calculated-offset 896}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOptionRanges", :type "CXType_Record", :id :clong/AVOptionRanges, :size-in-bytes 16, :fields [{:type "struct AVOptionRange **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOptionRange]], :name "range", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "nb_ranges", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "nb_components", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilterGraph", :type "CXType_Record", :id :clong/AVFilterGraph, :size-in-bytes 96, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "struct AVFilterContext **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterContext]], :name "filters", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_filters", :calculated-offset 128} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "scale_sws_opts", :calculated-offset 192} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "resample_lavr_opts", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "thread_type", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "nb_threads", :calculated-offset 352} {:type "struct AVFilterGraphInternal *", :datatype [:coffi.mem/pointer :clong/AVFilterGraphInternal], :name "internal", :calculated-offset 384} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 448} {:type "int (*)(struct AVFilterContext *, int (*)(struct AVFilterContext *, void *, int, int), void *, int *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFilterContext] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int] :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int] :coffi.mem/int], :name "execute", :calculated-offset 512} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "aresample_swr_opts", :calculated-offset 576} {:type "struct AVFilterLink **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFilterLink]], :name "sink_links", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "sink_links_count", :calculated-offset 704} {:type "unsigned int", :datatype :coffi.mem/int, :name "disable_auto_convert", :calculated-offset 736}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHDRPlusColorTransformParams", :type "CXType_Record", :id :clong/AVHDRPlusColorTransformParams, :size-in-bytes 428, :fields [{:type "struct AVRational", :datatype :clong/AVRational, :name "window_upper_left_corner_x", :calculated-offset 0} {:type "struct AVRational", :datatype :clong/AVRational, :name "window_upper_left_corner_y", :calculated-offset 64} {:type "struct AVRational", :datatype :clong/AVRational, :name "window_lower_right_corner_x", :calculated-offset 128} {:type "struct AVRational", :datatype :clong/AVRational, :name "window_lower_right_corner_y", :calculated-offset 192} {:type "unsigned short", :datatype :coffi.mem/short, :name "center_of_ellipse_x", :calculated-offset 256} {:type "unsigned short", :datatype :coffi.mem/short, :name "center_of_ellipse_y", :calculated-offset 272} {:type "unsigned char", :datatype :coffi.mem/char, :name "rotation_angle", :calculated-offset 288} {:type "unsigned short", :datatype :coffi.mem/short, :name "semimajor_axis_internal_ellipse", :calculated-offset 304} {:type "unsigned short", :datatype :coffi.mem/short, :name "semimajor_axis_external_ellipse", :calculated-offset 320} {:type "unsigned short", :datatype :coffi.mem/short, :name "semiminor_axis_external_ellipse", :calculated-offset 336} {:type "enum AVHDRPlusOverlapProcessOption", :datatype :coffi.mem/int, :name "overlap_process_option", :calculated-offset 352} {:type "struct AVRational [3]", :datatype [:coffi.mem/array :clong/AVRational 3], :name "maxscl", :calculated-offset 384} {:type "struct AVRational", :datatype :clong/AVRational, :name "average_maxrgb", :calculated-offset 576} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_distribution_maxrgb_percentiles", :calculated-offset 640} {:type "struct AVHDRPlusPercentile [15]", :datatype [:coffi.mem/array :clong/AVHDRPlusPercentile 15], :name "distribution_maxrgb", :calculated-offset 672} {:type "struct AVRational", :datatype :clong/AVRational, :name "fraction_bright_pixels", :calculated-offset 2112} {:type "unsigned char", :datatype :coffi.mem/char, :name "tone_mapping_flag", :calculated-offset 2176} {:type "struct AVRational", :datatype :clong/AVRational, :name "knee_point_x", :calculated-offset 2208} {:type "struct AVRational", :datatype :clong/AVRational, :name "knee_point_y", :calculated-offset 2272} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_bezier_curve_anchors", :calculated-offset 2336} {:type "struct AVRational [15]", :datatype [:coffi.mem/array :clong/AVRational 15], :name "bezier_curve_anchors", :calculated-offset 2368} {:type "unsigned char", :datatype :coffi.mem/char, :name "color_saturation_mapping_flag", :calculated-offset 3328} {:type "struct AVRational", :datatype :clong/AVRational, :name "color_saturation_weight", :calculated-offset 3360}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOptionRange", :type "CXType_Record", :id :clong/AVOptionRange, :size-in-bytes 48, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "str", :calculated-offset 0} {:type "double", :datatype :coffi.mem/double, :name "value_min", :calculated-offset 64} {:type "double", :datatype :coffi.mem/double, :name "value_max", :calculated-offset 128} {:type "double", :datatype :coffi.mem/double, :name "component_min", :calculated-offset 192} {:type "double", :datatype :coffi.mem/double, :name "component_max", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "is_range", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :spelling "struct AVLFG", :type "CXType_Record", :id :clong/AVLFG, :size-in-bytes 260, :fields [{:type "unsigned int [64]", :datatype [:coffi.mem/array :coffi.mem/int 64], :name "state", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "index", :calculated-offset 2048}]} {:kind "CXCursor_StructDecl", :spelling "struct AVClass", :type "CXType_Record", :id :clong/AVClass, :size-in-bytes 88, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "class_name", :calculated-offset 0} {:type "const char *(*)(void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/char]], :name "item_name", :calculated-offset 64} {:type "const struct AVOption *", :datatype [:coffi.mem/pointer :clong/AVOption], :name "option", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "version", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "log_level_offset_offset", :calculated-offset 224} {:type "int", :datatype :coffi.mem/int, :name "parent_log_context_offset", :calculated-offset 256} {:type "void *(*)(void *, void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/pointer], :name "child_next", :calculated-offset 320} {:type "const struct AVClass *(*)(const struct AVClass *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVClass]] [:coffi.mem/pointer :clong/AVClass]], :name "child_class_next", :calculated-offset 384} {:type "AVClassCategory", :datatype :coffi.mem/int, :name "category", :calculated-offset 448} {:type "AVClassCategory (*)(void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/int], :name "get_category", :calculated-offset 512} {:type "int (*)(struct AVOptionRanges **, void *, const char *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer [:coffi.mem/pointer :clong/AVOptionRanges]] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "query_ranges", :calculated-offset 576} {:type "const struct AVClass *(*)(void **)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :coffi.mem/pointer]] [:coffi.mem/pointer :clong/AVClass]], :name "child_class_iterate", :calculated-offset 640}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDeviceInfo", :type "CXType_Record", :id :clong/AVDeviceInfo, :size-in-bytes 16, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "device_name", :calculated-offset 0} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "device_description", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBufferSinkParams", :type "CXType_Record", :id :clong/AVBufferSinkParams, :size-in-bytes 8, :fields [{:type "const enum AVPixelFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "pixel_fmts", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHWDeviceContext", :type "CXType_Record", :id :clong/AVHWDeviceContext, :size-in-bytes 48, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "struct AVHWDeviceInternal *", :datatype [:coffi.mem/pointer :clong/AVHWDeviceInternal], :name "internal", :calculated-offset 64} {:type "enum AVHWDeviceType", :datatype :coffi.mem/int, :name "type", :calculated-offset 128} {:type "void *", :datatype :coffi.mem/pointer, :name "hwctx", :calculated-offset 192} {:type "void (*)(struct AVHWDeviceContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVHWDeviceContext]] :coffi.mem/void], :name "free", :calculated-offset 256} {:type "void *", :datatype :coffi.mem/pointer, :name "user_opaque", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :spelling "XvMCSubpicture", :type "CXType_Record", :id :clong/XvMCSubpicture, :size-in-bytes 48, :fields [{:type "unsigned long", :datatype :coffi.mem/long, :name "subpicture_id", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "context_id", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "xvimage_id", :calculated-offset 128} {:type "unsigned short", :datatype :coffi.mem/short, :name "width", :calculated-offset 160} {:type "unsigned short", :datatype :coffi.mem/short, :name "height", :calculated-offset 176} {:type "int", :datatype :coffi.mem/int, :name "num_palette_entries", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "entry_bytes", :calculated-offset 224} {:type "char [4]", :datatype [:coffi.mem/array :coffi.mem/char 4], :name "component_order", :calculated-offset 256} {:type "void *", :datatype :coffi.mem/pointer, :name "privData", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDRMFrameDescriptor", :type "CXType_Record", :id :clong/AVDRMFrameDescriptor, :size-in-bytes 528, :fields [{:type "int", :datatype :coffi.mem/int, :name "nb_objects", :calculated-offset 0} {:type "struct AVDRMObjectDescriptor [4]", :datatype [:coffi.mem/array :clong/AVDRMObjectDescriptor 4], :name "objects", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "nb_layers", :calculated-offset 832} {:type "struct AVDRMLayerDescriptor [4]", :datatype [:coffi.mem/array :clong/AVDRMLayerDescriptor 4], :name "layers", :calculated-offset 896}]} {:kind "CXCursor_StructDecl", :spelling "struct AVComplexDouble", :type "CXType_Record", :id :clong/AVComplexDouble, :size-in-bytes 16, :fields [{:type "double", :datatype :coffi.mem/double, :name "re", :calculated-offset 0} {:type "double", :datatype :coffi.mem/double, :name "im", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDVProfile", :type "CXType_Record", :id :clong/AVDVProfile, :size-in-bytes 120, :fields [{:type "int", :datatype :coffi.mem/int, :name "dsf", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "video_stype", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "frame_size", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "difseg_size", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "n_difchan", :calculated-offset 128} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 160} {:type "int", :datatype :coffi.mem/int, :name "ltc_divisor", :calculated-offset 224} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 288} {:type "struct AVRational [2]", :datatype [:coffi.mem/array :clong/AVRational 2], :name "sar", :calculated-offset 320} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pix_fmt", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "bpm", :calculated-offset 480} {:type "const unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "block_sizes", :calculated-offset 512} {:type "int", :datatype :coffi.mem/int, :name "audio_stride", :calculated-offset 576} {:type "int [3]", :datatype [:coffi.mem/array :coffi.mem/int 3], :name "audio_min_samples", :calculated-offset 608} {:type "int [5]", :datatype [:coffi.mem/array :coffi.mem/int 5], :name "audio_samples_dist", :calculated-offset 704} {:type "unsigned char const (*)[9]", :datatype [:coffi.mem/pointer [:coffi.mem/array :coffi.mem/char 9]], :name "audio_shuffle", :calculated-offset 896}]} {:kind "CXCursor_StructDecl", :spelling "struct SwsFilter", :type "CXType_Record", :id :clong/SwsFilter, :size-in-bytes 32, :fields [{:type "struct SwsVector *", :datatype [:coffi.mem/pointer :clong/SwsVector], :name "lumH", :calculated-offset 0} {:type "struct SwsVector *", :datatype [:coffi.mem/pointer :clong/SwsVector], :name "lumV", :calculated-offset 64} {:type "struct SwsVector *", :datatype [:coffi.mem/pointer :clong/SwsVector], :name "chrH", :calculated-offset 128} {:type "struct SwsVector *", :datatype [:coffi.mem/pointer :clong/SwsVector], :name "chrV", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDictionaryEntry", :type "CXType_Record", :id :clong/AVDictionaryEntry, :size-in-bytes 16, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "key", :calculated-offset 0} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "value", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVVideotoolboxContext", :type "CXType_Record", :id :clong/AVVideotoolboxContext, :size-in-bytes 40, :fields [{:type "struct OpaqueVTDecompressionSession *", :datatype [:coffi.mem/pointer :clong/OpaqueVTDecompressionSession], :name "session", :calculated-offset 0} {:type "void (*)(void *, void *, int, unsigned int, struct __CVBuffer *, CMTime, CMTime)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clong/__CVBuffer] :clong/CMTime :clong/CMTime] :coffi.mem/void], :name "output_callback", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "cv_pix_fmt_type", :calculated-offset 128} {:type "const struct opaqueCMFormatDescription *", :datatype [:coffi.mem/pointer :clong/opaqueCMFormatDescription], :name "cm_fmt_desc", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "cm_codec_type", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOpenCLFramesContext", :type "CXType_Record", :id :clong/AVOpenCLFramesContext, :size-in-bytes 8, :fields [{:type "struct _cl_command_queue *", :datatype [:coffi.mem/pointer :clong/_cl_command_queue], :name "command_queue", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVComponentDescriptor", :type "CXType_Record", :id :clong/AVComponentDescriptor, :size-in-bytes 32, :fields [{:type "int", :datatype :coffi.mem/int, :name "plane", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "step", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "offset", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "shift", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "depth", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "step_minus1", :calculated-offset 160} {:type "int", :datatype :coffi.mem/int, :name "depth_minus1", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "offset_plus1", :calculated-offset 224}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBSFContext", :type "CXType_Record", :id :clong/AVBSFContext, :size-in-bytes 64, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "const struct AVBitStreamFilter *", :datatype [:coffi.mem/pointer :clong/AVBitStreamFilter], :name "filter", :calculated-offset 64} {:type "struct AVBSFInternal *", :datatype [:coffi.mem/pointer :clong/AVBSFInternal], :name "internal", :calculated-offset 128} {:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 192} {:type "struct AVCodecParameters *", :datatype [:coffi.mem/pointer :clong/AVCodecParameters], :name "par_in", :calculated-offset 256} {:type "struct AVCodecParameters *", :datatype [:coffi.mem/pointer :clong/AVCodecParameters], :name "par_out", :calculated-offset 320} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base_in", :calculated-offset 384} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base_out", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBlowfish", :type "CXType_Record", :id :clong/AVBlowfish, :size-in-bytes 4168, :fields [{:type "unsigned int [18]", :datatype [:coffi.mem/array :coffi.mem/int 18], :name "p", :calculated-offset 0} {:type "unsigned int [4][256]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/int 256] 4], :name "s", :calculated-offset 576}]} {:kind "CXCursor_StructDecl", :spelling "struct AVChapter", :type "CXType_Record", :id :clong/AVChapter, :size-in-bytes 40, :fields [{:type "int", :datatype :coffi.mem/int, :name "id", :calculated-offset 0} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 32} {:type "long long", :datatype :coffi.mem/long, :name "start", :calculated-offset 128} {:type "long long", :datatype :coffi.mem/long, :name "end", :calculated-offset 192} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecParser", :type "CXType_Record", :id :clong/AVCodecParser, :size-in-bytes 64, :fields [{:type "int [5]", :datatype [:coffi.mem/array :coffi.mem/int 5], :name "codec_ids", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 160} {:type "int (*)(struct AVCodecParserContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecParserContext]] :coffi.mem/int], :name "parser_init", :calculated-offset 192} {:type "int (*)(struct AVCodecParserContext *, struct AVCodecContext *, const unsigned char **, int *, const unsigned char *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecParserContext] [:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "parser_parse", :calculated-offset 256} {:type "void (*)(struct AVCodecParserContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecParserContext]] :coffi.mem/void], :name "parser_close", :calculated-offset 320} {:type "int (*)(struct AVCodecContext *, const unsigned char *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "split", :calculated-offset 384} {:type "struct AVCodecParser *", :datatype [:coffi.mem/pointer :clong/AVCodecParser], :name "next", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCPBProperties", :type "CXType_Record", :id :clong/AVCPBProperties, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "max_bitrate", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "min_bitrate", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "avg_bitrate", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "buffer_size", :calculated-offset 96} {:type "unsigned long long", :datatype :coffi.mem/long, :name "vbv_delay", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVEncryptionInitInfo", :type "CXType_Record", :id :clong/AVEncryptionInitInfo, :size-in-bytes 56, :fields [{:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "system_id", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "system_id_size", :calculated-offset 64} {:type "unsigned char **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :name "key_ids", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "num_key_ids", :calculated-offset 192} {:type "unsigned int", :datatype :coffi.mem/int, :name "key_id_size", :calculated-offset 224} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "data", :calculated-offset 256} {:type "unsigned int", :datatype :coffi.mem/int, :name "data_size", :calculated-offset 320} {:type "struct AVEncryptionInitInfo *", :datatype [:coffi.mem/pointer :clong/AVEncryptionInitInfo], :name "next", :calculated-offset 384}]} {:kind "CXCursor_StructDecl", :spelling "struct AVMotionVector", :type "CXType_Record", :id :clong/AVMotionVector, :size-in-bytes 40, :fields [{:type "int", :datatype :coffi.mem/int, :name "source", :calculated-offset 0} {:type "unsigned char", :datatype :coffi.mem/char, :name "w", :calculated-offset 32} {:type "unsigned char", :datatype :coffi.mem/char, :name "h", :calculated-offset 40} {:type "short", :datatype :coffi.mem/short, :name "src_x", :calculated-offset 48} {:type "short", :datatype :coffi.mem/short, :name "src_y", :calculated-offset 64} {:type "short", :datatype :coffi.mem/short, :name "dst_x", :calculated-offset 80} {:type "short", :datatype :coffi.mem/short, :name "dst_y", :calculated-offset 96} {:type "unsigned long long", :datatype :coffi.mem/long, :name "flags", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "motion_x", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "motion_y", :calculated-offset 224} {:type "unsigned short", :datatype :coffi.mem/short, :name "motion_scale", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOpenCLDeviceContext", :type "CXType_Record", :id :clong/AVOpenCLDeviceContext, :size-in-bytes 24, :fields [{:type "struct _cl_device_id *", :datatype [:coffi.mem/pointer :clong/_cl_device_id], :name "device_id", :calculated-offset 0} {:type "struct _cl_context *", :datatype [:coffi.mem/pointer :clong/_cl_context], :name "context", :calculated-offset 64} {:type "struct _cl_command_queue *", :datatype [:coffi.mem/pointer :clong/_cl_command_queue], :name "command_queue", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPacket", :type "CXType_Record", :id :clong/AVPacket, :size-in-bytes 88, :fields [{:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "buf", :calculated-offset 0} {:type "long long", :datatype :coffi.mem/long, :name "pts", :calculated-offset 64} {:type "long long", :datatype :coffi.mem/long, :name "dts", :calculated-offset 128} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "data", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "size", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "stream_index", :calculated-offset 288} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 320} {:type "struct AVPacketSideData *", :datatype [:coffi.mem/pointer :clong/AVPacketSideData], :name "side_data", :calculated-offset 384} {:type "int", :datatype :coffi.mem/int, :name "side_data_elems", :calculated-offset 448} {:type "long long", :datatype :coffi.mem/long, :name "duration", :calculated-offset 512} {:type "long long", :datatype :coffi.mem/long, :name "pos", :calculated-offset 576} {:type "long long", :datatype :coffi.mem/long, :name "convergence_duration", :calculated-offset 640}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPacketList", :type "CXType_Record", :id :clong/AVPacketList, :size-in-bytes 96, :fields [{:type "struct AVPacket", :datatype :clong/AVPacket, :name "pkt", :calculated-offset 0} {:type "struct AVPacketList *", :datatype [:coffi.mem/pointer :clong/AVPacketList], :name "next", :calculated-offset 704}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPanScan", :type "CXType_Record", :id :clong/AVPanScan, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "id", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 64} {:type "short [3][2]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/short 2] 3], :name "position", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct FFTComplex", :type "CXType_Record", :id :clong/FFTComplex, :size-in-bytes 8, :fields [{:type "float", :datatype :coffi.mem/float, :name "re", :calculated-offset 0} {:type "float", :datatype :coffi.mem/float, :name "im", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFormatContext", :type "CXType_Record", :id :clong/AVFormatContext, :size-in-bytes 1504, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "struct AVInputFormat *", :datatype [:coffi.mem/pointer :clong/AVInputFormat], :name "iformat", :calculated-offset 64} {:type "struct AVOutputFormat *", :datatype [:coffi.mem/pointer :clong/AVOutputFormat], :name "oformat", :calculated-offset 128} {:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 192} {:type "struct AVIOContext *", :datatype [:coffi.mem/pointer :clong/AVIOContext], :name "pb", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "ctx_flags", :calculated-offset 320} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_streams", :calculated-offset 352} {:type "struct AVStream **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVStream]], :name "streams", :calculated-offset 384} {:type "char [1024]", :datatype [:coffi.mem/array :coffi.mem/char 1024], :name "filename", :calculated-offset 448} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "url", :calculated-offset 8640} {:type "long long", :datatype :coffi.mem/long, :name "start_time", :calculated-offset 8704} {:type "long long", :datatype :coffi.mem/long, :name "duration", :calculated-offset 8768} {:type "long long", :datatype :coffi.mem/long, :name "bit_rate", :calculated-offset 8832} {:type "unsigned int", :datatype :coffi.mem/int, :name "packet_size", :calculated-offset 8896} {:type "int", :datatype :coffi.mem/int, :name "max_delay", :calculated-offset 8928} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 8960} {:type "long long", :datatype :coffi.mem/long, :name "probesize", :calculated-offset 9024} {:type "long long", :datatype :coffi.mem/long, :name "max_analyze_duration", :calculated-offset 9088} {:type "const unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "key", :calculated-offset 9152} {:type "int", :datatype :coffi.mem/int, :name "keylen", :calculated-offset 9216} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_programs", :calculated-offset 9248} {:type "struct AVProgram **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVProgram]], :name "programs", :calculated-offset 9280} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "video_codec_id", :calculated-offset 9344} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "audio_codec_id", :calculated-offset 9376} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "subtitle_codec_id", :calculated-offset 9408} {:type "unsigned int", :datatype :coffi.mem/int, :name "max_index_size", :calculated-offset 9440} {:type "unsigned int", :datatype :coffi.mem/int, :name "max_picture_buffer", :calculated-offset 9472} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_chapters", :calculated-offset 9504} {:type "struct AVChapter **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVChapter]], :name "chapters", :calculated-offset 9536} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 9600} {:type "long long", :datatype :coffi.mem/long, :name "start_time_realtime", :calculated-offset 9664} {:type "int", :datatype :coffi.mem/int, :name "fps_probe_size", :calculated-offset 9728} {:type "int", :datatype :coffi.mem/int, :name "error_recognition", :calculated-offset 9760} {:type "struct AVIOInterruptCB", :datatype :clong/AVIOInterruptCB, :name "interrupt_callback", :calculated-offset 9792} {:type "int", :datatype :coffi.mem/int, :name "debug", :calculated-offset 9920} {:type "long long", :datatype :coffi.mem/long, :name "max_interleave_delta", :calculated-offset 9984} {:type "int", :datatype :coffi.mem/int, :name "strict_std_compliance", :calculated-offset 10048} {:type "int", :datatype :coffi.mem/int, :name "event_flags", :calculated-offset 10080} {:type "int", :datatype :coffi.mem/int, :name "max_ts_probe", :calculated-offset 10112} {:type "int", :datatype :coffi.mem/int, :name "avoid_negative_ts", :calculated-offset 10144} {:type "int", :datatype :coffi.mem/int, :name "ts_id", :calculated-offset 10176} {:type "int", :datatype :coffi.mem/int, :name "audio_preload", :calculated-offset 10208} {:type "int", :datatype :coffi.mem/int, :name "max_chunk_duration", :calculated-offset 10240} {:type "int", :datatype :coffi.mem/int, :name "max_chunk_size", :calculated-offset 10272} {:type "int", :datatype :coffi.mem/int, :name "use_wallclock_as_timestamps", :calculated-offset 10304} {:type "int", :datatype :coffi.mem/int, :name "avio_flags", :calculated-offset 10336} {:type "enum AVDurationEstimationMethod", :datatype :coffi.mem/int, :name "duration_estimation_method", :calculated-offset 10368} {:type "long long", :datatype :coffi.mem/long, :name "skip_initial_bytes", :calculated-offset 10432} {:type "unsigned int", :datatype :coffi.mem/int, :name "correct_ts_overflow", :calculated-offset 10496} {:type "int", :datatype :coffi.mem/int, :name "seek2any", :calculated-offset 10528} {:type "int", :datatype :coffi.mem/int, :name "flush_packets", :calculated-offset 10560} {:type "int", :datatype :coffi.mem/int, :name "probe_score", :calculated-offset 10592} {:type "int", :datatype :coffi.mem/int, :name "format_probesize", :calculated-offset 10624} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "codec_whitelist", :calculated-offset 10688} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "format_whitelist", :calculated-offset 10752} {:type "struct AVFormatInternal *", :datatype [:coffi.mem/pointer :clong/AVFormatInternal], :name "internal", :calculated-offset 10816} {:type "int", :datatype :coffi.mem/int, :name "io_repositioned", :calculated-offset 10880} {:type "struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "video_codec", :calculated-offset 10944} {:type "struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "audio_codec", :calculated-offset 11008} {:type "struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "subtitle_codec", :calculated-offset 11072} {:type "struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "data_codec", :calculated-offset 11136} {:type "int", :datatype :coffi.mem/int, :name "metadata_header_padding", :calculated-offset 11200} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 11264} {:type "int (*)(struct AVFormatContext *, int, void *, unsigned long)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long] :coffi.mem/int], :name "control_message_cb", :calculated-offset 11328} {:type "long long", :datatype :coffi.mem/long, :name "output_ts_offset", :calculated-offset 11392} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "dump_separator", :calculated-offset 11456} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "data_codec_id", :calculated-offset 11520} {:type "int (*)(struct AVFormatContext *, struct AVIOContext **, const char *, int, const struct AVIOInterruptCB *, struct AVDictionary **)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVIOInterruptCB] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]] :coffi.mem/int], :name "open_cb", :calculated-offset 11584} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "protocol_whitelist", :calculated-offset 11648} {:type "int (*)(struct AVFormatContext *, struct AVIOContext **, const char *, int, struct AVDictionary **)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVIOContext]] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVDictionary]]] :coffi.mem/int], :name "io_open", :calculated-offset 11712} {:type "void (*)(struct AVFormatContext *, struct AVIOContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVIOContext]] :coffi.mem/void], :name "io_close", :calculated-offset 11776} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "protocol_blacklist", :calculated-offset 11840} {:type "int", :datatype :coffi.mem/int, :name "max_streams", :calculated-offset 11904} {:type "int", :datatype :coffi.mem/int, :name "skip_estimate_duration_from_pts", :calculated-offset 11936} {:type "int", :datatype :coffi.mem/int, :name "max_probe_packets", :calculated-offset 11968}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDownmixInfo", :type "CXType_Record", :id :clong/AVDownmixInfo, :size-in-bytes 48, :fields [{:type "enum AVDownmixType", :datatype :coffi.mem/int, :name "preferred_downmix_type", :calculated-offset 0} {:type "double", :datatype :coffi.mem/double, :name "center_mix_level", :calculated-offset 64} {:type "double", :datatype :coffi.mem/double, :name "center_mix_level_ltrt", :calculated-offset 128} {:type "double", :datatype :coffi.mem/double, :name "surround_mix_level", :calculated-offset 192} {:type "double", :datatype :coffi.mem/double, :name "surround_mix_level_ltrt", :calculated-offset 256} {:type "double", :datatype :coffi.mem/double, :name "lfe_mix_level", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecParameters", :type "CXType_Record", :id :clong/AVCodecParameters, :size-in-bytes 144, :fields [{:type "enum AVMediaType", :datatype :coffi.mem/int, :name "codec_type", :calculated-offset 0} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "codec_id", :calculated-offset 32} {:type "unsigned int", :datatype :coffi.mem/int, :name "codec_tag", :calculated-offset 64} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "extradata", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "extradata_size", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "format", :calculated-offset 224} {:type "long long", :datatype :coffi.mem/long, :name "bit_rate", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "bits_per_coded_sample", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "bits_per_raw_sample", :calculated-offset 352} {:type "int", :datatype :coffi.mem/int, :name "profile", :calculated-offset 384} {:type "int", :datatype :coffi.mem/int, :name "level", :calculated-offset 416} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 480} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 512} {:type "enum AVFieldOrder", :datatype :coffi.mem/int, :name "field_order", :calculated-offset 576} {:type "enum AVColorRange", :datatype :coffi.mem/int, :name "color_range", :calculated-offset 608} {:type "enum AVColorPrimaries", :datatype :coffi.mem/int, :name "color_primaries", :calculated-offset 640} {:type "enum AVColorTransferCharacteristic", :datatype :coffi.mem/int, :name "color_trc", :calculated-offset 672} {:type "enum AVColorSpace", :datatype :coffi.mem/int, :name "color_space", :calculated-offset 704} {:type "enum AVChromaLocation", :datatype :coffi.mem/int, :name "chroma_location", :calculated-offset 736} {:type "int", :datatype :coffi.mem/int, :name "video_delay", :calculated-offset 768} {:type "unsigned long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 832} {:type "int", :datatype :coffi.mem/int, :name "channels", :calculated-offset 896} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 928} {:type "int", :datatype :coffi.mem/int, :name "block_align", :calculated-offset 960} {:type "int", :datatype :coffi.mem/int, :name "frame_size", :calculated-offset 992} {:type "int", :datatype :coffi.mem/int, :name "initial_padding", :calculated-offset 1024} {:type "int", :datatype :coffi.mem/int, :name "trailing_padding", :calculated-offset 1056} {:type "int", :datatype :coffi.mem/int, :name "seek_preroll", :calculated-offset 1088}]} {:kind "CXCursor_StructDecl", :spelling "struct ff_pad_helper_AVBPrint", :type "CXType_Record", :id :clong/ff_pad_helper_AVBPrint, :size-in-bytes 24, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "str", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "len", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "size", :calculated-offset 96} {:type "unsigned int", :datatype :coffi.mem/int, :name "size_max", :calculated-offset 128} {:type "char [1]", :datatype [:coffi.mem/array :coffi.mem/char 1], :name "reserved_internal_buffer", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :spelling "struct AVIOContext", :type "CXType_Record", :id :clong/AVIOContext, :size-in-bytes 264, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buffer", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "buffer_size", :calculated-offset 128} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buf_ptr", :calculated-offset 192} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buf_end", :calculated-offset 256} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 320} {:type "int (*)(void *, unsigned char *, int)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "read_packet", :calculated-offset 384} {:type "int (*)(void *, unsigned char *, int)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/int], :name "write_packet", :calculated-offset 448} {:type "long long (*)(void *, long long, int)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/long :coffi.mem/int] :coffi.mem/long], :name "seek", :calculated-offset 512} {:type "long long", :datatype :coffi.mem/long, :name "pos", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "eof_reached", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "write_flag", :calculated-offset 672} {:type "int", :datatype :coffi.mem/int, :name "max_packet_size", :calculated-offset 704} {:type "unsigned long", :datatype :coffi.mem/long, :name "checksum", :calculated-offset 768} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "checksum_ptr", :calculated-offset 832} {:type "unsigned long (*)(unsigned long, const unsigned char *, unsigned int)", :datatype [:coffi.ffi/fn [:coffi.mem/long [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int] :coffi.mem/long], :name "update_checksum", :calculated-offset 896} {:type "int", :datatype :coffi.mem/int, :name "error", :calculated-offset 960} {:type "int (*)(void *, int)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int], :name "read_pause", :calculated-offset 1024} {:type "long long (*)(void *, int, long long, int)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/int :coffi.mem/long :coffi.mem/int] :coffi.mem/long], :name "read_seek", :calculated-offset 1088} {:type "int", :datatype :coffi.mem/int, :name "seekable", :calculated-offset 1152} {:type "long long", :datatype :coffi.mem/long, :name "maxsize", :calculated-offset 1216} {:type "int", :datatype :coffi.mem/int, :name "direct", :calculated-offset 1280} {:type "long long", :datatype :coffi.mem/long, :name "bytes_read", :calculated-offset 1344} {:type "int", :datatype :coffi.mem/int, :name "seek_count", :calculated-offset 1408} {:type "int", :datatype :coffi.mem/int, :name "writeout_count", :calculated-offset 1440} {:type "int", :datatype :coffi.mem/int, :name "orig_buffer_size", :calculated-offset 1472} {:type "int", :datatype :coffi.mem/int, :name "short_seek_threshold", :calculated-offset 1504} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "protocol_whitelist", :calculated-offset 1536} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "protocol_blacklist", :calculated-offset 1600} {:type "int (*)(void *, unsigned char *, int, enum AVIODataMarkerType, long long)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int :coffi.mem/long] :coffi.mem/int], :name "write_data_type", :calculated-offset 1664} {:type "int", :datatype :coffi.mem/int, :name "ignore_boundary_point", :calculated-offset 1728} {:type "enum AVIODataMarkerType", :datatype :coffi.mem/int, :name "current_type", :calculated-offset 1760} {:type "long long", :datatype :coffi.mem/long, :name "last_time", :calculated-offset 1792} {:type "int (*)(void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/int], :name "short_seek_get", :calculated-offset 1856} {:type "long long", :datatype :coffi.mem/long, :name "written", :calculated-offset 1920} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buf_ptr_max", :calculated-offset 1984} {:type "int", :datatype :coffi.mem/int, :name "min_packet_size", :calculated-offset 2048}]} {:kind "CXCursor_StructDecl", :spelling "struct AVProfile", :type "CXType_Record", :id :clong/AVProfile, :size-in-bytes 16, :fields [{:type "int", :datatype :coffi.mem/int, :name "profile", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVRegionOfInterest", :type "CXType_Record", :id :clong/AVRegionOfInterest, :size-in-bytes 28, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "self_size", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "top", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "bottom", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "left", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "right", :calculated-offset 128} {:type "struct AVRational", :datatype :clong/AVRational, :name "qoffset", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :spelling "struct tm", :type "CXType_Record", :id :clong/tm, :size-in-bytes 56, :fields [{:type "int", :datatype :coffi.mem/int, :name "tm_sec", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "tm_min", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "tm_hour", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "tm_mday", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "tm_mon", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "tm_year", :calculated-offset 160} {:type "int", :datatype :coffi.mem/int, :name "tm_wday", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "tm_yday", :calculated-offset 224} {:type "int", :datatype :coffi.mem/int, :name "tm_isdst", :calculated-offset 256} {:type "long", :datatype :coffi.mem/long, :name "tm_gmtoff", :calculated-offset 320} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "tm_zone", :calculated-offset 384}]} {:kind "CXCursor_StructDecl", :spelling "struct xvmc_pix_fmt", :type "CXType_Record", :id :clong/xvmc_pix_fmt, :size-in-bytes 88, :fields [{:type "int", :datatype :coffi.mem/int, :name "xvmc_id", :calculated-offset 0} {:type "short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "data_blocks", :calculated-offset 64} {:type "XvMCMacroBlock *", :datatype [:coffi.mem/pointer :clong/XvMCMacroBlock], :name "mv_blocks", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "allocated_mv_blocks", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "allocated_data_blocks", :calculated-offset 224} {:type "int", :datatype :coffi.mem/int, :name "idct", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "unsigned_intra", :calculated-offset 288} {:type "XvMCSurface *", :datatype [:coffi.mem/pointer :clong/XvMCSurface], :name "p_surface", :calculated-offset 320} {:type "XvMCSurface *", :datatype [:coffi.mem/pointer :clong/XvMCSurface], :name "p_past_surface", :calculated-offset 384} {:type "XvMCSurface *", :datatype [:coffi.mem/pointer :clong/XvMCSurface], :name "p_future_surface", :calculated-offset 448} {:type "unsigned int", :datatype :coffi.mem/int, :name "picture_structure", :calculated-offset 512} {:type "unsigned int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 544} {:type "int", :datatype :coffi.mem/int, :name "start_mv_blocks_num", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "filled_mv_blocks_num", :calculated-offset 608} {:type "int", :datatype :coffi.mem/int, :name "next_free_data_block_num", :calculated-offset 640}]} {:kind "CXCursor_StructDecl", :spelling "struct AVComplexInt32", :type "CXType_Record", :id :clong/AVComplexInt32, :size-in-bytes 8, :fields [{:type "int", :datatype :coffi.mem/int, :name "re", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "im", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDRMPlaneDescriptor", :type "CXType_Record", :id :clong/AVDRMPlaneDescriptor, :size-in-bytes 24, :fields [{:type "int", :datatype :coffi.mem/int, :name "object_index", :calculated-offset 0} {:type "long", :datatype :coffi.mem/long, :name "offset", :calculated-offset 64} {:type "long", :datatype :coffi.mem/long, :name "pitch", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVSubsampleEncryptionInfo", :type "CXType_Record", :id :clong/AVSubsampleEncryptionInfo, :size-in-bytes 8, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "bytes_of_clear_data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "bytes_of_protected_data", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct vaapi_context", :type "CXType_Record", :id :clong/vaapi_context, :size-in-bytes 16, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "display", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "config_id", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "context_id", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct SwsVector", :type "CXType_Record", :id :clong/SwsVector, :size-in-bytes 16, :fields [{:type "double *", :datatype [:coffi.mem/pointer :coffi.mem/double], :name "coeff", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "length", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDeviceRect", :type "CXType_Record", :id :clong/AVDeviceRect, :size-in-bytes 16, :fields [{:type "int", :datatype :coffi.mem/int, :name "x", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "y", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct AVProbeData", :type "CXType_Record", :id :clong/AVProbeData, :size-in-bytes 32, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "filename", :calculated-offset 0} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buf", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "buf_size", :calculated-offset 128} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "mime_type", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVIODirEntry", :type "CXType_Record", :id :clong/AVIODirEntry, :size-in-bytes 72, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "type", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "utf8", :calculated-offset 96} {:type "long long", :datatype :coffi.mem/long, :name "size", :calculated-offset 128} {:type "long long", :datatype :coffi.mem/long, :name "modification_timestamp", :calculated-offset 192} {:type "long long", :datatype :coffi.mem/long, :name "access_timestamp", :calculated-offset 256} {:type "long long", :datatype :coffi.mem/long, :name "status_change_timestamp", :calculated-offset 320} {:type "long long", :datatype :coffi.mem/long, :name "user_id", :calculated-offset 384} {:type "long long", :datatype :coffi.mem/long, :name "group_id", :calculated-offset 448} {:type "long long", :datatype :coffi.mem/long, :name "filemode", :calculated-offset 512}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBufferRef", :type "CXType_Record", :id :clong/AVBufferRef, :size-in-bytes 24, :fields [{:type "struct AVBuffer *", :datatype [:coffi.mem/pointer :clong/AVBuffer], :name "buffer", :calculated-offset 0} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "data", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "size", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDES", :type "CXType_Record", :id :clong/AVDES, :size-in-bytes 392, :fields [{:type "unsigned long long [3][16]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/long 16] 3], :name "round_keys", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "triple_des", :calculated-offset 3072}]} {:kind "CXCursor_StructDecl", :spelling "AVTimecode", :type "CXType_Record", :id :clong/AVTimecode, :size-in-bytes 20, :fields [{:type "int", :datatype :coffi.mem/int, :name "start", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 32} {:type "struct AVRational", :datatype :clong/AVRational, :name "rate", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "fps", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFifoBuffer", :type "CXType_Record", :id :clong/AVFifoBuffer, :size-in-bytes 40, :fields [{:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "buffer", :calculated-offset 0} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "rptr", :calculated-offset 64} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "wptr", :calculated-offset 128} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "end", :calculated-offset 192} {:type "unsigned int", :datatype :coffi.mem/int, :name "rndx", :calculated-offset 256} {:type "unsigned int", :datatype :coffi.mem/int, :name "wndx", :calculated-offset 288}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecDescriptor", :type "CXType_Record", :id :clong/AVCodecDescriptor, :size-in-bytes 48, :fields [{:type "enum AVCodecID", :datatype :coffi.mem/int, :name "id", :calculated-offset 0} {:type "enum AVMediaType", :datatype :coffi.mem/int, :name "type", :calculated-offset 32} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 64} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "long_name", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "props", :calculated-offset 192} {:type "const char *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :name "mime_types", :calculated-offset 256} {:type "const struct AVProfile *", :datatype [:coffi.mem/pointer :clong/AVProfile], :name "profiles", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDynamicHDRPlus", :type "CXType_Record", :id :clong/AVDynamicHDRPlus, :size-in-bytes 11304, :fields [{:type "unsigned char", :datatype :coffi.mem/char, :name "itu_t_t35_country_code", :calculated-offset 0} {:type "unsigned char", :datatype :coffi.mem/char, :name "application_version", :calculated-offset 8} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_windows", :calculated-offset 16} {:type "struct AVHDRPlusColorTransformParams [3]", :datatype [:coffi.mem/array :clong/AVHDRPlusColorTransformParams 3], :name "params", :calculated-offset 32} {:type "struct AVRational", :datatype :clong/AVRational, :name "targeted_system_display_maximum_luminance", :calculated-offset 10304} {:type "unsigned char", :datatype :coffi.mem/char, :name "targeted_system_display_actual_peak_luminance_flag", :calculated-offset 10368} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_rows_targeted_system_display_actual_peak_luminance", :calculated-offset 10376} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_cols_targeted_system_display_actual_peak_luminance", :calculated-offset 10384} {:type "struct AVRational [25][25]", :datatype [:coffi.mem/array [:coffi.mem/array :clong/AVRational 25] 25], :name "targeted_system_display_actual_peak_luminance", :calculated-offset 10400} {:type "unsigned char", :datatype :coffi.mem/char, :name "mastering_display_actual_peak_luminance_flag", :calculated-offset 50400} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_rows_mastering_display_actual_peak_luminance", :calculated-offset 50408} {:type "unsigned char", :datatype :coffi.mem/char, :name "num_cols_mastering_display_actual_peak_luminance", :calculated-offset 50416} {:type "struct AVRational [25][25]", :datatype [:coffi.mem/array [:coffi.mem/array :clong/AVRational 25] 25], :name "mastering_display_actual_peak_luminance", :calculated-offset 50432}]} {:kind "CXCursor_StructDecl", :spelling "struct AVSphericalMapping", :type "CXType_Record", :id :clong/AVSphericalMapping, :size-in-bytes 36, :fields [{:type "enum AVSphericalProjection", :datatype :coffi.mem/int, :name "projection", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "yaw", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "pitch", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "roll", :calculated-offset 96} {:type "unsigned int", :datatype :coffi.mem/int, :name "bound_left", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "bound_top", :calculated-offset 160} {:type "unsigned int", :datatype :coffi.mem/int, :name "bound_right", :calculated-offset 192} {:type "unsigned int", :datatype :coffi.mem/int, :name "bound_bottom", :calculated-offset 224} {:type "unsigned int", :datatype :coffi.mem/int, :name "padding", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVXTEA", :type "CXType_Record", :id :clong/AVXTEA, :size-in-bytes 64, :fields [{:type "unsigned int [16]", :datatype [:coffi.mem/array :coffi.mem/int 16], :name "key", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct RcOverride", :type "CXType_Record", :id :clong/RcOverride, :size-in-bytes 16, :fields [{:type "int", :datatype :coffi.mem/int, :name "start_frame", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "end_frame", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "qscale", :calculated-offset 64} {:type "float", :datatype :coffi.mem/float, :name "quality_factor", :calculated-offset 96}]} {:kind "CXCursor_StructDecl", :spelling "struct AVVideoEncParams", :type "CXType_Record", :id :clong/AVVideoEncParams, :size-in-bytes 64, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "nb_blocks", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "blocks_offset", :calculated-offset 64} {:type "unsigned long", :datatype :coffi.mem/long, :name "block_size", :calculated-offset 128} {:type "enum AVVideoEncParamsType", :datatype :coffi.mem/int, :name "type", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "qp", :calculated-offset 224} {:type "int [4][2]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/int 2] 4], :name "delta_qp", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilterInOut", :type "CXType_Record", :id :clong/AVFilterInOut, :size-in-bytes 32, :fields [{:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "struct AVFilterContext *", :datatype [:coffi.mem/pointer :clong/AVFilterContext], :name "filter_ctx", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "pad_idx", :calculated-offset 128} {:type "struct AVFilterInOut *", :datatype [:coffi.mem/pointer :clong/AVFilterInOut], :name "next", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVSubtitle", :type "CXType_Record", :id :clong/AVSubtitle, :size-in-bytes 32, :fields [{:type "unsigned short", :datatype :coffi.mem/short, :name "format", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "start_display_time", :calculated-offset 32} {:type "unsigned int", :datatype :coffi.mem/int, :name "end_display_time", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "num_rects", :calculated-offset 96} {:type "struct AVSubtitleRect **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVSubtitleRect]], :name "rects", :calculated-offset 128} {:type "long long", :datatype :coffi.mem/long, :name "pts", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFrameSideData", :type "CXType_Record", :id :clong/AVFrameSideData, :size-in-bytes 40, :fields [{:type "enum AVFrameSideDataType", :datatype :coffi.mem/int, :name "type", :calculated-offset 0} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "data", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "size", :calculated-offset 128} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 192} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "buf", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDRMLayerDescriptor", :type "CXType_Record", :id :clong/AVDRMLayerDescriptor, :size-in-bytes 104, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "format", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "nb_planes", :calculated-offset 32} {:type "struct AVDRMPlaneDescriptor [4]", :datatype [:coffi.mem/array :clong/AVDRMPlaneDescriptor 4], :name "planes", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVBitStreamFilterContext", :type "CXType_Record", :id :clong/AVBitStreamFilterContext, :size-in-bytes 40, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 0} {:type "const struct AVBitStreamFilter *", :datatype [:coffi.mem/pointer :clong/AVBitStreamFilter], :name "filter", :calculated-offset 64} {:type "struct AVCodecParserContext *", :datatype [:coffi.mem/pointer :clong/AVCodecParserContext], :name "parser", :calculated-offset 128} {:type "struct AVBitStreamFilterContext *", :datatype [:coffi.mem/pointer :clong/AVBitStreamFilterContext], :name "next", :calculated-offset 192} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "args", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct AVInputFormat", :type "CXType_Record", :id :clong/AVInputFormat, :size-in-bytes 168, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "long_name", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 128} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "extensions", :calculated-offset 192} {:type "const struct AVCodecTag *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecTag]], :name "codec_tag", :calculated-offset 256} {:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "priv_class", :calculated-offset 320} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "mime_type", :calculated-offset 384} {:type "struct AVInputFormat *", :datatype [:coffi.mem/pointer :clong/AVInputFormat], :name "next", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "raw_codec_id", :calculated-offset 512} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 544} {:type "int (*)(const struct AVProbeData *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVProbeData]] :coffi.mem/int], :name "read_probe", :calculated-offset 576} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "read_header", :calculated-offset 640} {:type "int (*)(struct AVFormatContext *, struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "read_packet", :calculated-offset 704} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "read_close", :calculated-offset 768} {:type "int (*)(struct AVFormatContext *, int, long long, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/long :coffi.mem/int] :coffi.mem/int], :name "read_seek", :calculated-offset 832} {:type "long long (*)(struct AVFormatContext *, int, long long *, long long)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long] :coffi.mem/long] :coffi.mem/long], :name "read_timestamp", :calculated-offset 896} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "read_play", :calculated-offset 960} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "read_pause", :calculated-offset 1024} {:type "int (*)(struct AVFormatContext *, int, long long, long long, long long, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/long :coffi.mem/long :coffi.mem/long :coffi.mem/int] :coffi.mem/int], :name "read_seek2", :calculated-offset 1088} {:type "int (*)(struct AVFormatContext *, struct AVDeviceInfoList *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceInfoList]] :coffi.mem/int], :name "get_device_list", :calculated-offset 1152} {:type "int (*)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] :coffi.mem/int], :name "create_device_capabilities", :calculated-offset 1216} {:type "int (*)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] :coffi.mem/int], :name "free_device_capabilities", :calculated-offset 1280}]} {:kind "CXCursor_StructDecl", :spelling "struct AVABufferSinkParams", :type "CXType_Record", :id :clong/AVABufferSinkParams, :size-in-bytes 40, :fields [{:type "const enum AVSampleFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "sample_fmts", :calculated-offset 0} {:type "const long long *", :datatype [:coffi.mem/pointer :coffi.mem/long], :name "channel_layouts", :calculated-offset 64} {:type "const int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "channel_counts", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "all_channel_counts", :calculated-offset 192} {:type "int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "sample_rates", :calculated-offset 256}]} {:kind "CXCursor_StructDecl", :spelling "struct DiracVersionInfo", :type "CXType_Record", :id :clong/DiracVersionInfo, :size-in-bytes 8, :fields [{:type "int", :datatype :coffi.mem/int, :name "major", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "minor", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVIndexEntry", :type "CXType_Record", :id :clong/AVIndexEntry, :size-in-bytes 24, :fields [{:type "long long", :datatype :coffi.mem/long, :name "pos", :calculated-offset 0} {:type "long long", :datatype :coffi.mem/long, :name "timestamp", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "size", :calculated-offset 130} {:type "int", :datatype :coffi.mem/int, :name "min_distance", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :spelling "XvMCMacroBlockArray", :type "CXType_Record", :id :clong/XvMCMacroBlockArray, :size-in-bytes 32, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "num_blocks", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "context_id", :calculated-offset 64} {:type "void *", :datatype :coffi.mem/pointer, :name "privData", :calculated-offset 128} {:type "XvMCMacroBlock *", :datatype [:coffi.mem/pointer :clong/XvMCMacroBlock], :name "macro_blocks", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFrame", :type "CXType_Record", :id :clong/AVFrame, :size-in-bytes 536, :fields [{:type "unsigned char *[8]", :datatype [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 8], :name "data", :calculated-offset 0} {:type "int [8]", :datatype [:coffi.mem/array :coffi.mem/int 8], :name "linesize", :calculated-offset 512} {:type "unsigned char **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :name "extended_data", :calculated-offset 768} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 832} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 864} {:type "int", :datatype :coffi.mem/int, :name "nb_samples", :calculated-offset 896} {:type "int", :datatype :coffi.mem/int, :name "format", :calculated-offset 928} {:type "int", :datatype :coffi.mem/int, :name "key_frame", :calculated-offset 960} {:type "enum AVPictureType", :datatype :coffi.mem/int, :name "pict_type", :calculated-offset 992} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 1024} {:type "long long", :datatype :coffi.mem/long, :name "pts", :calculated-offset 1088} {:type "long long", :datatype :coffi.mem/long, :name "pkt_pts", :calculated-offset 1152} {:type "long long", :datatype :coffi.mem/long, :name "pkt_dts", :calculated-offset 1216} {:type "int", :datatype :coffi.mem/int, :name "coded_picture_number", :calculated-offset 1280} {:type "int", :datatype :coffi.mem/int, :name "display_picture_number", :calculated-offset 1312} {:type "int", :datatype :coffi.mem/int, :name "quality", :calculated-offset 1344} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 1408} {:type "unsigned long long [8]", :datatype [:coffi.mem/array :coffi.mem/long 8], :name "error", :calculated-offset 1472} {:type "int", :datatype :coffi.mem/int, :name "repeat_pict", :calculated-offset 1984} {:type "int", :datatype :coffi.mem/int, :name "interlaced_frame", :calculated-offset 2016} {:type "int", :datatype :coffi.mem/int, :name "top_field_first", :calculated-offset 2048} {:type "int", :datatype :coffi.mem/int, :name "palette_has_changed", :calculated-offset 2080} {:type "long long", :datatype :coffi.mem/long, :name "reordered_opaque", :calculated-offset 2112} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 2176} {:type "unsigned long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 2240} {:type "struct AVBufferRef *[8]", :datatype [:coffi.mem/array [:coffi.mem/pointer :clong/AVBufferRef] 8], :name "buf", :calculated-offset 2304} {:type "struct AVBufferRef **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVBufferRef]], :name "extended_buf", :calculated-offset 2816} {:type "int", :datatype :coffi.mem/int, :name "nb_extended_buf", :calculated-offset 2880} {:type "struct AVFrameSideData **", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFrameSideData]], :name "side_data", :calculated-offset 2944} {:type "int", :datatype :coffi.mem/int, :name "nb_side_data", :calculated-offset 3008} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 3040} {:type "enum AVColorRange", :datatype :coffi.mem/int, :name "color_range", :calculated-offset 3072} {:type "enum AVColorPrimaries", :datatype :coffi.mem/int, :name "color_primaries", :calculated-offset 3104} {:type "enum AVColorTransferCharacteristic", :datatype :coffi.mem/int, :name "color_trc", :calculated-offset 3136} {:type "enum AVColorSpace", :datatype :coffi.mem/int, :name "colorspace", :calculated-offset 3168} {:type "enum AVChromaLocation", :datatype :coffi.mem/int, :name "chroma_location", :calculated-offset 3200} {:type "long long", :datatype :coffi.mem/long, :name "best_effort_timestamp", :calculated-offset 3264} {:type "long long", :datatype :coffi.mem/long, :name "pkt_pos", :calculated-offset 3328} {:type "long long", :datatype :coffi.mem/long, :name "pkt_duration", :calculated-offset 3392} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 3456} {:type "int", :datatype :coffi.mem/int, :name "decode_error_flags", :calculated-offset 3520} {:type "int", :datatype :coffi.mem/int, :name "channels", :calculated-offset 3552} {:type "int", :datatype :coffi.mem/int, :name "pkt_size", :calculated-offset 3584} {:type "signed char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "qscale_table", :calculated-offset 3648} {:type "int", :datatype :coffi.mem/int, :name "qstride", :calculated-offset 3712} {:type "int", :datatype :coffi.mem/int, :name "qscale_type", :calculated-offset 3744} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "qp_table_buf", :calculated-offset 3776} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_frames_ctx", :calculated-offset 3840} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "opaque_ref", :calculated-offset 3904} {:type "unsigned long", :datatype :coffi.mem/long, :name "crop_top", :calculated-offset 3968} {:type "unsigned long", :datatype :coffi.mem/long, :name "crop_bottom", :calculated-offset 4032} {:type "unsigned long", :datatype :coffi.mem/long, :name "crop_left", :calculated-offset 4096} {:type "unsigned long", :datatype :coffi.mem/long, :name "crop_right", :calculated-offset 4160} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "private_ref", :calculated-offset 4224}]} {:kind "CXCursor_StructDecl", :spelling "XvMCMacroBlock", :type "CXType_Record", :id :clong/XvMCMacroBlock, :size-in-bytes 32, :fields [{:type "unsigned short", :datatype :coffi.mem/short, :name "x", :calculated-offset 0} {:type "unsigned short", :datatype :coffi.mem/short, :name "y", :calculated-offset 16} {:type "unsigned char", :datatype :coffi.mem/char, :name "macroblock_type", :calculated-offset 32} {:type "unsigned char", :datatype :coffi.mem/char, :name "motion_type", :calculated-offset 40} {:type "unsigned char", :datatype :coffi.mem/char, :name "motion_vertical_field_select", :calculated-offset 48} {:type "unsigned char", :datatype :coffi.mem/char, :name "dct_type", :calculated-offset 56} {:type "short [2][2][2]", :datatype [:coffi.mem/array [:coffi.mem/array [:coffi.mem/array :coffi.mem/short 2] 2] 2], :name "PMV", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "index", :calculated-offset 192} {:type "unsigned short", :datatype :coffi.mem/short, :name "coded_block_pattern", :calculated-offset 224} {:type "unsigned short", :datatype :coffi.mem/short, :name "pad0", :calculated-offset 240}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOption", :type "CXType_Record", :id :clong/AVOption, :size-in-bytes 64, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "help", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "offset", :calculated-offset 128} {:type "enum AVOptionType", :datatype :coffi.mem/int, :name "type", :calculated-offset 160} {:type "union AVOption::(unnamed at /opt/local/include/libavutil/opt.h:267:5)", :datatype [:coffi.mem/array :coffi.mem/char 8], :name "default_val", :calculated-offset 192} {:type "double", :datatype :coffi.mem/double, :name "min", :calculated-offset 256} {:type "double", :datatype :coffi.mem/double, :name "max", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 384} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "unit", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilterFormatsConfig", :type "CXType_Record", :id :clong/AVFilterFormatsConfig, :size-in-bytes 24, :fields [{:type "struct AVFilterFormats *", :datatype [:coffi.mem/pointer :clong/AVFilterFormats], :name "formats", :calculated-offset 0} {:type "struct AVFilterFormats *", :datatype [:coffi.mem/pointer :clong/AVFilterFormats], :name "samplerates", :calculated-offset 64} {:type "struct AVFilterChannelLayouts *", :datatype [:coffi.mem/pointer :clong/AVFilterChannelLayouts], :name "channel_layouts", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilterLink", :type "CXType_Record", :id :clong/AVFilterLink, :size-in-bytes 61680, :fields [{:type "struct AVFilterContext *", :datatype [:coffi.mem/pointer :clong/AVFilterContext], :name "src", :calculated-offset 0} {:type "struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "srcpad", :calculated-offset 64} {:type "struct AVFilterContext *", :datatype [:coffi.mem/pointer :clong/AVFilterContext], :name "dst", :calculated-offset 128} {:type "struct AVFilterPad *", :datatype [:coffi.mem/pointer :clong/AVFilterPad], :name "dstpad", :calculated-offset 192} {:type "enum AVMediaType", :datatype :coffi.mem/int, :name "type", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "w", :calculated-offset 288} {:type "int", :datatype :coffi.mem/int, :name "h", :calculated-offset 320} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 352} {:type "unsigned long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 512} {:type "int", :datatype :coffi.mem/int, :name "format", :calculated-offset 544} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 576} {:type "struct AVFilterFormatsConfig", :datatype :clong/AVFilterFormatsConfig, :name "incfg", :calculated-offset 640} {:type "struct AVFilterFormatsConfig", :datatype :clong/AVFilterFormatsConfig, :name "outcfg", :calculated-offset 832} {:type "enum AVFilterLink::(unnamed at /opt/local/include/libavfilter/avfilter.h:518:5)", :datatype :coffi.mem/int, :name "init_state", :calculated-offset 1024} {:type "struct AVFilterGraph *", :datatype [:coffi.mem/pointer :clong/AVFilterGraph], :name "graph", :calculated-offset 1088} {:type "long long", :datatype :coffi.mem/long, :name "current_pts", :calculated-offset 1152} {:type "long long", :datatype :coffi.mem/long, :name "current_pts_us", :calculated-offset 1216} {:type "int", :datatype :coffi.mem/int, :name "age_index", :calculated-offset 1280} {:type "struct AVRational", :datatype :clong/AVRational, :name "frame_rate", :calculated-offset 1312} {:type "struct AVFrame *", :datatype [:coffi.mem/pointer :clong/AVFrame], :name "partial_buf", :calculated-offset 1408} {:type "int", :datatype :coffi.mem/int, :name "partial_buf_size", :calculated-offset 1472} {:type "int", :datatype :coffi.mem/int, :name "min_samples", :calculated-offset 1504} {:type "int", :datatype :coffi.mem/int, :name "max_samples", :calculated-offset 1536} {:type "int", :datatype :coffi.mem/int, :name "channels", :calculated-offset 1568} {:type "long long", :datatype :coffi.mem/long, :name "frame_count_in", :calculated-offset 1600} {:type "long long", :datatype :coffi.mem/long, :name "frame_count_out", :calculated-offset 1664} {:type "void *", :datatype :coffi.mem/pointer, :name "frame_pool", :calculated-offset 1728} {:type "int", :datatype :coffi.mem/int, :name "frame_wanted_out", :calculated-offset 1792} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_frames_ctx", :calculated-offset 1856} {:type "char [61440]", :datatype [:coffi.mem/array :coffi.mem/char 61440], :name "reserved", :calculated-offset 1920}]} {:kind "CXCursor_StructDecl", :spelling "struct AVMasteringDisplayMetadata", :type "CXType_Record", :id :clong/AVMasteringDisplayMetadata, :size-in-bytes 88, :fields [{:type "struct AVRational [3][2]", :datatype [:coffi.mem/array [:coffi.mem/array :clong/AVRational 2] 3], :name "display_primaries", :calculated-offset 0} {:type "struct AVRational [2]", :datatype [:coffi.mem/array :clong/AVRational 2], :name "white_point", :calculated-offset 384} {:type "struct AVRational", :datatype :clong/AVRational, :name "min_luminance", :calculated-offset 512} {:type "struct AVRational", :datatype :clong/AVRational, :name "max_luminance", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "has_primaries", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "has_luminance", :calculated-offset 672}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOutputFormat", :type "CXType_Record", :id :clong/AVOutputFormat, :size-in-bytes 200, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "long_name", :calculated-offset 64} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "mime_type", :calculated-offset 128} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "extensions", :calculated-offset 192} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "audio_codec", :calculated-offset 256} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "video_codec", :calculated-offset 288} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "subtitle_codec", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 352} {:type "const struct AVCodecTag *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecTag]], :name "codec_tag", :calculated-offset 384} {:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "priv_class", :calculated-offset 448} {:type "struct AVOutputFormat *", :datatype [:coffi.mem/pointer :clong/AVOutputFormat], :name "next", :calculated-offset 512} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 576} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "write_header", :calculated-offset 640} {:type "int (*)(struct AVFormatContext *, struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "write_packet", :calculated-offset 704} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "write_trailer", :calculated-offset 768} {:type "int (*)(struct AVFormatContext *, struct AVPacket *, struct AVPacket *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int] :coffi.mem/int], :name "interleave_packet", :calculated-offset 832} {:type "int (*)(enum AVCodecID, int)", :datatype [:coffi.ffi/fn [:coffi.mem/int :coffi.mem/int] :coffi.mem/int], :name "query_codec", :calculated-offset 896} {:type "void (*)(struct AVFormatContext *, int, long long *, long long *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer :coffi.mem/long] [:coffi.mem/pointer :coffi.mem/long]] :coffi.mem/void], :name "get_output_timestamp", :calculated-offset 960} {:type "int (*)(struct AVFormatContext *, int, void *, unsigned long)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int :coffi.mem/pointer :coffi.mem/long] :coffi.mem/int], :name "control_message", :calculated-offset 1024} {:type "int (*)(struct AVFormatContext *, int, struct AVFrame **, unsigned int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVFrame]] :coffi.mem/int] :coffi.mem/int], :name "write_uncoded_frame", :calculated-offset 1088} {:type "int (*)(struct AVFormatContext *, struct AVDeviceInfoList *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceInfoList]] :coffi.mem/int], :name "get_device_list", :calculated-offset 1152} {:type "int (*)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] :coffi.mem/int], :name "create_device_capabilities", :calculated-offset 1216} {:type "int (*)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVDeviceCapabilitiesQuery]] :coffi.mem/int], :name "free_device_capabilities", :calculated-offset 1280} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "data_codec", :calculated-offset 1344} {:type "int (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/int], :name "init", :calculated-offset 1408} {:type "void (*)(struct AVFormatContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext]] :coffi.mem/void], :name "deinit", :calculated-offset 1472} {:type "int (*)(struct AVFormatContext *, const struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVFormatContext] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "check_bitstream", :calculated-offset 1536}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDiracSeqHeader", :type "CXType_Record", :id :clong/AVDiracSeqHeader, :size-in-bytes 80, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "width", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "height", :calculated-offset 32} {:type "unsigned char", :datatype :coffi.mem/char, :name "chroma_format", :calculated-offset 64} {:type "unsigned char", :datatype :coffi.mem/char, :name "interlaced", :calculated-offset 72} {:type "unsigned char", :datatype :coffi.mem/char, :name "top_field_first", :calculated-offset 80} {:type "unsigned char", :datatype :coffi.mem/char, :name "frame_rate_index", :calculated-offset 88} {:type "unsigned char", :datatype :coffi.mem/char, :name "aspect_ratio_index", :calculated-offset 96} {:type "unsigned short", :datatype :coffi.mem/short, :name "clean_width", :calculated-offset 112} {:type "unsigned short", :datatype :coffi.mem/short, :name "clean_height", :calculated-offset 128} {:type "unsigned short", :datatype :coffi.mem/short, :name "clean_left_offset", :calculated-offset 144} {:type "unsigned short", :datatype :coffi.mem/short, :name "clean_right_offset", :calculated-offset 160} {:type "unsigned char", :datatype :coffi.mem/char, :name "pixel_range_index", :calculated-offset 176} {:type "unsigned char", :datatype :coffi.mem/char, :name "color_spec_index", :calculated-offset 184} {:type "int", :datatype :coffi.mem/int, :name "profile", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "level", :calculated-offset 224} {:type "struct AVRational", :datatype :clong/AVRational, :name "framerate", :calculated-offset 256} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 320} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pix_fmt", :calculated-offset 384} {:type "enum AVColorRange", :datatype :coffi.mem/int, :name "color_range", :calculated-offset 416} {:type "enum AVColorPrimaries", :datatype :coffi.mem/int, :name "color_primaries", :calculated-offset 448} {:type "enum AVColorTransferCharacteristic", :datatype :coffi.mem/int, :name "color_trc", :calculated-offset 480} {:type "enum AVColorSpace", :datatype :coffi.mem/int, :name "colorspace", :calculated-offset 512} {:type "struct DiracVersionInfo", :datatype :clong/DiracVersionInfo, :name "version", :calculated-offset 544} {:type "int", :datatype :coffi.mem/int, :name "bit_depth", :calculated-offset 608}]} {:kind "CXCursor_StructDecl", :spelling "struct AVIODirContext", :type "CXType_Record", :id :clong/AVIODirContext, :size-in-bytes 8, :fields [{:type "struct URLContext *", :datatype [:coffi.mem/pointer :clong/URLContext], :name "url_context", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVOpenCLFrameDescriptor", :type "CXType_Record", :id :clong/AVOpenCLFrameDescriptor, :size-in-bytes 72, :fields [{:type "int", :datatype :coffi.mem/int, :name "nb_planes", :calculated-offset 0} {:type "struct _cl_mem *[8]", :datatype [:coffi.mem/array [:coffi.mem/pointer :clong/_cl_mem] 8], :name "planes", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :spelling "struct AVMediaCodecContext", :type "CXType_Record", :id :clong/AVMediaCodecContext, :size-in-bytes 8, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "surface", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVEncryptionInfo", :type "CXType_Record", :id :clong/AVEncryptionInfo, :size-in-bytes 64, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "scheme", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "crypt_byte_block", :calculated-offset 32} {:type "unsigned int", :datatype :coffi.mem/int, :name "skip_byte_block", :calculated-offset 64} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "key_id", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "key_id_size", :calculated-offset 192} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "iv", :calculated-offset 256} {:type "unsigned int", :datatype :coffi.mem/int, :name "iv_size", :calculated-offset 320} {:type "struct AVSubsampleEncryptionInfo *", :datatype [:coffi.mem/pointer :clong/AVSubsampleEncryptionInfo], :name "subsamples", :calculated-offset 384} {:type "unsigned int", :datatype :coffi.mem/int, :name "subsample_count", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :spelling "struct AVFilmGrainAOMParams", :type "CXType_Record", :id :clong/AVFilmGrainAOMParams, :size-in-bytes 208, :fields [{:type "int", :datatype :coffi.mem/int, :name "num_y_points", :calculated-offset 0} {:type "unsigned char [14][2]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/char 2] 14], :name "y_points", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "chroma_scaling_from_luma", :calculated-offset 256} {:type "int [2]", :datatype [:coffi.mem/array :coffi.mem/int 2], :name "num_uv_points", :calculated-offset 288} {:type "unsigned char [2][10][2]", :datatype [:coffi.mem/array [:coffi.mem/array [:coffi.mem/array :coffi.mem/char 2] 10] 2], :name "uv_points", :calculated-offset 352} {:type "int", :datatype :coffi.mem/int, :name "scaling_shift", :calculated-offset 672} {:type "int", :datatype :coffi.mem/int, :name "ar_coeff_lag", :calculated-offset 704} {:type "signed char [24]", :datatype [:coffi.mem/array :coffi.mem/char 24], :name "ar_coeffs_y", :calculated-offset 736} {:type "signed char [2][25]", :datatype [:coffi.mem/array [:coffi.mem/array :coffi.mem/char 25] 2], :name "ar_coeffs_uv", :calculated-offset 928} {:type "int", :datatype :coffi.mem/int, :name "ar_coeff_shift", :calculated-offset 1344} {:type "int", :datatype :coffi.mem/int, :name "grain_scale_shift", :calculated-offset 1376} {:type "int [2]", :datatype [:coffi.mem/array :coffi.mem/int 2], :name "uv_mult", :calculated-offset 1408} {:type "int [2]", :datatype [:coffi.mem/array :coffi.mem/int 2], :name "uv_mult_luma", :calculated-offset 1472} {:type "int [2]", :datatype [:coffi.mem/array :coffi.mem/int 2], :name "uv_offset", :calculated-offset 1536} {:type "int", :datatype :coffi.mem/int, :name "overlap_flag", :calculated-offset 1600} {:type "int", :datatype :coffi.mem/int, :name "limit_output_range", :calculated-offset 1632}]} {:kind "CXCursor_StructDecl", :spelling "struct AVPicture", :type "CXType_Record", :id :clong/AVPicture, :size-in-bytes 96, :fields [{:type "unsigned char *[8]", :datatype [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 8], :name "data", :calculated-offset 0} {:type "int [8]", :datatype [:coffi.mem/array :coffi.mem/int 8], :name "linesize", :calculated-offset 512}]} {:kind "CXCursor_StructDecl", :spelling "struct AVSubtitleRect", :type "CXType_Record", :id :clong/AVSubtitleRect, :size-in-bytes 200, :fields [{:type "int", :datatype :coffi.mem/int, :name "x", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "y", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "w", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "h", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "nb_colors", :calculated-offset 128} {:type "struct AVPicture", :datatype :clong/AVPicture, :name "pict", :calculated-offset 192} {:type "unsigned char *[4]", :datatype [:coffi.mem/array [:coffi.mem/pointer :coffi.mem/char] 4], :name "data", :calculated-offset 960} {:type "int [4]", :datatype [:coffi.mem/array :coffi.mem/int 4], :name "linesize", :calculated-offset 1216} {:type "enum AVSubtitleType", :datatype :coffi.mem/int, :name "type", :calculated-offset 1344} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "text", :calculated-offset 1408} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "ass", :calculated-offset 1472} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 1536}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodec", :type "CXType_Record", :id :clong/AVCodec, :size-in-bytes 240, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "long_name", :calculated-offset 64} {:type "enum AVMediaType", :datatype :coffi.mem/int, :name "type", :calculated-offset 128} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "id", :calculated-offset 160} {:type "int", :datatype :coffi.mem/int, :name "capabilities", :calculated-offset 192} {:type "const struct AVRational *", :datatype [:coffi.mem/pointer :clong/AVRational], :name "supported_framerates", :calculated-offset 256} {:type "const enum AVPixelFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "pix_fmts", :calculated-offset 320} {:type "const int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "supported_samplerates", :calculated-offset 384} {:type "const enum AVSampleFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "sample_fmts", :calculated-offset 448} {:type "const unsigned long long *", :datatype [:coffi.mem/pointer :coffi.mem/long], :name "channel_layouts", :calculated-offset 512} {:type "unsigned char", :datatype :coffi.mem/char, :name "max_lowres", :calculated-offset 576} {:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "priv_class", :calculated-offset 640} {:type "const struct AVProfile *", :datatype [:coffi.mem/pointer :clong/AVProfile], :name "profiles", :calculated-offset 704} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "wrapper_name", :calculated-offset 768} {:type "int", :datatype :coffi.mem/int, :name "priv_data_size", :calculated-offset 832} {:type "struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "next", :calculated-offset 896} {:type "int (*)(struct AVCodecContext *, const struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "update_thread_context", :calculated-offset 960} {:type "const struct AVCodecDefault *", :datatype [:coffi.mem/pointer :clong/AVCodecDefault], :name "defaults", :calculated-offset 1024} {:type "void (*)(struct AVCodec *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodec]] :coffi.mem/void], :name "init_static_data", :calculated-offset 1088} {:type "int (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "init", :calculated-offset 1152} {:type "int (*)(struct AVCodecContext *, unsigned char *, int, const struct AVSubtitle *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer :clong/AVSubtitle]] :coffi.mem/int], :name "encode_sub", :calculated-offset 1216} {:type "int (*)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, int *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int]] :coffi.mem/int], :name "encode2", :calculated-offset 1280} {:type "int (*)(struct AVCodecContext *, void *, int *, struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "decode", :calculated-offset 1344} {:type "int (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/int], :name "close", :calculated-offset 1408} {:type "int (*)(struct AVCodecContext *, struct AVPacket *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket]] :coffi.mem/int], :name "receive_packet", :calculated-offset 1472} {:type "int (*)(struct AVCodecContext *, struct AVFrame *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame]] :coffi.mem/int], :name "receive_frame", :calculated-offset 1536} {:type "void (*)(struct AVCodecContext *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext]] :coffi.mem/void], :name "flush", :calculated-offset 1600} {:type "int", :datatype :coffi.mem/int, :name "caps_internal", :calculated-offset 1664} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "bsfs", :calculated-offset 1728} {:type "const struct AVCodecHWConfigInternal *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clong/AVCodecHWConfigInternal]], :name "hw_configs", :calculated-offset 1792} {:type "const unsigned int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "codec_tags", :calculated-offset 1856}]} {:kind "CXCursor_StructDecl", :spelling "struct AVStream", :type "CXType_Record", :id :clong/AVStream, :size-in-bytes 496, :fields [{:type "int", :datatype :coffi.mem/int, :name "index", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "id", :calculated-offset 32} {:type "struct AVCodecContext *", :datatype [:coffi.mem/pointer :clong/AVCodecContext], :name "codec", :calculated-offset 64} {:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 128} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 192} {:type "long long", :datatype :coffi.mem/long, :name "start_time", :calculated-offset 256} {:type "long long", :datatype :coffi.mem/long, :name "duration", :calculated-offset 320} {:type "long long", :datatype :coffi.mem/long, :name "nb_frames", :calculated-offset 384} {:type "int", :datatype :coffi.mem/int, :name "disposition", :calculated-offset 448} {:type "enum AVDiscard", :datatype :coffi.mem/int, :name "discard", :calculated-offset 480} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 512} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 576} {:type "struct AVRational", :datatype :clong/AVRational, :name "avg_frame_rate", :calculated-offset 640} {:type "struct AVPacket", :datatype :clong/AVPacket, :name "attached_pic", :calculated-offset 704} {:type "struct AVPacketSideData *", :datatype [:coffi.mem/pointer :clong/AVPacketSideData], :name "side_data", :calculated-offset 1408} {:type "int", :datatype :coffi.mem/int, :name "nb_side_data", :calculated-offset 1472} {:type "int", :datatype :coffi.mem/int, :name "event_flags", :calculated-offset 1504} {:type "struct AVRational", :datatype :clong/AVRational, :name "r_frame_rate", :calculated-offset 1536} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "recommended_encoder_configuration", :calculated-offset 1600} {:type "struct AVCodecParameters *", :datatype [:coffi.mem/pointer :clong/AVCodecParameters], :name "codecpar", :calculated-offset 1664} {:type "void *", :datatype :coffi.mem/pointer, :name "unused", :calculated-offset 1728} {:type "int", :datatype :coffi.mem/int, :name "pts_wrap_bits", :calculated-offset 1792} {:type "long long", :datatype :coffi.mem/long, :name "first_dts", :calculated-offset 1856} {:type "long long", :datatype :coffi.mem/long, :name "cur_dts", :calculated-offset 1920} {:type "long long", :datatype :coffi.mem/long, :name "last_IP_pts", :calculated-offset 1984} {:type "int", :datatype :coffi.mem/int, :name "last_IP_duration", :calculated-offset 2048} {:type "int", :datatype :coffi.mem/int, :name "probe_packets", :calculated-offset 2080} {:type "int", :datatype :coffi.mem/int, :name "codec_info_nb_frames", :calculated-offset 2112} {:type "enum AVStreamParseType", :datatype :coffi.mem/int, :name "need_parsing", :calculated-offset 2144} {:type "struct AVCodecParserContext *", :datatype [:coffi.mem/pointer :clong/AVCodecParserContext], :name "parser", :calculated-offset 2176} {:type "void *", :datatype :coffi.mem/pointer, :name "unused7", :calculated-offset 2240} {:type "struct AVProbeData", :datatype :clong/AVProbeData, :name "unused6", :calculated-offset 2304} {:type "long long [17]", :datatype [:coffi.mem/array :coffi.mem/long 17], :name "unused5", :calculated-offset 2560} {:type "struct AVIndexEntry *", :datatype [:coffi.mem/pointer :clong/AVIndexEntry], :name "index_entries", :calculated-offset 3648} {:type "int", :datatype :coffi.mem/int, :name "nb_index_entries", :calculated-offset 3712} {:type "unsigned int", :datatype :coffi.mem/int, :name "index_entries_allocated_size", :calculated-offset 3744} {:type "int", :datatype :coffi.mem/int, :name "stream_identifier", :calculated-offset 3776} {:type "int", :datatype :coffi.mem/int, :name "unused8", :calculated-offset 3808} {:type "int", :datatype :coffi.mem/int, :name "unused9", :calculated-offset 3840} {:type "int", :datatype :coffi.mem/int, :name "unused10", :calculated-offset 3872} {:type "struct AVStreamInternal *", :datatype [:coffi.mem/pointer :clong/AVStreamInternal], :name "internal", :calculated-offset 3904}]} {:kind "CXCursor_StructDecl", :spelling "struct AVComplexFloat", :type "CXType_Record", :id :clong/AVComplexFloat, :size-in-bytes 8, :fields [{:type "float", :datatype :coffi.mem/float, :name "re", :calculated-offset 0} {:type "float", :datatype :coffi.mem/float, :name "im", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "struct AVVideoBlockParams", :type "CXType_Record", :id :clong/AVVideoBlockParams, :size-in-bytes 20, :fields [{:type "int", :datatype :coffi.mem/int, :name "src_x", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "src_y", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "w", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "h", :calculated-offset 96} {:type "int", :datatype :coffi.mem/int, :name "delta_qp", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :spelling "struct AVDRMDeviceContext", :type "CXType_Record", :id :clong/AVDRMDeviceContext, :size-in-bytes 4, :fields [{:type "int", :datatype :coffi.mem/int, :name "fd", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :spelling "struct AVProgram", :type "CXType_Record", :id :clong/AVProgram, :size-in-bytes 88, :fields [{:type "int", :datatype :coffi.mem/int, :name "id", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 32} {:type "enum AVDiscard", :datatype :coffi.mem/int, :name "discard", :calculated-offset 64} {:type "unsigned int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "stream_index", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "nb_stream_indexes", :calculated-offset 192} {:type "struct AVDictionary *", :datatype [:coffi.mem/pointer :clong/AVDictionary], :name "metadata", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "program_num", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "pmt_pid", :calculated-offset 352} {:type "int", :datatype :coffi.mem/int, :name "pcr_pid", :calculated-offset 384} {:type "int", :datatype :coffi.mem/int, :name "pmt_version", :calculated-offset 416} {:type "long long", :datatype :coffi.mem/long, :name "start_time", :calculated-offset 448} {:type "long long", :datatype :coffi.mem/long, :name "end_time", :calculated-offset 512} {:type "long long", :datatype :coffi.mem/long, :name "pts_wrap_reference", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "pts_wrap_behavior", :calculated-offset 640}]} {:kind "CXCursor_StructDecl", :spelling "XvMCSurface", :type "CXType_Record", :id :clong/XvMCSurface, :size-in-bytes 32, :fields [{:type "unsigned long", :datatype :coffi.mem/long, :name "surface_id", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "context_id", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "surface_type_id", :calculated-offset 128} {:type "unsigned short", :datatype :coffi.mem/short, :name "width", :calculated-offset 160} {:type "unsigned short", :datatype :coffi.mem/short, :name "height", :calculated-offset 176} {:type "void *", :datatype :coffi.mem/pointer, :name "privData", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVCodecContext", :type "CXType_Record", :id :clong/AVCodecContext, :size-in-bytes 1080, :fields [{:type "const struct AVClass *", :datatype [:coffi.mem/pointer :clong/AVClass], :name "av_class", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "log_level_offset", :calculated-offset 64} {:type "enum AVMediaType", :datatype :coffi.mem/int, :name "codec_type", :calculated-offset 96} {:type "const struct AVCodec *", :datatype [:coffi.mem/pointer :clong/AVCodec], :name "codec", :calculated-offset 128} {:type "enum AVCodecID", :datatype :coffi.mem/int, :name "codec_id", :calculated-offset 192} {:type "unsigned int", :datatype :coffi.mem/int, :name "codec_tag", :calculated-offset 224} {:type "void *", :datatype :coffi.mem/pointer, :name "priv_data", :calculated-offset 256} {:type "struct AVCodecInternal *", :datatype [:coffi.mem/pointer :clong/AVCodecInternal], :name "internal", :calculated-offset 320} {:type "void *", :datatype :coffi.mem/pointer, :name "opaque", :calculated-offset 384} {:type "long long", :datatype :coffi.mem/long, :name "bit_rate", :calculated-offset 448} {:type "int", :datatype :coffi.mem/int, :name "bit_rate_tolerance", :calculated-offset 512} {:type "int", :datatype :coffi.mem/int, :name "global_quality", :calculated-offset 544} {:type "int", :datatype :coffi.mem/int, :name "compression_level", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 608} {:type "int", :datatype :coffi.mem/int, :name "flags2", :calculated-offset 640} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "extradata", :calculated-offset 704} {:type "int", :datatype :coffi.mem/int, :name "extradata_size", :calculated-offset 768} {:type "struct AVRational", :datatype :clong/AVRational, :name "time_base", :calculated-offset 800} {:type "int", :datatype :coffi.mem/int, :name "ticks_per_frame", :calculated-offset 864} {:type "int", :datatype :coffi.mem/int, :name "delay", :calculated-offset 896} {:type "int", :datatype :coffi.mem/int, :name "width", :calculated-offset 928} {:type "int", :datatype :coffi.mem/int, :name "height", :calculated-offset 960} {:type "int", :datatype :coffi.mem/int, :name "coded_width", :calculated-offset 992} {:type "int", :datatype :coffi.mem/int, :name "coded_height", :calculated-offset 1024} {:type "int", :datatype :coffi.mem/int, :name "gop_size", :calculated-offset 1056} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "pix_fmt", :calculated-offset 1088} {:type "void (*)(struct AVCodecContext *, const struct AVFrame *, int *, int, int, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :name "draw_horiz_band", :calculated-offset 1152} {:type "enum AVPixelFormat (*)(struct AVCodecContext *, const enum AVPixelFormat *)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :coffi.mem/int]] :coffi.mem/int], :name "get_format", :calculated-offset 1216} {:type "int", :datatype :coffi.mem/int, :name "max_b_frames", :calculated-offset 1280} {:type "float", :datatype :coffi.mem/float, :name "b_quant_factor", :calculated-offset 1312} {:type "int", :datatype :coffi.mem/int, :name "b_frame_strategy", :calculated-offset 1344} {:type "float", :datatype :coffi.mem/float, :name "b_quant_offset", :calculated-offset 1376} {:type "int", :datatype :coffi.mem/int, :name "has_b_frames", :calculated-offset 1408} {:type "int", :datatype :coffi.mem/int, :name "mpeg_quant", :calculated-offset 1440} {:type "float", :datatype :coffi.mem/float, :name "i_quant_factor", :calculated-offset 1472} {:type "float", :datatype :coffi.mem/float, :name "i_quant_offset", :calculated-offset 1504} {:type "float", :datatype :coffi.mem/float, :name "lumi_masking", :calculated-offset 1536} {:type "float", :datatype :coffi.mem/float, :name "temporal_cplx_masking", :calculated-offset 1568} {:type "float", :datatype :coffi.mem/float, :name "spatial_cplx_masking", :calculated-offset 1600} {:type "float", :datatype :coffi.mem/float, :name "p_masking", :calculated-offset 1632} {:type "float", :datatype :coffi.mem/float, :name "dark_masking", :calculated-offset 1664} {:type "int", :datatype :coffi.mem/int, :name "slice_count", :calculated-offset 1696} {:type "int", :datatype :coffi.mem/int, :name "prediction_method", :calculated-offset 1728} {:type "int *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "slice_offset", :calculated-offset 1792} {:type "struct AVRational", :datatype :clong/AVRational, :name "sample_aspect_ratio", :calculated-offset 1856} {:type "int", :datatype :coffi.mem/int, :name "me_cmp", :calculated-offset 1920} {:type "int", :datatype :coffi.mem/int, :name "me_sub_cmp", :calculated-offset 1952} {:type "int", :datatype :coffi.mem/int, :name "mb_cmp", :calculated-offset 1984} {:type "int", :datatype :coffi.mem/int, :name "ildct_cmp", :calculated-offset 2016} {:type "int", :datatype :coffi.mem/int, :name "dia_size", :calculated-offset 2048} {:type "int", :datatype :coffi.mem/int, :name "last_predictor_count", :calculated-offset 2080} {:type "int", :datatype :coffi.mem/int, :name "pre_me", :calculated-offset 2112} {:type "int", :datatype :coffi.mem/int, :name "me_pre_cmp", :calculated-offset 2144} {:type "int", :datatype :coffi.mem/int, :name "pre_dia_size", :calculated-offset 2176} {:type "int", :datatype :coffi.mem/int, :name "me_subpel_quality", :calculated-offset 2208} {:type "int", :datatype :coffi.mem/int, :name "me_range", :calculated-offset 2240} {:type "int", :datatype :coffi.mem/int, :name "slice_flags", :calculated-offset 2272} {:type "int", :datatype :coffi.mem/int, :name "mb_decision", :calculated-offset 2304} {:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "intra_matrix", :calculated-offset 2368} {:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "inter_matrix", :calculated-offset 2432} {:type "int", :datatype :coffi.mem/int, :name "scenechange_threshold", :calculated-offset 2496} {:type "int", :datatype :coffi.mem/int, :name "noise_reduction", :calculated-offset 2528} {:type "int", :datatype :coffi.mem/int, :name "intra_dc_precision", :calculated-offset 2560} {:type "int", :datatype :coffi.mem/int, :name "skip_top", :calculated-offset 2592} {:type "int", :datatype :coffi.mem/int, :name "skip_bottom", :calculated-offset 2624} {:type "int", :datatype :coffi.mem/int, :name "mb_lmin", :calculated-offset 2656} {:type "int", :datatype :coffi.mem/int, :name "mb_lmax", :calculated-offset 2688} {:type "int", :datatype :coffi.mem/int, :name "me_penalty_compensation", :calculated-offset 2720} {:type "int", :datatype :coffi.mem/int, :name "bidir_refine", :calculated-offset 2752} {:type "int", :datatype :coffi.mem/int, :name "brd_scale", :calculated-offset 2784} {:type "int", :datatype :coffi.mem/int, :name "keyint_min", :calculated-offset 2816} {:type "int", :datatype :coffi.mem/int, :name "refs", :calculated-offset 2848} {:type "int", :datatype :coffi.mem/int, :name "chromaoffset", :calculated-offset 2880} {:type "int", :datatype :coffi.mem/int, :name "mv0_threshold", :calculated-offset 2912} {:type "int", :datatype :coffi.mem/int, :name "b_sensitivity", :calculated-offset 2944} {:type "enum AVColorPrimaries", :datatype :coffi.mem/int, :name "color_primaries", :calculated-offset 2976} {:type "enum AVColorTransferCharacteristic", :datatype :coffi.mem/int, :name "color_trc", :calculated-offset 3008} {:type "enum AVColorSpace", :datatype :coffi.mem/int, :name "colorspace", :calculated-offset 3040} {:type "enum AVColorRange", :datatype :coffi.mem/int, :name "color_range", :calculated-offset 3072} {:type "enum AVChromaLocation", :datatype :coffi.mem/int, :name "chroma_sample_location", :calculated-offset 3104} {:type "int", :datatype :coffi.mem/int, :name "slices", :calculated-offset 3136} {:type "enum AVFieldOrder", :datatype :coffi.mem/int, :name "field_order", :calculated-offset 3168} {:type "int", :datatype :coffi.mem/int, :name "sample_rate", :calculated-offset 3200} {:type "int", :datatype :coffi.mem/int, :name "channels", :calculated-offset 3232} {:type "enum AVSampleFormat", :datatype :coffi.mem/int, :name "sample_fmt", :calculated-offset 3264} {:type "int", :datatype :coffi.mem/int, :name "frame_size", :calculated-offset 3296} {:type "int", :datatype :coffi.mem/int, :name "frame_number", :calculated-offset 3328} {:type "int", :datatype :coffi.mem/int, :name "block_align", :calculated-offset 3360} {:type "int", :datatype :coffi.mem/int, :name "cutoff", :calculated-offset 3392} {:type "unsigned long long", :datatype :coffi.mem/long, :name "channel_layout", :calculated-offset 3456} {:type "unsigned long long", :datatype :coffi.mem/long, :name "request_channel_layout", :calculated-offset 3520} {:type "enum AVAudioServiceType", :datatype :coffi.mem/int, :name "audio_service_type", :calculated-offset 3584} {:type "enum AVSampleFormat", :datatype :coffi.mem/int, :name "request_sample_fmt", :calculated-offset 3616} {:type "int (*)(struct AVCodecContext *, struct AVFrame *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVFrame] :coffi.mem/int] :coffi.mem/int], :name "get_buffer2", :calculated-offset 3648} {:type "int", :datatype :coffi.mem/int, :name "refcounted_frames", :calculated-offset 3712} {:type "float", :datatype :coffi.mem/float, :name "qcompress", :calculated-offset 3744} {:type "float", :datatype :coffi.mem/float, :name "qblur", :calculated-offset 3776} {:type "int", :datatype :coffi.mem/int, :name "qmin", :calculated-offset 3808} {:type "int", :datatype :coffi.mem/int, :name "qmax", :calculated-offset 3840} {:type "int", :datatype :coffi.mem/int, :name "max_qdiff", :calculated-offset 3872} {:type "int", :datatype :coffi.mem/int, :name "rc_buffer_size", :calculated-offset 3904} {:type "int", :datatype :coffi.mem/int, :name "rc_override_count", :calculated-offset 3936} {:type "struct RcOverride *", :datatype [:coffi.mem/pointer :clong/RcOverride], :name "rc_override", :calculated-offset 3968} {:type "long long", :datatype :coffi.mem/long, :name "rc_max_rate", :calculated-offset 4032} {:type "long long", :datatype :coffi.mem/long, :name "rc_min_rate", :calculated-offset 4096} {:type "float", :datatype :coffi.mem/float, :name "rc_max_available_vbv_use", :calculated-offset 4160} {:type "float", :datatype :coffi.mem/float, :name "rc_min_vbv_overflow_use", :calculated-offset 4192} {:type "int", :datatype :coffi.mem/int, :name "rc_initial_buffer_occupancy", :calculated-offset 4224} {:type "int", :datatype :coffi.mem/int, :name "coder_type", :calculated-offset 4256} {:type "int", :datatype :coffi.mem/int, :name "context_model", :calculated-offset 4288} {:type "int", :datatype :coffi.mem/int, :name "frame_skip_threshold", :calculated-offset 4320} {:type "int", :datatype :coffi.mem/int, :name "frame_skip_factor", :calculated-offset 4352} {:type "int", :datatype :coffi.mem/int, :name "frame_skip_exp", :calculated-offset 4384} {:type "int", :datatype :coffi.mem/int, :name "frame_skip_cmp", :calculated-offset 4416} {:type "int", :datatype :coffi.mem/int, :name "trellis", :calculated-offset 4448} {:type "int", :datatype :coffi.mem/int, :name "min_prediction_order", :calculated-offset 4480} {:type "int", :datatype :coffi.mem/int, :name "max_prediction_order", :calculated-offset 4512} {:type "long long", :datatype :coffi.mem/long, :name "timecode_frame_start", :calculated-offset 4544} {:type "void (*)(struct AVCodecContext *, void *, int, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int] :coffi.mem/void], :name "rtp_callback", :calculated-offset 4608} {:type "int", :datatype :coffi.mem/int, :name "rtp_payload_size", :calculated-offset 4672} {:type "int", :datatype :coffi.mem/int, :name "mv_bits", :calculated-offset 4704} {:type "int", :datatype :coffi.mem/int, :name "header_bits", :calculated-offset 4736} {:type "int", :datatype :coffi.mem/int, :name "i_tex_bits", :calculated-offset 4768} {:type "int", :datatype :coffi.mem/int, :name "p_tex_bits", :calculated-offset 4800} {:type "int", :datatype :coffi.mem/int, :name "i_count", :calculated-offset 4832} {:type "int", :datatype :coffi.mem/int, :name "p_count", :calculated-offset 4864} {:type "int", :datatype :coffi.mem/int, :name "skip_count", :calculated-offset 4896} {:type "int", :datatype :coffi.mem/int, :name "misc_bits", :calculated-offset 4928} {:type "int", :datatype :coffi.mem/int, :name "frame_bits", :calculated-offset 4960} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "stats_out", :calculated-offset 4992} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "stats_in", :calculated-offset 5056} {:type "int", :datatype :coffi.mem/int, :name "workaround_bugs", :calculated-offset 5120} {:type "int", :datatype :coffi.mem/int, :name "strict_std_compliance", :calculated-offset 5152} {:type "int", :datatype :coffi.mem/int, :name "error_concealment", :calculated-offset 5184} {:type "int", :datatype :coffi.mem/int, :name "debug", :calculated-offset 5216} {:type "int", :datatype :coffi.mem/int, :name "err_recognition", :calculated-offset 5248} {:type "long long", :datatype :coffi.mem/long, :name "reordered_opaque", :calculated-offset 5312} {:type "const struct AVHWAccel *", :datatype [:coffi.mem/pointer :clong/AVHWAccel], :name "hwaccel", :calculated-offset 5376} {:type "void *", :datatype :coffi.mem/pointer, :name "hwaccel_context", :calculated-offset 5440} {:type "unsigned long long [8]", :datatype [:coffi.mem/array :coffi.mem/long 8], :name "error", :calculated-offset 5504} {:type "int", :datatype :coffi.mem/int, :name "dct_algo", :calculated-offset 6016} {:type "int", :datatype :coffi.mem/int, :name "idct_algo", :calculated-offset 6048} {:type "int", :datatype :coffi.mem/int, :name "bits_per_coded_sample", :calculated-offset 6080} {:type "int", :datatype :coffi.mem/int, :name "bits_per_raw_sample", :calculated-offset 6112} {:type "int", :datatype :coffi.mem/int, :name "lowres", :calculated-offset 6144} {:type "struct AVFrame *", :datatype [:coffi.mem/pointer :clong/AVFrame], :name "coded_frame", :calculated-offset 6208} {:type "int", :datatype :coffi.mem/int, :name "thread_count", :calculated-offset 6272} {:type "int", :datatype :coffi.mem/int, :name "thread_type", :calculated-offset 6304} {:type "int", :datatype :coffi.mem/int, :name "active_thread_type", :calculated-offset 6336} {:type "int", :datatype :coffi.mem/int, :name "thread_safe_callbacks", :calculated-offset 6368} {:type "int (*)(struct AVCodecContext *, int (*)(struct AVCodecContext *, void *), void *, int *, int, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int :coffi.mem/int] :coffi.mem/int], :name "execute", :calculated-offset 6400} {:type "int (*)(struct AVCodecContext *, int (*)(struct AVCodecContext *, void *, int, int), void *, int *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int] :coffi.mem/int] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int] :coffi.mem/int] :coffi.mem/int], :name "execute2", :calculated-offset 6464} {:type "int", :datatype :coffi.mem/int, :name "nsse_weight", :calculated-offset 6528} {:type "int", :datatype :coffi.mem/int, :name "profile", :calculated-offset 6560} {:type "int", :datatype :coffi.mem/int, :name "level", :calculated-offset 6592} {:type "enum AVDiscard", :datatype :coffi.mem/int, :name "skip_loop_filter", :calculated-offset 6624} {:type "enum AVDiscard", :datatype :coffi.mem/int, :name "skip_idct", :calculated-offset 6656} {:type "enum AVDiscard", :datatype :coffi.mem/int, :name "skip_frame", :calculated-offset 6688} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "subtitle_header", :calculated-offset 6720} {:type "int", :datatype :coffi.mem/int, :name "subtitle_header_size", :calculated-offset 6784} {:type "unsigned long long", :datatype :coffi.mem/long, :name "vbv_delay", :calculated-offset 6848} {:type "int", :datatype :coffi.mem/int, :name "side_data_only_packets", :calculated-offset 6912} {:type "int", :datatype :coffi.mem/int, :name "initial_padding", :calculated-offset 6944} {:type "struct AVRational", :datatype :clong/AVRational, :name "framerate", :calculated-offset 6976} {:type "enum AVPixelFormat", :datatype :coffi.mem/int, :name "sw_pix_fmt", :calculated-offset 7040} {:type "struct AVRational", :datatype :clong/AVRational, :name "pkt_timebase", :calculated-offset 7072} {:type "const struct AVCodecDescriptor *", :datatype [:coffi.mem/pointer :clong/AVCodecDescriptor], :name "codec_descriptor", :calculated-offset 7168} {:type "long long", :datatype :coffi.mem/long, :name "pts_correction_num_faulty_pts", :calculated-offset 7232} {:type "long long", :datatype :coffi.mem/long, :name "pts_correction_num_faulty_dts", :calculated-offset 7296} {:type "long long", :datatype :coffi.mem/long, :name "pts_correction_last_pts", :calculated-offset 7360} {:type "long long", :datatype :coffi.mem/long, :name "pts_correction_last_dts", :calculated-offset 7424} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "sub_charenc", :calculated-offset 7488} {:type "int", :datatype :coffi.mem/int, :name "sub_charenc_mode", :calculated-offset 7552} {:type "int", :datatype :coffi.mem/int, :name "skip_alpha", :calculated-offset 7584} {:type "int", :datatype :coffi.mem/int, :name "seek_preroll", :calculated-offset 7616} {:type "int", :datatype :coffi.mem/int, :name "debug_mv", :calculated-offset 7648} {:type "unsigned short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "chroma_intra_matrix", :calculated-offset 7680} {:type "unsigned char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "dump_separator", :calculated-offset 7744} {:type "char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "codec_whitelist", :calculated-offset 7808} {:type "unsigned int", :datatype :coffi.mem/int, :name "properties", :calculated-offset 7872} {:type "struct AVPacketSideData *", :datatype [:coffi.mem/pointer :clong/AVPacketSideData], :name "coded_side_data", :calculated-offset 7936} {:type "int", :datatype :coffi.mem/int, :name "nb_coded_side_data", :calculated-offset 8000} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_frames_ctx", :calculated-offset 8064} {:type "int", :datatype :coffi.mem/int, :name "sub_text_format", :calculated-offset 8128} {:type "int", :datatype :coffi.mem/int, :name "trailing_padding", :calculated-offset 8160} {:type "long long", :datatype :coffi.mem/long, :name "max_pixels", :calculated-offset 8192} {:type "struct AVBufferRef *", :datatype [:coffi.mem/pointer :clong/AVBufferRef], :name "hw_device_ctx", :calculated-offset 8256} {:type "int", :datatype :coffi.mem/int, :name "hwaccel_flags", :calculated-offset 8320} {:type "int", :datatype :coffi.mem/int, :name "apply_cropping", :calculated-offset 8352} {:type "int", :datatype :coffi.mem/int, :name "extra_hw_frames", :calculated-offset 8384} {:type "int", :datatype :coffi.mem/int, :name "discard_damaged_percentage", :calculated-offset 8416} {:type "long long", :datatype :coffi.mem/long, :name "max_samples", :calculated-offset 8448} {:type "int", :datatype :coffi.mem/int, :name "export_side_data", :calculated-offset 8512} {:type "int (*)(struct AVCodecContext *, struct AVPacket *, int)", :datatype [:coffi.ffi/fn [[:coffi.mem/pointer :clong/AVCodecContext] [:coffi.mem/pointer :clong/AVPacket] :coffi.mem/int] :coffi.mem/int], :name "get_encode_buffer", :calculated-offset 8576}]} {:kind "CXCursor_StructDecl", :spelling "struct AVContentLightMetadata", :type "CXType_Record", :id :clong/AVContentLightMetadata, :size-in-bytes 8, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "MaxCLL", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "MaxFALL", :calculated-offset 32}]} {:kind "CXCursor_StructDecl", :spelling "XvMCBlockArray", :type "CXType_Record", :id :clong/XvMCBlockArray, :size-in-bytes 32, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "num_blocks", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "context_id", :calculated-offset 64} {:type "void *", :datatype :coffi.mem/pointer, :name "privData", :calculated-offset 128} {:type "short *", :datatype [:coffi.mem/pointer :coffi.mem/short], :name "blocks", :calculated-offset 192}]} {:kind "CXCursor_StructDecl", :spelling "struct AVHWFramesConstraints", :type "CXType_Record", :id :clong/AVHWFramesConstraints, :size-in-bytes 32, :fields [{:type "enum AVPixelFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "valid_hw_formats", :calculated-offset 0} {:type "enum AVPixelFormat *", :datatype [:coffi.mem/pointer :coffi.mem/int], :name "valid_sw_formats", :calculated-offset 64} {:type "int", :datatype :coffi.mem/int, :name "min_width", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "min_height", :calculated-offset 160} {:type "int", :datatype :coffi.mem/int, :name "max_width", :calculated-offset 192} {:type "int", :datatype :coffi.mem/int, :name "max_height", :calculated-offset 224}]}), :enums ({:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NONE", :type "CXType_Int", :name "AV_PIX_FMT_NONE", :value -1, :enum "AVPixelFormat", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P", :value 0, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUYV422", :type "CXType_Int", :name "AV_PIX_FMT_YUYV422", :value 1, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB24", :type "CXType_Int", :name "AV_PIX_FMT_RGB24", :value 2, :enum "AVPixelFormat", :raw-comment "///< packed RGB 8:8:8, 24bpp, RGBRGB..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR24", :type "CXType_Int", :name "AV_PIX_FMT_BGR24", :value 3, :enum "AVPixelFormat", :raw-comment "///< packed RGB 8:8:8, 24bpp, BGRBGR..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P", :value 4, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P", :value 5, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV410P", :type "CXType_Int", :name "AV_PIX_FMT_YUV410P", :value 6, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV411P", :type "CXType_Int", :name "AV_PIX_FMT_YUV411P", :value 7, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY8", :type "CXType_Int", :name "AV_PIX_FMT_GRAY8", :value 8, :enum "AVPixelFormat", :raw-comment "///<        Y        ,  8bpp"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_MONOWHITE", :type "CXType_Int", :name "AV_PIX_FMT_MONOWHITE", :value 9, :enum "AVPixelFormat", :raw-comment "///<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_MONOBLACK", :type "CXType_Int", :name "AV_PIX_FMT_MONOBLACK", :value 10, :enum "AVPixelFormat", :raw-comment "///<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_PAL8", :type "CXType_Int", :name "AV_PIX_FMT_PAL8", :value 11, :enum "AVPixelFormat", :raw-comment "///< 8 bits with AV_PIX_FMT_RGB32 palette"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVJ420P", :type "CXType_Int", :name "AV_PIX_FMT_YUVJ420P", :value 12, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVJ422P", :type "CXType_Int", :name "AV_PIX_FMT_YUVJ422P", :value 13, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVJ444P", :type "CXType_Int", :name "AV_PIX_FMT_YUVJ444P", :value 14, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_UYVY422", :type "CXType_Int", :name "AV_PIX_FMT_UYVY422", :value 15, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_UYYVYY411", :type "CXType_Int", :name "AV_PIX_FMT_UYYVYY411", :value 16, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR8", :type "CXType_Int", :name "AV_PIX_FMT_BGR8", :value 17, :enum "AVPixelFormat", :raw-comment "///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR4", :type "CXType_Int", :name "AV_PIX_FMT_BGR4", :value 18, :enum "AVPixelFormat", :raw-comment "///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR4_BYTE", :type "CXType_Int", :name "AV_PIX_FMT_BGR4_BYTE", :value 19, :enum "AVPixelFormat", :raw-comment "///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB8", :type "CXType_Int", :name "AV_PIX_FMT_RGB8", :value 20, :enum "AVPixelFormat", :raw-comment "///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB4", :type "CXType_Int", :name "AV_PIX_FMT_RGB4", :value 21, :enum "AVPixelFormat", :raw-comment "///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB4_BYTE", :type "CXType_Int", :name "AV_PIX_FMT_RGB4_BYTE", :value 22, :enum "AVPixelFormat", :raw-comment "///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV12", :type "CXType_Int", :name "AV_PIX_FMT_NV12", :value 23, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV21", :type "CXType_Int", :name "AV_PIX_FMT_NV21", :value 24, :enum "AVPixelFormat", :raw-comment "///< as above, but U and V bytes are swapped"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_ARGB", :type "CXType_Int", :name "AV_PIX_FMT_ARGB", :value 25, :enum "AVPixelFormat", :raw-comment "///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGBA", :type "CXType_Int", :name "AV_PIX_FMT_RGBA", :value 26, :enum "AVPixelFormat", :raw-comment "///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_ABGR", :type "CXType_Int", :name "AV_PIX_FMT_ABGR", :value 27, :enum "AVPixelFormat", :raw-comment "///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGRA", :type "CXType_Int", :name "AV_PIX_FMT_BGRA", :value 28, :enum "AVPixelFormat", :raw-comment "///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY16BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY16BE", :value 29, :enum "AVPixelFormat", :raw-comment "///<        Y        , 16bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY16LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY16LE", :value 30, :enum "AVPixelFormat", :raw-comment "///<        Y        , 16bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV440P", :type "CXType_Int", :name "AV_PIX_FMT_YUV440P", :value 31, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVJ440P", :type "CXType_Int", :name "AV_PIX_FMT_YUVJ440P", :value 32, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P", :value 33, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB48BE", :type "CXType_Int", :name "AV_PIX_FMT_RGB48BE", :value 34, :enum "AVPixelFormat", :raw-comment "///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB48LE", :type "CXType_Int", :name "AV_PIX_FMT_RGB48LE", :value 35, :enum "AVPixelFormat", :raw-comment "///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB565BE", :type "CXType_Int", :name "AV_PIX_FMT_RGB565BE", :value 36, :enum "AVPixelFormat", :raw-comment "///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB565LE", :type "CXType_Int", :name "AV_PIX_FMT_RGB565LE", :value 37, :enum "AVPixelFormat", :raw-comment "///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB555BE", :type "CXType_Int", :name "AV_PIX_FMT_RGB555BE", :value 38, :enum "AVPixelFormat", :raw-comment "///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB555LE", :type "CXType_Int", :name "AV_PIX_FMT_RGB555LE", :value 39, :enum "AVPixelFormat", :raw-comment "///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR565BE", :type "CXType_Int", :name "AV_PIX_FMT_BGR565BE", :value 40, :enum "AVPixelFormat", :raw-comment "///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR565LE", :type "CXType_Int", :name "AV_PIX_FMT_BGR565LE", :value 41, :enum "AVPixelFormat", :raw-comment "///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR555BE", :type "CXType_Int", :name "AV_PIX_FMT_BGR555BE", :value 42, :enum "AVPixelFormat", :raw-comment "///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR555LE", :type "CXType_Int", :name "AV_PIX_FMT_BGR555LE", :value 43, :enum "AVPixelFormat", :raw-comment "///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VAAPI_MOCO", :type "CXType_Int", :name "AV_PIX_FMT_VAAPI_MOCO", :value 44, :enum "AVPixelFormat", :raw-comment "///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VAAPI_IDCT", :type "CXType_Int", :name "AV_PIX_FMT_VAAPI_IDCT", :value 45, :enum "AVPixelFormat", :raw-comment "///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VAAPI_VLD", :type "CXType_Int", :name "AV_PIX_FMT_VAAPI_VLD", :value 46, :enum "AVPixelFormat", :raw-comment "///< HW decoding through VA API, Picture.data[3] contains a VASurfaceID"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VAAPI", :type "CXType_Int", :name "AV_PIX_FMT_VAAPI", :value 46, :enum "AVPixelFormat", :raw-comment "/**@}*/"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P16LE", :value 47, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P16BE", :value 48, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P16LE", :value 49, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P16BE", :value 50, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P16LE", :value 51, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P16BE", :value 52, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_DXVA2_VLD", :type "CXType_Int", :name "AV_PIX_FMT_DXVA2_VLD", :value 53, :enum "AVPixelFormat", :raw-comment "///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB444LE", :type "CXType_Int", :name "AV_PIX_FMT_RGB444LE", :value 54, :enum "AVPixelFormat", :raw-comment "///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB444BE", :type "CXType_Int", :name "AV_PIX_FMT_RGB444BE", :value 55, :enum "AVPixelFormat", :raw-comment "///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR444LE", :type "CXType_Int", :name "AV_PIX_FMT_BGR444LE", :value 56, :enum "AVPixelFormat", :raw-comment "///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR444BE", :type "CXType_Int", :name "AV_PIX_FMT_BGR444BE", :value 57, :enum "AVPixelFormat", :raw-comment "///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YA8", :type "CXType_Int", :name "AV_PIX_FMT_YA8", :value 58, :enum "AVPixelFormat", :raw-comment "///< 8 bits gray, 8 bits alpha"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_Y400A", :type "CXType_Int", :name "AV_PIX_FMT_Y400A", :value 58, :enum "AVPixelFormat", :raw-comment "///< alias for AV_PIX_FMT_YA8"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY8A", :type "CXType_Int", :name "AV_PIX_FMT_GRAY8A", :value 58, :enum "AVPixelFormat", :raw-comment "///< alias for AV_PIX_FMT_YA8"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR48BE", :type "CXType_Int", :name "AV_PIX_FMT_BGR48BE", :value 59, :enum "AVPixelFormat", :raw-comment "///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR48LE", :type "CXType_Int", :name "AV_PIX_FMT_BGR48LE", :value 60, :enum "AVPixelFormat", :raw-comment "///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P9BE", :value 61, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P9LE", :value 62, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P10BE", :value 63, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P10LE", :value 64, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P10BE", :value 65, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P10LE", :value 66, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P9BE", :value 67, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P9LE", :value 68, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P10BE", :value 69, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P10LE", :value 70, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P9BE", :value 71, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P9LE", :value 72, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP", :type "CXType_Int", :name "AV_PIX_FMT_GBRP", :value 73, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 24bpp"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBR24P", :type "CXType_Int", :name "AV_PIX_FMT_GBR24P", :value 73, :enum "AVPixelFormat", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP9BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP9BE", :value 74, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 27bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP9LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP9LE", :value 75, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 27bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP10BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP10BE", :value 76, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 30bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP10LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP10LE", :value 77, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 30bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP16BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP16BE", :value 78, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 48bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP16LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP16LE", :value 79, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 48bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P", :value 80, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P", :value 81, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P9BE", :value 82, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P9LE", :value 83, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P9BE", :value 84, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P9LE", :value 85, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P9BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P9BE", :value 86, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P9LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P9LE", :value 87, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P10BE", :value 88, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P10LE", :value 89, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P10BE", :value 90, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P10LE", :value 91, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P10BE", :value 92, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P10LE", :value 93, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P16BE", :value 94, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA420P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA420P16LE", :value 95, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P16BE", :value 96, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P16LE", :value 97, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P16BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P16BE", :value 98, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P16LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P16LE", :value 99, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VDPAU", :type "CXType_Int", :name "AV_PIX_FMT_VDPAU", :value 100, :enum "AVPixelFormat", :raw-comment "///< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_XYZ12LE", :type "CXType_Int", :name "AV_PIX_FMT_XYZ12LE", :value 101, :enum "AVPixelFormat", :raw-comment "///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_XYZ12BE", :type "CXType_Int", :name "AV_PIX_FMT_XYZ12BE", :value 102, :enum "AVPixelFormat", :raw-comment "///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV16", :type "CXType_Int", :name "AV_PIX_FMT_NV16", :value 103, :enum "AVPixelFormat", :raw-comment "///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV20LE", :type "CXType_Int", :name "AV_PIX_FMT_NV20LE", :value 104, :enum "AVPixelFormat", :raw-comment "///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV20BE", :type "CXType_Int", :name "AV_PIX_FMT_NV20BE", :value 105, :enum "AVPixelFormat", :raw-comment "///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGBA64BE", :type "CXType_Int", :name "AV_PIX_FMT_RGBA64BE", :value 106, :enum "AVPixelFormat", :raw-comment "///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGBA64LE", :type "CXType_Int", :name "AV_PIX_FMT_RGBA64LE", :value 107, :enum "AVPixelFormat", :raw-comment "///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGRA64BE", :type "CXType_Int", :name "AV_PIX_FMT_BGRA64BE", :value 108, :enum "AVPixelFormat", :raw-comment "///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGRA64LE", :type "CXType_Int", :name "AV_PIX_FMT_BGRA64LE", :value 109, :enum "AVPixelFormat", :raw-comment "///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YVYU422", :type "CXType_Int", :name "AV_PIX_FMT_YVYU422", :value 110, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YA16BE", :type "CXType_Int", :name "AV_PIX_FMT_YA16BE", :value 111, :enum "AVPixelFormat", :raw-comment "///< 16 bits gray, 16 bits alpha (big-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YA16LE", :type "CXType_Int", :name "AV_PIX_FMT_YA16LE", :value 112, :enum "AVPixelFormat", :raw-comment "///< 16 bits gray, 16 bits alpha (little-endian)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP", :value 113, :enum "AVPixelFormat", :raw-comment "///< planar GBRA 4:4:4:4 32bpp"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP16BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP16BE", :value 114, :enum "AVPixelFormat", :raw-comment "///< planar GBRA 4:4:4:4 64bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP16LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP16LE", :value 115, :enum "AVPixelFormat", :raw-comment "///< planar GBRA 4:4:4:4 64bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_QSV", :type "CXType_Int", :name "AV_PIX_FMT_QSV", :value 116, :enum "AVPixelFormat", :raw-comment "/**\n     *  HW acceleration through QSV, data[3] contains a pointer to the\n     *  mfxFrameSurface1 structure.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_MMAL", :type "CXType_Int", :name "AV_PIX_FMT_MMAL", :value 117, :enum "AVPixelFormat", :raw-comment "/**\n     * HW acceleration though MMAL, data[3] contains a pointer to the\n     * MMAL_BUFFER_HEADER_T structure.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_D3D11VA_VLD", :type "CXType_Int", :name "AV_PIX_FMT_D3D11VA_VLD", :value 118, :enum "AVPixelFormat", :raw-comment "///< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_CUDA", :type "CXType_Int", :name "AV_PIX_FMT_CUDA", :value 119, :enum "AVPixelFormat", :raw-comment "/**\n     * HW acceleration through CUDA. data[i] contain CUdeviceptr pointers\n     * exactly as for system memory frames.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_0RGB", :type "CXType_Int", :name "AV_PIX_FMT_0RGB", :value 120, :enum "AVPixelFormat", :raw-comment "///< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_RGB0", :type "CXType_Int", :name "AV_PIX_FMT_RGB0", :value 121, :enum "AVPixelFormat", :raw-comment "///< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_0BGR", :type "CXType_Int", :name "AV_PIX_FMT_0BGR", :value 122, :enum "AVPixelFormat", :raw-comment "///< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BGR0", :type "CXType_Int", :name "AV_PIX_FMT_BGR0", :value 123, :enum "AVPixelFormat", :raw-comment "///< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P12BE", :value 124, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P12LE", :value 125, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P14BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P14BE", :value 126, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV420P14LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV420P14LE", :value 127, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P12BE", :value 128, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P12LE", :value 129, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P14BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P14BE", :value 130, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV422P14LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV422P14LE", :value 131, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P12BE", :value 132, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P12LE", :value 133, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P14BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P14BE", :value 134, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV444P14LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV444P14LE", :value 135, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP12BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP12BE", :value 136, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 36bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP12LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP12LE", :value 137, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 36bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP14BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP14BE", :value 138, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 42bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRP14LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRP14LE", :value 139, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4 42bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVJ411P", :type "CXType_Int", :name "AV_PIX_FMT_YUVJ411P", :value 140, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_BGGR8", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_BGGR8", :value 141, :enum "AVPixelFormat", :raw-comment "///< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_RGGB8", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_RGGB8", :value 142, :enum "AVPixelFormat", :raw-comment "///< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GBRG8", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GBRG8", :value 143, :enum "AVPixelFormat", :raw-comment "///< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GRBG8", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GRBG8", :value 144, :enum "AVPixelFormat", :raw-comment "///< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_BGGR16LE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_BGGR16LE", :value 145, :enum "AVPixelFormat", :raw-comment "///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_BGGR16BE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_BGGR16BE", :value 146, :enum "AVPixelFormat", :raw-comment "///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_RGGB16LE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_RGGB16LE", :value 147, :enum "AVPixelFormat", :raw-comment "///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_RGGB16BE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_RGGB16BE", :value 148, :enum "AVPixelFormat", :raw-comment "///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GBRG16LE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GBRG16LE", :value 149, :enum "AVPixelFormat", :raw-comment "///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GBRG16BE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GBRG16BE", :value 150, :enum "AVPixelFormat", :raw-comment "///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GRBG16LE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GRBG16LE", :value 151, :enum "AVPixelFormat", :raw-comment "///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_BAYER_GRBG16BE", :type "CXType_Int", :name "AV_PIX_FMT_BAYER_GRBG16BE", :value 152, :enum "AVPixelFormat", :raw-comment "///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_XVMC", :type "CXType_Int", :name "AV_PIX_FMT_XVMC", :value 153, :enum "AVPixelFormat", :raw-comment "///< XVideo Motion Acceleration via common packet passing"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV440P10LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV440P10LE", :value 154, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV440P10BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV440P10BE", :value 155, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV440P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUV440P12LE", :value 156, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUV440P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUV440P12BE", :value 157, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_AYUV64LE", :type "CXType_Int", :name "AV_PIX_FMT_AYUV64LE", :value 158, :enum "AVPixelFormat", :raw-comment "///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_AYUV64BE", :type "CXType_Int", :name "AV_PIX_FMT_AYUV64BE", :value 159, :enum "AVPixelFormat", :raw-comment "///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VIDEOTOOLBOX", :type "CXType_Int", :name "AV_PIX_FMT_VIDEOTOOLBOX", :value 160, :enum "AVPixelFormat", :raw-comment "///< hardware decoding through Videotoolbox"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_P010LE", :type "CXType_Int", :name "AV_PIX_FMT_P010LE", :value 161, :enum "AVPixelFormat", :raw-comment "///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_P010BE", :type "CXType_Int", :name "AV_PIX_FMT_P010BE", :value 162, :enum "AVPixelFormat", :raw-comment "///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP12BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP12BE", :value 163, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4:4 48bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP12LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP12LE", :value 164, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4:4 48bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP10BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP10BE", :value 165, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4:4 40bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAP10LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAP10LE", :value 166, :enum "AVPixelFormat", :raw-comment "///< planar GBR 4:4:4:4 40bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_MEDIACODEC", :type "CXType_Int", :name "AV_PIX_FMT_MEDIACODEC", :value 167, :enum "AVPixelFormat", :raw-comment "///< hardware decoding through MediaCodec"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY12BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY12BE", :value 168, :enum "AVPixelFormat", :raw-comment "///<        Y        , 12bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY12LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY12LE", :value 169, :enum "AVPixelFormat", :raw-comment "///<        Y        , 12bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY10BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY10BE", :value 170, :enum "AVPixelFormat", :raw-comment "///<        Y        , 10bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY10LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY10LE", :value 171, :enum "AVPixelFormat", :raw-comment "///<        Y        , 10bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_P016LE", :type "CXType_Int", :name "AV_PIX_FMT_P016LE", :value 172, :enum "AVPixelFormat", :raw-comment "///< like NV12, with 16bpp per component, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_P016BE", :type "CXType_Int", :name "AV_PIX_FMT_P016BE", :value 173, :enum "AVPixelFormat", :raw-comment "///< like NV12, with 16bpp per component, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_D3D11", :type "CXType_Int", :name "AV_PIX_FMT_D3D11", :value 174, :enum "AVPixelFormat", :raw-comment "/**\n     * Hardware surfaces for Direct3D11.\n     *\n     * This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11\n     * hwaccel API and filtering support AV_PIX_FMT_D3D11 only.\n     *\n     * data[0] contains a ID3D11Texture2D pointer, and data[1] contains the\n     * texture array index of the frame as intptr_t if the ID3D11Texture2D is\n     * an array texture (or always 0 if it's a normal texture).\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY9BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY9BE", :value 175, :enum "AVPixelFormat", :raw-comment "///<        Y        , 9bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY9LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY9LE", :value 176, :enum "AVPixelFormat", :raw-comment "///<        Y        , 9bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRPF32BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRPF32BE", :value 177, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRPF32LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRPF32LE", :value 178, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAPF32BE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAPF32BE", :value 179, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GBRAPF32LE", :type "CXType_Int", :name "AV_PIX_FMT_GBRAPF32LE", :value 180, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_DRM_PRIME", :type "CXType_Int", :name "AV_PIX_FMT_DRM_PRIME", :value 181, :enum "AVPixelFormat", :raw-comment "/**\n     * DRM-managed buffers exposed through PRIME buffer sharing.\n     *\n     * data[0] points to an AVDRMFrameDescriptor.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_OPENCL", :type "CXType_Int", :name "AV_PIX_FMT_OPENCL", :value 182, :enum "AVPixelFormat", :raw-comment "/**\n     * Hardware surfaces for OpenCL.\n     *\n     * data[i] contain 2D image objects (typed in C as cl_mem, used\n     * in OpenCL as image2d_t) for each plane of the surface.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY14BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY14BE", :value 183, :enum "AVPixelFormat", :raw-comment "///<        Y        , 14bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAY14LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAY14LE", :value 184, :enum "AVPixelFormat", :raw-comment "///<        Y        , 14bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAYF32BE", :type "CXType_Int", :name "AV_PIX_FMT_GRAYF32BE", :value 185, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision Y, 32bpp, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_GRAYF32LE", :type "CXType_Int", :name "AV_PIX_FMT_GRAYF32LE", :value 186, :enum "AVPixelFormat", :raw-comment "///< IEEE-754 single precision Y, 32bpp, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P12BE", :value 187, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA422P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA422P12LE", :value 188, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P12BE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P12BE", :value 189, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_YUVA444P12LE", :type "CXType_Int", :name "AV_PIX_FMT_YUVA444P12LE", :value 190, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV24", :type "CXType_Int", :name "AV_PIX_FMT_NV24", :value 191, :enum "AVPixelFormat", :raw-comment "///< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NV42", :type "CXType_Int", :name "AV_PIX_FMT_NV42", :value 192, :enum "AVPixelFormat", :raw-comment "///< as above, but U and V bytes are swapped"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_VULKAN", :type "CXType_Int", :name "AV_PIX_FMT_VULKAN", :value 193, :enum "AVPixelFormat", :raw-comment "/**\n     * Vulkan hardware images.\n     *\n     * data[0] points to an AVVkFrame\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_Y210BE", :type "CXType_Int", :name "AV_PIX_FMT_Y210BE", :value 194, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_Y210LE", :type "CXType_Int", :name "AV_PIX_FMT_Y210LE", :value 195, :enum "AVPixelFormat", :raw-comment "///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_X2RGB10LE", :type "CXType_Int", :name "AV_PIX_FMT_X2RGB10LE", :value 196, :enum "AVPixelFormat", :raw-comment "///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_X2RGB10BE", :type "CXType_Int", :name "AV_PIX_FMT_X2RGB10BE", :value 197, :enum "AVPixelFormat", :raw-comment "///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PIX_FMT_NB", :type "CXType_Int", :name "AV_PIX_FMT_NB", :value 198, :enum "AVPixelFormat", :raw-comment "///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_RESERVED0", :type "CXType_Int", :name "AVCOL_PRI_RESERVED0", :value 0, :enum "AVColorPrimaries", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_BT709", :type "CXType_Int", :name "AVCOL_PRI_BT709", :value 1, :enum "AVColorPrimaries", :raw-comment "///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_UNSPECIFIED", :type "CXType_Int", :name "AVCOL_PRI_UNSPECIFIED", :value 2, :enum "AVColorPrimaries", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_RESERVED", :type "CXType_Int", :name "AVCOL_PRI_RESERVED", :value 3, :enum "AVColorPrimaries", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_BT470M", :type "CXType_Int", :name "AVCOL_PRI_BT470M", :value 4, :enum "AVColorPrimaries", :raw-comment "///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_BT470BG", :type "CXType_Int", :name "AVCOL_PRI_BT470BG", :value 5, :enum "AVColorPrimaries", :raw-comment "///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTE170M", :type "CXType_Int", :name "AVCOL_PRI_SMPTE170M", :value 6, :enum "AVColorPrimaries", :raw-comment "///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTE240M", :type "CXType_Int", :name "AVCOL_PRI_SMPTE240M", :value 7, :enum "AVColorPrimaries", :raw-comment "///< functionally identical to above"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_FILM", :type "CXType_Int", :name "AVCOL_PRI_FILM", :value 8, :enum "AVColorPrimaries", :raw-comment "///< colour filters using Illuminant C"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_BT2020", :type "CXType_Int", :name "AVCOL_PRI_BT2020", :value 9, :enum "AVColorPrimaries", :raw-comment "///< ITU-R BT2020"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTE428", :type "CXType_Int", :name "AVCOL_PRI_SMPTE428", :value 10, :enum "AVColorPrimaries", :raw-comment "///< SMPTE ST 428-1 (CIE 1931 XYZ)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTEST428_1", :type "CXType_Int", :name "AVCOL_PRI_SMPTEST428_1", :value 10, :enum "AVColorPrimaries", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTE431", :type "CXType_Int", :name "AVCOL_PRI_SMPTE431", :value 11, :enum "AVColorPrimaries", :raw-comment "///< SMPTE ST 431-2 (2011) / DCI P3"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_SMPTE432", :type "CXType_Int", :name "AVCOL_PRI_SMPTE432", :value 12, :enum "AVColorPrimaries", :raw-comment "///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_EBU3213", :type "CXType_Int", :name "AVCOL_PRI_EBU3213", :value 22, :enum "AVColorPrimaries", :raw-comment "///< EBU Tech. 3213-E / JEDEC P22 phosphors"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_JEDEC_P22", :type "CXType_Int", :name "AVCOL_PRI_JEDEC_P22", :value 22, :enum "AVColorPrimaries", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_PRI_NB", :type "CXType_Int", :name "AVCOL_PRI_NB", :value 23, :enum "AVColorPrimaries", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_RESERVED0", :type "CXType_Int", :name "AVCOL_TRC_RESERVED0", :value 0, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_BT709", :type "CXType_Int", :name "AVCOL_TRC_BT709", :value 1, :enum "AVColorTransferCharacteristic", :raw-comment "///< also ITU-R BT1361"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_UNSPECIFIED", :type "CXType_Int", :name "AVCOL_TRC_UNSPECIFIED", :value 2, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_RESERVED", :type "CXType_Int", :name "AVCOL_TRC_RESERVED", :value 3, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_GAMMA22", :type "CXType_Int", :name "AVCOL_TRC_GAMMA22", :value 4, :enum "AVColorTransferCharacteristic", :raw-comment "///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_GAMMA28", :type "CXType_Int", :name "AVCOL_TRC_GAMMA28", :value 5, :enum "AVColorTransferCharacteristic", :raw-comment "///< also ITU-R BT470BG"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTE170M", :type "CXType_Int", :name "AVCOL_TRC_SMPTE170M", :value 6, :enum "AVColorTransferCharacteristic", :raw-comment "///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTE240M", :type "CXType_Int", :name "AVCOL_TRC_SMPTE240M", :value 7, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_LINEAR", :type "CXType_Int", :name "AVCOL_TRC_LINEAR", :value 8, :enum "AVColorTransferCharacteristic", :raw-comment "///< \"Linear transfer characteristics\""} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_LOG", :type "CXType_Int", :name "AVCOL_TRC_LOG", :value 9, :enum "AVColorTransferCharacteristic", :raw-comment "///< \"Logarithmic transfer characteristic (100:1 range)\""} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_LOG_SQRT", :type "CXType_Int", :name "AVCOL_TRC_LOG_SQRT", :value 10, :enum "AVColorTransferCharacteristic", :raw-comment "///< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_IEC61966_2_4", :type "CXType_Int", :name "AVCOL_TRC_IEC61966_2_4", :value 11, :enum "AVColorTransferCharacteristic", :raw-comment "///< IEC 61966-2-4"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_BT1361_ECG", :type "CXType_Int", :name "AVCOL_TRC_BT1361_ECG", :value 12, :enum "AVColorTransferCharacteristic", :raw-comment "///< ITU-R BT1361 Extended Colour Gamut"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_IEC61966_2_1", :type "CXType_Int", :name "AVCOL_TRC_IEC61966_2_1", :value 13, :enum "AVColorTransferCharacteristic", :raw-comment "///< IEC 61966-2-1 (sRGB or sYCC)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_BT2020_10", :type "CXType_Int", :name "AVCOL_TRC_BT2020_10", :value 14, :enum "AVColorTransferCharacteristic", :raw-comment "///< ITU-R BT2020 for 10-bit system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_BT2020_12", :type "CXType_Int", :name "AVCOL_TRC_BT2020_12", :value 15, :enum "AVColorTransferCharacteristic", :raw-comment "///< ITU-R BT2020 for 12-bit system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTE2084", :type "CXType_Int", :name "AVCOL_TRC_SMPTE2084", :value 16, :enum "AVColorTransferCharacteristic", :raw-comment "///< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTEST2084", :type "CXType_Int", :name "AVCOL_TRC_SMPTEST2084", :value 16, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTE428", :type "CXType_Int", :name "AVCOL_TRC_SMPTE428", :value 17, :enum "AVColorTransferCharacteristic", :raw-comment "///< SMPTE ST 428-1"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_SMPTEST428_1", :type "CXType_Int", :name "AVCOL_TRC_SMPTEST428_1", :value 17, :enum "AVColorTransferCharacteristic", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_ARIB_STD_B67", :type "CXType_Int", :name "AVCOL_TRC_ARIB_STD_B67", :value 18, :enum "AVColorTransferCharacteristic", :raw-comment "///< ARIB STD-B67, known as \"Hybrid log-gamma\""} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_TRC_NB", :type "CXType_Int", :name "AVCOL_TRC_NB", :value 19, :enum "AVColorTransferCharacteristic", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_RGB", :type "CXType_Int", :name "AVCOL_SPC_RGB", :value 0, :enum "AVColorSpace", :raw-comment "///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_BT709", :type "CXType_Int", :name "AVCOL_SPC_BT709", :value 1, :enum "AVColorSpace", :raw-comment "///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_UNSPECIFIED", :type "CXType_Int", :name "AVCOL_SPC_UNSPECIFIED", :value 2, :enum "AVColorSpace", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_RESERVED", :type "CXType_Int", :name "AVCOL_SPC_RESERVED", :value 3, :enum "AVColorSpace", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_FCC", :type "CXType_Int", :name "AVCOL_SPC_FCC", :value 4, :enum "AVColorSpace", :raw-comment "///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_BT470BG", :type "CXType_Int", :name "AVCOL_SPC_BT470BG", :value 5, :enum "AVColorSpace", :raw-comment "///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_SMPTE170M", :type "CXType_Int", :name "AVCOL_SPC_SMPTE170M", :value 6, :enum "AVColorSpace", :raw-comment "///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_SMPTE240M", :type "CXType_Int", :name "AVCOL_SPC_SMPTE240M", :value 7, :enum "AVColorSpace", :raw-comment "///< functionally identical to above"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_YCGCO", :type "CXType_Int", :name "AVCOL_SPC_YCGCO", :value 8, :enum "AVColorSpace", :raw-comment "///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_YCOCG", :type "CXType_Int", :name "AVCOL_SPC_YCOCG", :value 8, :enum "AVColorSpace", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_BT2020_NCL", :type "CXType_Int", :name "AVCOL_SPC_BT2020_NCL", :value 9, :enum "AVColorSpace", :raw-comment "///< ITU-R BT2020 non-constant luminance system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_BT2020_CL", :type "CXType_Int", :name "AVCOL_SPC_BT2020_CL", :value 10, :enum "AVColorSpace", :raw-comment "///< ITU-R BT2020 constant luminance system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_SMPTE2085", :type "CXType_Int", :name "AVCOL_SPC_SMPTE2085", :value 11, :enum "AVColorSpace", :raw-comment "///< SMPTE 2085, Y'D'zD'x"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_CHROMA_DERIVED_NCL", :type "CXType_Int", :name "AVCOL_SPC_CHROMA_DERIVED_NCL", :value 12, :enum "AVColorSpace", :raw-comment "///< Chromaticity-derived non-constant luminance system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_CHROMA_DERIVED_CL", :type "CXType_Int", :name "AVCOL_SPC_CHROMA_DERIVED_CL", :value 13, :enum "AVColorSpace", :raw-comment "///< Chromaticity-derived constant luminance system"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_ICTCP", :type "CXType_Int", :name "AVCOL_SPC_ICTCP", :value 14, :enum "AVColorSpace", :raw-comment "///< ITU-R BT.2100-0, ICtCp"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_SPC_NB", :type "CXType_Int", :name "AVCOL_SPC_NB", :value 15, :enum "AVColorSpace", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_RANGE_UNSPECIFIED", :type "CXType_Int", :name "AVCOL_RANGE_UNSPECIFIED", :value 0, :enum "AVColorRange", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_RANGE_MPEG", :type "CXType_Int", :name "AVCOL_RANGE_MPEG", :value 1, :enum "AVColorRange", :raw-comment "/**\n     * Narrow or limited range content.\n     *\n     * - For luminance planes:\n     *\n     *       (219 * E + 16) * 2^(n-8)\n     *\n     *   F.ex. the range of 16-235 for 8 bits\n     *\n     * - For chrominance planes:\n     *\n     *       (224 * E + 128) * 2^(n-8)\n     *\n     *   F.ex. the range of 16-240 for 8 bits\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_RANGE_JPEG", :type "CXType_Int", :name "AVCOL_RANGE_JPEG", :value 2, :enum "AVColorRange", :raw-comment "/**\n     * Full range content.\n     *\n     * - For RGB and luminance planes:\n     *\n     *       (2^n - 1) * E\n     *\n     *   F.ex. the range of 0-255 for 8 bits\n     *\n     * - For chrominance planes:\n     *\n     *       (2^n - 1) * E + 2^(n - 1)\n     *\n     *   F.ex. the range of 1-255 for 8 bits\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCOL_RANGE_NB", :type "CXType_Int", :name "AVCOL_RANGE_NB", :value 3, :enum "AVColorRange", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_UNSPECIFIED", :type "CXType_Int", :name "AVCHROMA_LOC_UNSPECIFIED", :value 0, :enum "AVChromaLocation", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_LEFT", :type "CXType_Int", :name "AVCHROMA_LOC_LEFT", :value 1, :enum "AVChromaLocation", :raw-comment "///< MPEG-2/4 4:2:0, H.264 default for 4:2:0"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_CENTER", :type "CXType_Int", :name "AVCHROMA_LOC_CENTER", :value 2, :enum "AVChromaLocation", :raw-comment "///< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_TOPLEFT", :type "CXType_Int", :name "AVCHROMA_LOC_TOPLEFT", :value 3, :enum "AVChromaLocation", :raw-comment "///< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_TOP", :type "CXType_Int", :name "AVCHROMA_LOC_TOP", :value 4, :enum "AVChromaLocation", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_BOTTOMLEFT", :type "CXType_Int", :name "AVCHROMA_LOC_BOTTOMLEFT", :value 5, :enum "AVChromaLocation", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_BOTTOM", :type "CXType_Int", :name "AVCHROMA_LOC_BOTTOM", :value 6, :enum "AVChromaLocation", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVCHROMA_LOC_NB", :type "CXType_Int", :name "AVCHROMA_LOC_NB", :value 7, :enum "AVChromaLocation", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_UNKNOWN", :type "CXType_Int", :name "AVMEDIA_TYPE_UNKNOWN", :value -1, :enum "AVMediaType", :raw-comment "///< Usually treated as AVMEDIA_TYPE_DATA"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_VIDEO", :type "CXType_Int", :name "AVMEDIA_TYPE_VIDEO", :value 0, :enum "AVMediaType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_AUDIO", :type "CXType_Int", :name "AVMEDIA_TYPE_AUDIO", :value 1, :enum "AVMediaType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_DATA", :type "CXType_Int", :name "AVMEDIA_TYPE_DATA", :value 2, :enum "AVMediaType", :raw-comment "///< Opaque data information usually continuous"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_SUBTITLE", :type "CXType_Int", :name "AVMEDIA_TYPE_SUBTITLE", :value 3, :enum "AVMediaType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_ATTACHMENT", :type "CXType_Int", :name "AVMEDIA_TYPE_ATTACHMENT", :value 4, :enum "AVMediaType", :raw-comment "///< Opaque data information usually sparse"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVMEDIA_TYPE_NB", :type "CXType_Int", :name "AVMEDIA_TYPE_NB", :value 5, :enum "AVMediaType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_NONE", :type "CXType_Int", :name "AV_PICTURE_TYPE_NONE", :value 0, :enum "AVPictureType", :raw-comment "///< Undefined"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_I", :type "CXType_Int", :name "AV_PICTURE_TYPE_I", :value 1, :enum "AVPictureType", :raw-comment "///< Intra"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_P", :type "CXType_Int", :name "AV_PICTURE_TYPE_P", :value 2, :enum "AVPictureType", :raw-comment "///< Predicted"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_B", :type "CXType_Int", :name "AV_PICTURE_TYPE_B", :value 3, :enum "AVPictureType", :raw-comment "///< Bi-dir predicted"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_S", :type "CXType_Int", :name "AV_PICTURE_TYPE_S", :value 4, :enum "AVPictureType", :raw-comment "///< S(GMC)-VOP MPEG-4"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_SI", :type "CXType_Int", :name "AV_PICTURE_TYPE_SI", :value 5, :enum "AVPictureType", :raw-comment "///< Switching Intra"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_SP", :type "CXType_Int", :name "AV_PICTURE_TYPE_SP", :value 6, :enum "AVPictureType", :raw-comment "///< Switching Predicted"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_TYPE_BI", :type "CXType_Int", :name "AV_PICTURE_TYPE_BI", :value 7, :enum "AVPictureType", :raw-comment "///< BI type"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_ZERO", :type "CXType_Int", :name "AV_ROUND_ZERO", :value 0, :enum "AVRounding", :raw-comment "///< Round toward zero."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_INF", :type "CXType_Int", :name "AV_ROUND_INF", :value 1, :enum "AVRounding", :raw-comment "///< Round away from zero."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_DOWN", :type "CXType_Int", :name "AV_ROUND_DOWN", :value 2, :enum "AVRounding", :raw-comment "///< Round toward -infinity."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_UP", :type "CXType_Int", :name "AV_ROUND_UP", :value 3, :enum "AVRounding", :raw-comment "///< Round toward +infinity."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_NEAR_INF", :type "CXType_Int", :name "AV_ROUND_NEAR_INF", :value 5, :enum "AVRounding", :raw-comment "///< Round to nearest and halfway cases away from zero."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ROUND_PASS_MINMAX", :type "CXType_Int", :name "AV_ROUND_PASS_MINMAX", :value 8192, :enum "AVRounding", :raw-comment "/**\n     * Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through\n     * unchanged, avoiding special cases for #AV_NOPTS_VALUE.\n     *\n     * Unlike other values of the enumeration AVRounding, this value is a\n     * bitmask that must be used in conjunction with another value of the\n     * enumeration through a bitwise OR, in order to set behavior for normal\n     * cases.\n     *\n     * @code{.c}\n     * av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n     * // Rescaling 3:\n     * //     Calculating 3 * 1 / 2\n     * //     3 / 2 is rounded up to 2\n     * //     => 2\n     *\n     * av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n     * // Rescaling AV_NOPTS_VALUE:\n     * //     AV_NOPTS_VALUE == INT64_MIN\n     * //     AV_NOPTS_VALUE is passed through\n     * //     => AV_NOPTS_VALUE\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_NA", :type "CXType_Int", :name "AV_CLASS_CATEGORY_NA", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_INPUT", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_OUTPUT", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_MUXER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_MUXER", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEMUXER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEMUXER", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_ENCODER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_ENCODER", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DECODER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DECODER", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_FILTER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_FILTER", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_BITSTREAM_FILTER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_BITSTREAM_FILTER", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_SWSCALER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_SWSCALER", :value 9, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_SWRESAMPLER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_SWRESAMPLER", :value 10, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT", :value 40, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT", :value 41, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT", :value 42, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT", :value 43, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_OUTPUT", :value 44, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_INPUT", :value 45, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_NB", :type "CXType_Int", :name "AV_CLASS_CATEGORY_NB", :value 46, :enum "", :raw-comment "///< not part of ABI/API"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_NA", :type "CXType_Int", :name "AV_CLASS_CATEGORY_NA", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_INPUT", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_OUTPUT", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_MUXER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_MUXER", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEMUXER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEMUXER", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_ENCODER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_ENCODER", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DECODER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DECODER", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_FILTER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_FILTER", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_BITSTREAM_FILTER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_BITSTREAM_FILTER", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_SWSCALER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_SWSCALER", :value 9, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_SWRESAMPLER", :type "CXType_Int", :name "AV_CLASS_CATEGORY_SWRESAMPLER", :value 10, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT", :value 40, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT", :value 41, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT", :value 42, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT", :value 43, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_OUTPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_OUTPUT", :value 44, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_DEVICE_INPUT", :type "CXType_Int", :name "AV_CLASS_CATEGORY_DEVICE_INPUT", :value 45, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CLASS_CATEGORY_NB", :type "CXType_Int", :name "AV_CLASS_CATEGORY_NB", :value 46, :enum "", :raw-comment "///< not part of ABI/API"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_NONE", :type "CXType_Int", :name "AV_SAMPLE_FMT_NONE", :value -1, :enum "AVSampleFormat", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_U8", :type "CXType_Int", :name "AV_SAMPLE_FMT_U8", :value 0, :enum "AVSampleFormat", :raw-comment "///< unsigned 8 bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S16", :type "CXType_Int", :name "AV_SAMPLE_FMT_S16", :value 1, :enum "AVSampleFormat", :raw-comment "///< signed 16 bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S32", :type "CXType_Int", :name "AV_SAMPLE_FMT_S32", :value 2, :enum "AVSampleFormat", :raw-comment "///< signed 32 bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_FLT", :type "CXType_Int", :name "AV_SAMPLE_FMT_FLT", :value 3, :enum "AVSampleFormat", :raw-comment "///< float"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_DBL", :type "CXType_Int", :name "AV_SAMPLE_FMT_DBL", :value 4, :enum "AVSampleFormat", :raw-comment "///< double"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_U8P", :type "CXType_Int", :name "AV_SAMPLE_FMT_U8P", :value 5, :enum "AVSampleFormat", :raw-comment "///< unsigned 8 bits, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S16P", :type "CXType_Int", :name "AV_SAMPLE_FMT_S16P", :value 6, :enum "AVSampleFormat", :raw-comment "///< signed 16 bits, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S32P", :type "CXType_Int", :name "AV_SAMPLE_FMT_S32P", :value 7, :enum "AVSampleFormat", :raw-comment "///< signed 32 bits, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_FLTP", :type "CXType_Int", :name "AV_SAMPLE_FMT_FLTP", :value 8, :enum "AVSampleFormat", :raw-comment "///< float, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_DBLP", :type "CXType_Int", :name "AV_SAMPLE_FMT_DBLP", :value 9, :enum "AVSampleFormat", :raw-comment "///< double, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S64", :type "CXType_Int", :name "AV_SAMPLE_FMT_S64", :value 10, :enum "AVSampleFormat", :raw-comment "///< signed 64 bits"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_S64P", :type "CXType_Int", :name "AV_SAMPLE_FMT_S64P", :value 11, :enum "AVSampleFormat", :raw-comment "///< signed 64 bits, planar"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SAMPLE_FMT_NB", :type "CXType_Int", :name "AV_SAMPLE_FMT_NB", :value 12, :enum "AVSampleFormat", :raw-comment "///< Number of sample formats. DO NOT USE if linking dynamically"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_PANSCAN", :type "CXType_Int", :name "AV_FRAME_DATA_PANSCAN", :value 0, :enum "AVFrameSideDataType", :raw-comment "/**\n     * The data is the AVPanScan struct defined in libavcodec.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_A53_CC", :type "CXType_Int", :name "AV_FRAME_DATA_A53_CC", :value 1, :enum "AVFrameSideDataType", :raw-comment "/**\n     * ATSC A53 Part 4 Closed Captions.\n     * A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.\n     * The number of bytes of CC data is AVFrameSideData.size.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_STEREO3D", :type "CXType_Int", :name "AV_FRAME_DATA_STEREO3D", :value 2, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Stereoscopic 3d metadata.\n     * The data is the AVStereo3D struct defined in libavutil/stereo3d.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_MATRIXENCODING", :type "CXType_Int", :name "AV_FRAME_DATA_MATRIXENCODING", :value 3, :enum "AVFrameSideDataType", :raw-comment "/**\n     * The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_DOWNMIX_INFO", :type "CXType_Int", :name "AV_FRAME_DATA_DOWNMIX_INFO", :value 4, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Metadata relevant to a downmix procedure.\n     * The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_REPLAYGAIN", :type "CXType_Int", :name "AV_FRAME_DATA_REPLAYGAIN", :value 5, :enum "AVFrameSideDataType", :raw-comment "/**\n     * ReplayGain information in the form of the AVReplayGain struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_DISPLAYMATRIX", :type "CXType_Int", :name "AV_FRAME_DATA_DISPLAYMATRIX", :value 6, :enum "AVFrameSideDataType", :raw-comment "/**\n     * This side data contains a 3x3 transformation matrix describing an affine\n     * transformation that needs to be applied to the frame for correct\n     * presentation.\n     *\n     * See libavutil/display.h for a detailed description of the data.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_AFD", :type "CXType_Int", :name "AV_FRAME_DATA_AFD", :value 7, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Active Format Description data consisting of a single byte as specified\n     * in ETSI TS 101 154 using AVActiveFormatDescription enum.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_MOTION_VECTORS", :type "CXType_Int", :name "AV_FRAME_DATA_MOTION_VECTORS", :value 8, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Motion vectors exported by some codecs (on demand through the export_mvs\n     * flag set in the libavcodec AVCodecContext flags2 option).\n     * The data is the AVMotionVector struct defined in\n     * libavutil/motion_vector.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_SKIP_SAMPLES", :type "CXType_Int", :name "AV_FRAME_DATA_SKIP_SAMPLES", :value 9, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Recommmends skipping the specified number of samples. This is exported\n     * only if the \"skip_manual\" AVOption is set in libavcodec.\n     * This has the same format as AV_PKT_DATA_SKIP_SAMPLES.\n     * @code\n     * u32le number of samples to skip from start of this packet\n     * u32le number of samples to skip from end of this packet\n     * u8    reason for start skip\n     * u8    reason for end   skip (0=padding silence, 1=convergence)\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_AUDIO_SERVICE_TYPE", :type "CXType_Int", :name "AV_FRAME_DATA_AUDIO_SERVICE_TYPE", :value 10, :enum "AVFrameSideDataType", :raw-comment "/**\n     * This side data must be associated with an audio frame and corresponds to\n     * enum AVAudioServiceType defined in avcodec.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_MASTERING_DISPLAY_METADATA", :type "CXType_Int", :name "AV_FRAME_DATA_MASTERING_DISPLAY_METADATA", :value 11, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Mastering display metadata associated with a video frame. The payload is\n     * an AVMasteringDisplayMetadata type and contains information about the\n     * mastering display color volume.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_GOP_TIMECODE", :type "CXType_Int", :name "AV_FRAME_DATA_GOP_TIMECODE", :value 12, :enum "AVFrameSideDataType", :raw-comment "/**\n     * The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.\n     * This is set on the first frame of a GOP that has a temporal reference of 0.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_SPHERICAL", :type "CXType_Int", :name "AV_FRAME_DATA_SPHERICAL", :value 13, :enum "AVFrameSideDataType", :raw-comment "/**\n     * The data represents the AVSphericalMapping structure defined in\n     * libavutil/spherical.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_CONTENT_LIGHT_LEVEL", :type "CXType_Int", :name "AV_FRAME_DATA_CONTENT_LIGHT_LEVEL", :value 14, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Content light level (based on CTA-861.3). This payload contains data in\n     * the form of the AVContentLightMetadata struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_ICC_PROFILE", :type "CXType_Int", :name "AV_FRAME_DATA_ICC_PROFILE", :value 15, :enum "AVFrameSideDataType", :raw-comment "/**\n     * The data contains an ICC profile as an opaque octet buffer following the\n     * format described by ISO 15076-1 with an optional name defined in the\n     * metadata key entry \"name\".\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_QP_TABLE_PROPERTIES", :type "CXType_Int", :name "AV_FRAME_DATA_QP_TABLE_PROPERTIES", :value 16, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.\n     * The contents of this side data are undocumented and internal; use\n     * av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a\n     * meaningful way instead.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_QP_TABLE_DATA", :type "CXType_Int", :name "AV_FRAME_DATA_QP_TABLE_DATA", :value 17, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Raw QP table data. Its format is described by\n     * AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and\n     * av_frame_get_qp_table() to access this instead.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_S12M_TIMECODE", :type "CXType_Int", :name "AV_FRAME_DATA_S12M_TIMECODE", :value 18, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t\n     * where the first uint32_t describes how many (1-3) of the other timecodes are used.\n     * The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n     * function in libavutil/timecode.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_DYNAMIC_HDR_PLUS", :type "CXType_Int", :name "AV_FRAME_DATA_DYNAMIC_HDR_PLUS", :value 19, :enum "AVFrameSideDataType", :raw-comment "/**\n     * HDR dynamic metadata associated with a video frame. The payload is\n     * an AVDynamicHDRPlus type and contains information for color\n     * volume transform - application 4 of SMPTE 2094-40:2016 standard.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_REGIONS_OF_INTEREST", :type "CXType_Int", :name "AV_FRAME_DATA_REGIONS_OF_INTEREST", :value 20, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of\n     * array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_VIDEO_ENC_PARAMS", :type "CXType_Int", :name "AV_FRAME_DATA_VIDEO_ENC_PARAMS", :value 21, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Encoding parameters for a video frame, as described by AVVideoEncParams.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_SEI_UNREGISTERED", :type "CXType_Int", :name "AV_FRAME_DATA_SEI_UNREGISTERED", :value 22, :enum "AVFrameSideDataType", :raw-comment "/**\n     * User data unregistered metadata associated with a video frame.\n     * This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose\n     * The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of\n     * uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_DATA_FILM_GRAIN_PARAMS", :type "CXType_Int", :name "AV_FRAME_DATA_FILM_GRAIN_PARAMS", :value 23, :enum "AVFrameSideDataType", :raw-comment "/**\n     * Film grain parameters for a frame, described by AVFilmGrainParams.\n     * Must be present for every frame which should have film grain applied.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_SAME", :type "CXType_Int", :name "AV_AFD_SAME", :value 8, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_4_3", :type "CXType_Int", :name "AV_AFD_4_3", :value 9, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_16_9", :type "CXType_Int", :name "AV_AFD_16_9", :value 10, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_14_9", :type "CXType_Int", :name "AV_AFD_14_9", :value 11, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_4_3_SP_14_9", :type "CXType_Int", :name "AV_AFD_4_3_SP_14_9", :value 13, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_16_9_SP_14_9", :type "CXType_Int", :name "AV_AFD_16_9_SP_14_9", :value 14, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AFD_SP_4_3", :type "CXType_Int", :name "AV_AFD_SP_4_3", :value 15, :enum "AVActiveFormatDescription", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FRAME_CROP_UNALIGNED", :type "CXType_Int", :name "AV_FRAME_CROP_UNALIGNED", :value 1, :enum "", :raw-comment "/**\n     * Apply the maximum possible cropping, even if it requires setting the\n     * AVFrame.data[] entries to unaligned pointers. Passing unaligned data\n     * to FFmpeg API is generally not allowed, and causes undefined behavior\n     * (such as crashes). You can pass unaligned data only to FFmpeg APIs that\n     * are explicitly documented to accept it. Use this flag only if you\n     * absolutely know what you are doing.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_2D", :type "CXType_Int", :name "AV_STEREO3D_2D", :value 0, :enum "AVStereo3DType", :raw-comment "/**\n     * Video is not stereoscopic (and metadata has to be there).\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_SIDEBYSIDE", :type "CXType_Int", :name "AV_STEREO3D_SIDEBYSIDE", :value 1, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are next to each other.\n     *\n     * @code{.unparsed}\n     *    LLLLRRRR\n     *    LLLLRRRR\n     *    LLLLRRRR\n     *    ...\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_TOPBOTTOM", :type "CXType_Int", :name "AV_STEREO3D_TOPBOTTOM", :value 2, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are on top of each other.\n     *\n     * @code{.unparsed}\n     *    LLLLLLLL\n     *    LLLLLLLL\n     *    RRRRRRRR\n     *    RRRRRRRR\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_FRAMESEQUENCE", :type "CXType_Int", :name "AV_STEREO3D_FRAMESEQUENCE", :value 3, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are alternated temporally.\n     *\n     * @code{.unparsed}\n     *     frame0   frame1   frame2   ...\n     *    LLLLLLLL RRRRRRRR LLLLLLLL\n     *    LLLLLLLL RRRRRRRR LLLLLLLL\n     *    LLLLLLLL RRRRRRRR LLLLLLLL\n     *    ...      ...      ...\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_CHECKERBOARD", :type "CXType_Int", :name "AV_STEREO3D_CHECKERBOARD", :value 4, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are packed in a checkerboard-like structure per pixel.\n     *\n     * @code{.unparsed}\n     *    LRLRLRLR\n     *    RLRLRLRL\n     *    LRLRLRLR\n     *    ...\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_SIDEBYSIDE_QUINCUNX", :type "CXType_Int", :name "AV_STEREO3D_SIDEBYSIDE_QUINCUNX", :value 5, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are next to each other, but when upscaling\n     * apply a checkerboard pattern.\n     *\n     * @code{.unparsed}\n     *     LLLLRRRR          L L L L    R R R R\n     *     LLLLRRRR    =>     L L L L  R R R R\n     *     LLLLRRRR          L L L L    R R R R\n     *     LLLLRRRR           L L L L  R R R R\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_LINES", :type "CXType_Int", :name "AV_STEREO3D_LINES", :value 6, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are packed per line, as if interlaced.\n     *\n     * @code{.unparsed}\n     *    LLLLLLLL\n     *    RRRRRRRR\n     *    LLLLLLLL\n     *    ...\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_COLUMNS", :type "CXType_Int", :name "AV_STEREO3D_COLUMNS", :value 7, :enum "AVStereo3DType", :raw-comment "/**\n     * Views are packed per column.\n     *\n     * @code{.unparsed}\n     *    LRLRLRLR\n     *    LRLRLRLR\n     *    LRLRLRLR\n     *    ...\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_VIEW_PACKED", :type "CXType_Int", :name "AV_STEREO3D_VIEW_PACKED", :value 0, :enum "AVStereo3DView", :raw-comment "/**\n     * Frame contains two packed views.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_VIEW_LEFT", :type "CXType_Int", :name "AV_STEREO3D_VIEW_LEFT", :value 1, :enum "AVStereo3DView", :raw-comment "/**\n     * Frame contains only the left view.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_STEREO3D_VIEW_RIGHT", :type "CXType_Int", :name "AV_STEREO3D_VIEW_RIGHT", :value 2, :enum "AVStereo3DView", :raw-comment "/**\n     * Frame contains only the right view.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_8_ATM", :type "CXType_Int", :name "AV_CRC_8_ATM", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_ANSI", :type "CXType_Int", :name "AV_CRC_16_ANSI", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_CCITT", :type "CXType_Int", :name "AV_CRC_16_CCITT", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_32_IEEE", :type "CXType_Int", :name "AV_CRC_32_IEEE", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_32_IEEE_LE", :type "CXType_Int", :name "AV_CRC_32_IEEE_LE", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_ANSI_LE", :type "CXType_Int", :name "AV_CRC_16_ANSI_LE", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_24_IEEE", :type "CXType_Int", :name "AV_CRC_24_IEEE", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_8_EBU", :type "CXType_Int", :name "AV_CRC_8_EBU", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_MAX", :type "CXType_Int", :name "AV_CRC_MAX", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_8_ATM", :type "CXType_Int", :name "AV_CRC_8_ATM", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_ANSI", :type "CXType_Int", :name "AV_CRC_16_ANSI", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_CCITT", :type "CXType_Int", :name "AV_CRC_16_CCITT", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_32_IEEE", :type "CXType_Int", :name "AV_CRC_32_IEEE", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_32_IEEE_LE", :type "CXType_Int", :name "AV_CRC_32_IEEE_LE", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_16_ANSI_LE", :type "CXType_Int", :name "AV_CRC_16_ANSI_LE", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_24_IEEE", :type "CXType_Int", :name "AV_CRC_24_IEEE", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_8_EBU", :type "CXType_Int", :name "AV_CRC_8_EBU", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CRC_MAX", :type "CXType_Int", :name "AV_CRC_MAX", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VAAPI_DRIVER_QUIRK_USER_SET", :type "CXType_Int", :name "AV_VAAPI_DRIVER_QUIRK_USER_SET", :value 1, :enum "", :raw-comment "/**\n     * The quirks field has been set by the user and should not be detected\n     * automatically by av_hwdevice_ctx_init().\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS", :type "CXType_Int", :name "AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS", :value 2, :enum "", :raw-comment "/**\n     * The driver does not destroy parameter buffers when they are used by\n     * vaRenderPicture().  Additional code will be required to destroy them\n     * separately afterwards.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE", :type "CXType_Int", :name "AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE", :value 4, :enum "", :raw-comment "/**\n     * The driver does not support the VASurfaceAttribMemoryType attribute,\n     * so the surface allocation code will not try to use it.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES", :type "CXType_Int", :name "AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES", :value 8, :enum "", :raw-comment "/**\n     * The driver does not support surface attributes at all.\n     * The surface allocation code will never pass them to surface allocation,\n     * and the results of the vaQuerySurfaceAttributes() call will be faked.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SPHERICAL_EQUIRECTANGULAR", :type "CXType_Int", :name "AV_SPHERICAL_EQUIRECTANGULAR", :value 0, :enum "AVSphericalProjection", :raw-comment "/**\n     * Video represents a sphere mapped on a flat surface using\n     * equirectangular projection.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SPHERICAL_CUBEMAP", :type "CXType_Int", :name "AV_SPHERICAL_CUBEMAP", :value 1, :enum "AVSphericalProjection", :raw-comment "/**\n     * Video frame is split into 6 faces of a cube, and arranged on a\n     * 3x2 layout. Faces are oriented upwards for the front, left, right,\n     * and back faces. The up face is oriented so the top of the face is\n     * forwards and the down face is oriented so the top of the face is\n     * to the back.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SPHERICAL_EQUIRECTANGULAR_TILE", :type "CXType_Int", :name "AV_SPHERICAL_EQUIRECTANGULAR_TILE", :value 2, :enum "AVSphericalProjection", :raw-comment "/**\n     * Video represents a portion of a sphere mapped on a flat surface\n     * using equirectangular projection. The @ref bounding fields indicate\n     * the position of the current video in a larger surface.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_THREAD_MESSAGE_NONBLOCK", :type "CXType_Int", :name "AV_THREAD_MESSAGE_NONBLOCK", :value 1, :enum "AVThreadMessageFlags", :raw-comment "/**\n     * Perform non-blocking operation.\n     * If this flag is set, send and recv operations are non-blocking and\n     * return AVERROR(EAGAIN) immediately if they can not proceed.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_THREAD_MESSAGE_NONBLOCK", :type "CXType_Int", :name "AV_THREAD_MESSAGE_NONBLOCK", :value 1, :enum "AVThreadMessageFlags", :raw-comment "/**\n     * Perform non-blocking operation.\n     * If this flag is set, send and recv operations are non-blocking and\n     * return AVERROR(EAGAIN) immediately if they can not proceed.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TIMECODE_FLAG_DROPFRAME", :type "CXType_Int", :name "AV_TIMECODE_FLAG_DROPFRAME", :value 1, :enum "AVTimecodeFlag", :raw-comment "///< timecode is drop frame"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TIMECODE_FLAG_24HOURSMAX", :type "CXType_Int", :name "AV_TIMECODE_FLAG_24HOURSMAX", :value 2, :enum "AVTimecodeFlag", :raw-comment "///< timecode wraps after 24 hours"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TIMECODE_FLAG_ALLOWNEGATIVE", :type "CXType_Int", :name "AV_TIMECODE_FLAG_ALLOWNEGATIVE", :value 4, :enum "AVTimecodeFlag", :raw-comment "///< negative time values are allowed"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_FLOAT_FFT", :type "CXType_Int", :name "AV_TX_FLOAT_FFT", :value 0, :enum "AVTXType", :raw-comment "/**\n     * Standard complex to complex FFT with sample data type AVComplexFloat.\n     * Output is not 1/len normalized. Scaling currently unsupported.\n     * The stride parameter is ignored.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_FLOAT_MDCT", :type "CXType_Int", :name "AV_TX_FLOAT_MDCT", :value 1, :enum "AVTXType", :raw-comment "/**\n     * Standard MDCT with sample data type of float and a scale type of\n     * float. Length is the frame size, not the window size (which is 2x frame)\n     * For forward transforms, the stride specifies the spacing between each\n     * sample in the output array in bytes. The input must be a flat array.\n     * For inverse transforms, the stride specifies the spacing between each\n     * sample in the input array in bytes. The output will be a flat array.\n     * Stride must be a non-zero multiple of sizeof(float).\n     * NOTE: the inverse transform is half-length, meaning the output will not\n     * contain redundant data. This is what most codecs work with.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_DOUBLE_FFT", :type "CXType_Int", :name "AV_TX_DOUBLE_FFT", :value 2, :enum "AVTXType", :raw-comment "/**\n     * Same as AV_TX_FLOAT_FFT with a data type of AVComplexDouble.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_DOUBLE_MDCT", :type "CXType_Int", :name "AV_TX_DOUBLE_MDCT", :value 3, :enum "AVTXType", :raw-comment "/**\n     * Same as AV_TX_FLOAT_MDCT with data and scale type of double.\n     * Stride must be a non-zero multiple of sizeof(double).\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_INT32_FFT", :type "CXType_Int", :name "AV_TX_INT32_FFT", :value 4, :enum "AVTXType", :raw-comment "/**\n     * Same as AV_TX_FLOAT_FFT with a data type of AVComplexInt32.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_INT32_MDCT", :type "CXType_Int", :name "AV_TX_INT32_MDCT", :value 5, :enum "AVTXType", :raw-comment "/**\n     * Same as AV_TX_FLOAT_MDCT with data type of int32_t and scale type of float.\n     * Only scale values less than or equal to 1.0 are supported.\n     * Stride must be a non-zero multiple of sizeof(int32_t).\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_TX_INPLACE", :type "CXType_Int", :name "AV_TX_INPLACE", :value 1, :enum "AVTXFlags", :raw-comment "/**\n     * Performs an in-place transformation on the input. The output argument\n     * of av_tn_fn() MUST match the input. May be unsupported or slower for some\n     * transform types.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DRM_MAX_PLANES", :type "CXType_Int", :name "AV_DRM_MAX_PLANES", :value 4, :enum "", :raw-comment "/**\n     * The maximum number of layers/planes in a DRM frame.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_MD5", :type "CXType_Int", :name "AV_HMAC_MD5", :value 0, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_SHA1", :type "CXType_Int", :name "AV_HMAC_SHA1", :value 1, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_SHA224", :type "CXType_Int", :name "AV_HMAC_SHA224", :value 2, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_SHA256", :type "CXType_Int", :name "AV_HMAC_SHA256", :value 3, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_SHA384", :type "CXType_Int", :name "AV_HMAC_SHA384", :value 4, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HMAC_SHA512", :type "CXType_Int", :name "AV_HMAC_SHA512", :value 5, :enum "AVHMACType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_FLAGS", :type "CXType_Int", :name "AV_OPT_TYPE_FLAGS", :value 0, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_INT", :type "CXType_Int", :name "AV_OPT_TYPE_INT", :value 1, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_INT64", :type "CXType_Int", :name "AV_OPT_TYPE_INT64", :value 2, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_DOUBLE", :type "CXType_Int", :name "AV_OPT_TYPE_DOUBLE", :value 3, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_FLOAT", :type "CXType_Int", :name "AV_OPT_TYPE_FLOAT", :value 4, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_STRING", :type "CXType_Int", :name "AV_OPT_TYPE_STRING", :value 5, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_RATIONAL", :type "CXType_Int", :name "AV_OPT_TYPE_RATIONAL", :value 6, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_BINARY", :type "CXType_Int", :name "AV_OPT_TYPE_BINARY", :value 7, :enum "AVOptionType", :raw-comment "///< offset must point to a pointer immediately followed by an int for the length"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_DICT", :type "CXType_Int", :name "AV_OPT_TYPE_DICT", :value 8, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_UINT64", :type "CXType_Int", :name "AV_OPT_TYPE_UINT64", :value 9, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_CONST", :type "CXType_Int", :name "AV_OPT_TYPE_CONST", :value 10, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_IMAGE_SIZE", :type "CXType_Int", :name "AV_OPT_TYPE_IMAGE_SIZE", :value 11, :enum "AVOptionType", :raw-comment "///< offset must point to two consecutive integers"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_PIXEL_FMT", :type "CXType_Int", :name "AV_OPT_TYPE_PIXEL_FMT", :value 12, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_SAMPLE_FMT", :type "CXType_Int", :name "AV_OPT_TYPE_SAMPLE_FMT", :value 13, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_VIDEO_RATE", :type "CXType_Int", :name "AV_OPT_TYPE_VIDEO_RATE", :value 14, :enum "AVOptionType", :raw-comment "///< offset must point to AVRational"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_DURATION", :type "CXType_Int", :name "AV_OPT_TYPE_DURATION", :value 15, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_COLOR", :type "CXType_Int", :name "AV_OPT_TYPE_COLOR", :value 16, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_CHANNEL_LAYOUT", :type "CXType_Int", :name "AV_OPT_TYPE_CHANNEL_LAYOUT", :value 17, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_TYPE_BOOL", :type "CXType_Int", :name "AV_OPT_TYPE_BOOL", :value 18, :enum "AVOptionType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_OPT_FLAG_IMPLICIT_KEY", :type "CXType_Int", :name "AV_OPT_FLAG_IMPLICIT_KEY", :value 1, :enum "", :raw-comment "/**\n     * Accept to parse a value without a key; the key will then be returned\n     * as NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_NONE", :type "CXType_Int", :name "AV_MATRIX_ENCODING_NONE", :value 0, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DOLBY", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DOLBY", :value 1, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DPLII", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DPLII", :value 2, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DPLIIX", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DPLIIX", :value 3, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DPLIIZ", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DPLIIZ", :value 4, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DOLBYEX", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DOLBYEX", :value 5, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_DOLBYHEADPHONE", :type "CXType_Int", :name "AV_MATRIX_ENCODING_DOLBYHEADPHONE", :value 6, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MATRIX_ENCODING_NB", :type "CXType_Int", :name "AV_MATRIX_ENCODING_NB", :value 7, :enum "AVMatrixEncoding", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VIDEO_ENC_PARAMS_NONE", :type "CXType_Int", :name "AV_VIDEO_ENC_PARAMS_NONE", :value -1, :enum "AVVideoEncParamsType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VIDEO_ENC_PARAMS_VP9", :type "CXType_Int", :name "AV_VIDEO_ENC_PARAMS_VP9", :value 0, :enum "AVVideoEncParamsType", :raw-comment "/**\n     * VP9 stores:\n     * - per-frame base (luma AC) quantizer index, exported as AVVideoEncParams.qp\n     * - deltas for luma DC, chroma AC and chroma DC, exported in the\n     *   corresponding entries in AVVideoEncParams.delta_qp\n     * - per-segment delta, exported as for each block as AVVideoBlockParams.delta_qp\n     *\n     * To compute the resulting quantizer index for a block:\n     * - for luma AC, add the base qp and the per-block delta_qp, saturating to\n     *   unsigned 8-bit.\n     * - for luma DC and chroma AC/DC, add the corresponding\n     *   AVVideoBlockParams.delta_qp to the luma AC index, again saturating to\n     *   unsigned 8-bit.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VIDEO_ENC_PARAMS_H264", :type "CXType_Int", :name "AV_VIDEO_ENC_PARAMS_H264", :value 1, :enum "AVVideoEncParamsType", :raw-comment "/**\n     * H.264 stores:\n     * - in PPS (per-picture):\n     *   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp\n     *   * delta(s) for chroma QP values (same for both, or each separately),\n     *     exported as in the corresponding entries in AVVideoEncParams.delta_qp\n     * - per-slice QP delta, not exported directly, added to the per-MB value\n     * - per-MB delta; not exported directly; the final per-MB quantizer\n     *   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported\n     *   as AVVideoBlockParams.qp_delta.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_VIDEO_ENC_PARAMS_MPEG2", :type "CXType_Int", :name "AV_VIDEO_ENC_PARAMS_MPEG2", :value 2, :enum "AVVideoEncParamsType", :raw-comment "/**\n     * H.264 stores:\n     * - in PPS (per-picture):\n     *   * initial QP_Y (luma) value, exported as AVVideoEncParams.qp\n     *   * delta(s) for chroma QP values (same for both, or each separately),\n     *     exported as in the corresponding entries in AVVideoEncParams.delta_qp\n     * - per-slice QP delta, not exported directly, added to the per-MB value\n     * - per-MB delta; not exported directly; the final per-MB quantizer\n     *   parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported\n     *   as AVVideoBlockParams.qp_delta.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ESCAPE_MODE_AUTO", :type "CXType_Int", :name "AV_ESCAPE_MODE_AUTO", :value 0, :enum "AVEscapeMode", :raw-comment "///< Use auto-selected escaping mode."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ESCAPE_MODE_BACKSLASH", :type "CXType_Int", :name "AV_ESCAPE_MODE_BACKSLASH", :value 1, :enum "AVEscapeMode", :raw-comment "///< Use backslash escaping."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ESCAPE_MODE_QUOTE", :type "CXType_Int", :name "AV_ESCAPE_MODE_QUOTE", :value 2, :enum "AVEscapeMode", :raw-comment "///< Use single-quote escaping."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_ESCAPE_MODE_XML", :type "CXType_Int", :name "AV_ESCAPE_MODE_XML", :value 3, :enum "AVEscapeMode", :raw-comment "///< Use XML non-markup character data escaping."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING", :type "CXType_Int", :name "AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING", :value 0, :enum "AVHDRPlusOverlapProcessOption", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING", :type "CXType_Int", :name "AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING", :value 1, :enum "AVHDRPlusOverlapProcessOption", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DOWNMIX_TYPE_UNKNOWN", :type "CXType_Int", :name "AV_DOWNMIX_TYPE_UNKNOWN", :value 0, :enum "AVDownmixType", :raw-comment "/**< Not indicated. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DOWNMIX_TYPE_LORO", :type "CXType_Int", :name "AV_DOWNMIX_TYPE_LORO", :value 1, :enum "AVDownmixType", :raw-comment "/**< Lo/Ro 2-channel downmix (Stereo). */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DOWNMIX_TYPE_LTRT", :type "CXType_Int", :name "AV_DOWNMIX_TYPE_LTRT", :value 2, :enum "AVDownmixType", :raw-comment "/**< Lt/Rt 2-channel downmix, Dolby Surround compatible. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DOWNMIX_TYPE_DPLII", :type "CXType_Int", :name "AV_DOWNMIX_TYPE_DPLII", :value 3, :enum "AVDownmixType", :raw-comment "/**< Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DOWNMIX_TYPE_NB", :type "CXType_Int", :name "AV_DOWNMIX_TYPE_NB", :value 4, :enum "AVDownmixType", :raw-comment "/**< Number of downmix types. Not part of ABI. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FILM_GRAIN_PARAMS_NONE", :type "CXType_Int", :name "AV_FILM_GRAIN_PARAMS_NONE", :value 0, :enum "AVFilmGrainParamsType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FILM_GRAIN_PARAMS_AV1", :type "CXType_Int", :name "AV_FILM_GRAIN_PARAMS_AV1", :value 1, :enum "AVFilmGrainParamsType", :raw-comment "/**\n     * The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MIX_COEFF_TYPE_Q8", :type "CXType_Int", :name "AV_MIX_COEFF_TYPE_Q8", :value 0, :enum "AVMixCoeffType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MIX_COEFF_TYPE_Q15", :type "CXType_Int", :name "AV_MIX_COEFF_TYPE_Q15", :value 1, :enum "AVMixCoeffType", :raw-comment "/** 16-bit 8.8 fixed-point                      */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MIX_COEFF_TYPE_FLT", :type "CXType_Int", :name "AV_MIX_COEFF_TYPE_FLT", :value 2, :enum "AVMixCoeffType", :raw-comment "/** 32-bit 17.15 fixed-point                    */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_MIX_COEFF_TYPE_NB", :type "CXType_Int", :name "AV_MIX_COEFF_TYPE_NB", :value 3, :enum "AVMixCoeffType", :raw-comment "/** floating-point                              */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_FILTER_TYPE_CUBIC", :type "CXType_Int", :name "AV_RESAMPLE_FILTER_TYPE_CUBIC", :value 0, :enum "AVResampleFilterType", :raw-comment "/**< Cubic */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL", :type "CXType_Int", :name "AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL", :value 1, :enum "AVResampleFilterType", :raw-comment "/**< Blackman Nuttall Windowed Sinc */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_FILTER_TYPE_KAISER", :type "CXType_Int", :name "AV_RESAMPLE_FILTER_TYPE_KAISER", :value 2, :enum "AVResampleFilterType", :raw-comment "/**< Kaiser Windowed Sinc */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_NONE", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_NONE", :value 0, :enum "AVResampleDitherMethod", :raw-comment "/**< Do not use dithering */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_RECTANGULAR", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_RECTANGULAR", :value 1, :enum "AVResampleDitherMethod", :raw-comment "/**< Rectangular Dither */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_TRIANGULAR", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_TRIANGULAR", :value 2, :enum "AVResampleDitherMethod", :raw-comment "/**< Triangular Dither*/"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_TRIANGULAR_HP", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_TRIANGULAR_HP", :value 3, :enum "AVResampleDitherMethod", :raw-comment "/**< Triangular Dither with High Pass */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_TRIANGULAR_NS", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_TRIANGULAR_NS", :value 4, :enum "AVResampleDitherMethod", :raw-comment "/**< Triangular Dither with Noise Shaping */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_RESAMPLE_DITHER_NB", :type "CXType_Int", :name "AV_RESAMPLE_DITHER_NB", :value 5, :enum "AVResampleDitherMethod", :raw-comment "/**< Number of dither types. Not part of ABI. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_UNINIT", :type "CXType_Int", :name "AVLINK_UNINIT", :value 0, :enum "", :raw-comment "///< not started"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_STARTINIT", :type "CXType_Int", :name "AVLINK_STARTINIT", :value 1, :enum "", :raw-comment "///< started, but incomplete"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_INIT", :type "CXType_Int", :name "AVLINK_INIT", :value 2, :enum "", :raw-comment "///< complete"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_UNINIT", :type "CXType_Int", :name "AVLINK_UNINIT", :value 0, :enum "", :raw-comment "///< not started"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_STARTINIT", :type "CXType_Int", :name "AVLINK_STARTINIT", :value 1, :enum "", :raw-comment "///< started, but incomplete"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVLINK_INIT", :type "CXType_Int", :name "AVLINK_INIT", :value 2, :enum "", :raw-comment "///< complete"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFILTER_AUTO_CONVERT_ALL", :type "CXType_Int", :name "AVFILTER_AUTO_CONVERT_ALL", :value 0, :enum "", :raw-comment "/**< all automatic conversions enabled */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFILTER_AUTO_CONVERT_NONE", :type "CXType_Int", :name "AVFILTER_AUTO_CONVERT_NONE", :value -1, :enum "", :raw-comment "/**< all automatic conversions disabled */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT", :type "CXType_Int", :name "AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT", :value 1, :enum "", :raw-comment "/**\n     * Do not check for format changes.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_BUFFERSRC_FLAG_PUSH", :type "CXType_Int", :name "AV_BUFFERSRC_FLAG_PUSH", :value 4, :enum "", :raw-comment "/**\n     * Immediately push the frame to the output.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_BUFFERSRC_FLAG_KEEP_REF", :type "CXType_Int", :name "AV_BUFFERSRC_FLAG_KEEP_REF", :value 8, :enum "", :raw-comment "/**\n     * Keep a reference to the frame.\n     * If the frame if reference-counted, create a new reference; otherwise\n     * copy the frame data.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_UNKNOWN", :type "CXType_Int", :name "AVIO_ENTRY_UNKNOWN", :value 0, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_BLOCK_DEVICE", :type "CXType_Int", :name "AVIO_ENTRY_BLOCK_DEVICE", :value 1, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_CHARACTER_DEVICE", :type "CXType_Int", :name "AVIO_ENTRY_CHARACTER_DEVICE", :value 2, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_DIRECTORY", :type "CXType_Int", :name "AVIO_ENTRY_DIRECTORY", :value 3, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_NAMED_PIPE", :type "CXType_Int", :name "AVIO_ENTRY_NAMED_PIPE", :value 4, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_SYMBOLIC_LINK", :type "CXType_Int", :name "AVIO_ENTRY_SYMBOLIC_LINK", :value 5, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_SOCKET", :type "CXType_Int", :name "AVIO_ENTRY_SOCKET", :value 6, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_FILE", :type "CXType_Int", :name "AVIO_ENTRY_FILE", :value 7, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_SERVER", :type "CXType_Int", :name "AVIO_ENTRY_SERVER", :value 8, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_SHARE", :type "CXType_Int", :name "AVIO_ENTRY_SHARE", :value 9, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_ENTRY_WORKGROUP", :type "CXType_Int", :name "AVIO_ENTRY_WORKGROUP", :value 10, :enum "AVIODirEntryType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_HEADER", :type "CXType_Int", :name "AVIO_DATA_MARKER_HEADER", :value 0, :enum "AVIODataMarkerType", :raw-comment "/**\n     * Header data; this needs to be present for the stream to be decodeable.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_SYNC_POINT", :type "CXType_Int", :name "AVIO_DATA_MARKER_SYNC_POINT", :value 1, :enum "AVIODataMarkerType", :raw-comment "/**\n     * A point in the output bytestream where a decoder can start decoding\n     * (i.e. a keyframe). A demuxer/decoder given the data flagged with\n     * AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,\n     * should give decodeable results.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_BOUNDARY_POINT", :type "CXType_Int", :name "AVIO_DATA_MARKER_BOUNDARY_POINT", :value 2, :enum "AVIODataMarkerType", :raw-comment "/**\n     * A point in the output bytestream where a demuxer can start parsing\n     * (for non self synchronizing bytestream formats). That is, any\n     * non-keyframe packet start point.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_UNKNOWN", :type "CXType_Int", :name "AVIO_DATA_MARKER_UNKNOWN", :value 3, :enum "AVIODataMarkerType", :raw-comment "/**\n     * This is any, unlabelled data. It can either be a muxer not marking\n     * any positions at all, it can be an actual boundary/sync point\n     * that the muxer chooses not to mark, or a later part of a packet/fragment\n     * that is cut into multiple write callbacks due to limited IO buffer size.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_TRAILER", :type "CXType_Int", :name "AVIO_DATA_MARKER_TRAILER", :value 4, :enum "AVIODataMarkerType", :raw-comment "/**\n     * Trailer data, which doesn't contain actual content, but only for\n     * finalizing the output file.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVIO_DATA_MARKER_FLUSH_POINT", :type "CXType_Int", :name "AVIO_DATA_MARKER_FLUSH_POINT", :value 5, :enum "AVIODataMarkerType", :raw-comment "/**\n     * A point in the output bytestream where the underlying AVIOContext might\n     * flush the buffer depending on latency or buffering requirements. Typically\n     * means the end of a packet.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_NONE", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_NONE", :value 0, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_VDPAU", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_VDPAU", :value 1, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_CUDA", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_CUDA", :value 2, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_VAAPI", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_VAAPI", :value 3, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_DXVA2", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_DXVA2", :value 4, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_QSV", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_QSV", :value 5, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_VIDEOTOOLBOX", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_VIDEOTOOLBOX", :value 6, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_D3D11VA", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_D3D11VA", :value 7, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_DRM", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_DRM", :value 8, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_OPENCL", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_OPENCL", :value 9, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_MEDIACODEC", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_MEDIACODEC", :value 10, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWDEVICE_TYPE_VULKAN", :type "CXType_Int", :name "AV_HWDEVICE_TYPE_VULKAN", :value 11, :enum "AVHWDeviceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_TRANSFER_DIRECTION_FROM", :type "CXType_Int", :name "AV_HWFRAME_TRANSFER_DIRECTION_FROM", :value 0, :enum "AVHWFrameTransferDirection", :raw-comment "/**\n     * Transfer the data from the queried hw frame.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_TRANSFER_DIRECTION_TO", :type "CXType_Int", :name "AV_HWFRAME_TRANSFER_DIRECTION_TO", :value 1, :enum "AVHWFrameTransferDirection", :raw-comment "/**\n     * Transfer the data to the queried hw frame.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_MAP_READ", :type "CXType_Int", :name "AV_HWFRAME_MAP_READ", :value 1, :enum "", :raw-comment "/**\n     * The mapping must be readable.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_MAP_WRITE", :type "CXType_Int", :name "AV_HWFRAME_MAP_WRITE", :value 2, :enum "", :raw-comment "/**\n     * The mapping must be writeable.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_MAP_OVERWRITE", :type "CXType_Int", :name "AV_HWFRAME_MAP_OVERWRITE", :value 4, :enum "", :raw-comment "/**\n     * The mapped frame will be overwritten completely in subsequent\n     * operations, so the current frame data need not be loaded.  Any values\n     * which are not overwritten are unspecified.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_HWFRAME_MAP_DIRECT", :type "CXType_Int", :name "AV_HWFRAME_MAP_DIRECT", :value 8, :enum "", :raw-comment "/**\n     * The mapping must be direct.  That is, there must not be any copying in\n     * the map or unmap steps.  Note that performance of direct mappings may\n     * be much lower than normal memory.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_NONE", :type "CXType_Int", :name "AV_CODEC_ID_NONE", :value 0, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEG1VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_MPEG1VIDEO", :value 1, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEG2VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_MPEG2VIDEO", :value 2, :enum "AVCodecID", :raw-comment "///< preferred ID for MPEG-1/2 video decoding"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_H261", :type "CXType_Int", :name "AV_CODEC_ID_H261", :value 3, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_H263", :type "CXType_Int", :name "AV_CODEC_ID_H263", :value 4, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RV10", :type "CXType_Int", :name "AV_CODEC_ID_RV10", :value 5, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RV20", :type "CXType_Int", :name "AV_CODEC_ID_RV20", :value 6, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MJPEG", :type "CXType_Int", :name "AV_CODEC_ID_MJPEG", :value 7, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MJPEGB", :type "CXType_Int", :name "AV_CODEC_ID_MJPEGB", :value 8, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_LJPEG", :type "CXType_Int", :name "AV_CODEC_ID_LJPEG", :value 9, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SP5X", :type "CXType_Int", :name "AV_CODEC_ID_SP5X", :value 10, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_JPEGLS", :type "CXType_Int", :name "AV_CODEC_ID_JPEGLS", :value 11, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEG4", :type "CXType_Int", :name "AV_CODEC_ID_MPEG4", :value 12, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RAWVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_RAWVIDEO", :value 13, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSMPEG4V1", :type "CXType_Int", :name "AV_CODEC_ID_MSMPEG4V1", :value 14, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSMPEG4V2", :type "CXType_Int", :name "AV_CODEC_ID_MSMPEG4V2", :value 15, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSMPEG4V3", :type "CXType_Int", :name "AV_CODEC_ID_MSMPEG4V3", :value 16, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMV1", :type "CXType_Int", :name "AV_CODEC_ID_WMV1", :value 17, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMV2", :type "CXType_Int", :name "AV_CODEC_ID_WMV2", :value 18, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_H263P", :type "CXType_Int", :name "AV_CODEC_ID_H263P", :value 19, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_H263I", :type "CXType_Int", :name "AV_CODEC_ID_H263I", :value 20, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FLV1", :type "CXType_Int", :name "AV_CODEC_ID_FLV1", :value 21, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SVQ1", :type "CXType_Int", :name "AV_CODEC_ID_SVQ1", :value 22, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SVQ3", :type "CXType_Int", :name "AV_CODEC_ID_SVQ3", :value 23, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_DVVIDEO", :value 24, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HUFFYUV", :type "CXType_Int", :name "AV_CODEC_ID_HUFFYUV", :value 25, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CYUV", :type "CXType_Int", :name "AV_CODEC_ID_CYUV", :value 26, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_H264", :type "CXType_Int", :name "AV_CODEC_ID_H264", :value 27, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INDEO3", :type "CXType_Int", :name "AV_CODEC_ID_INDEO3", :value 28, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP3", :type "CXType_Int", :name "AV_CODEC_ID_VP3", :value 29, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_THEORA", :type "CXType_Int", :name "AV_CODEC_ID_THEORA", :value 30, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ASV1", :type "CXType_Int", :name "AV_CODEC_ID_ASV1", :value 31, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ASV2", :type "CXType_Int", :name "AV_CODEC_ID_ASV2", :value 32, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FFV1", :type "CXType_Int", :name "AV_CODEC_ID_FFV1", :value 33, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_4XM", :type "CXType_Int", :name "AV_CODEC_ID_4XM", :value 34, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VCR1", :type "CXType_Int", :name "AV_CODEC_ID_VCR1", :value 35, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CLJR", :type "CXType_Int", :name "AV_CODEC_ID_CLJR", :value 36, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MDEC", :type "CXType_Int", :name "AV_CODEC_ID_MDEC", :value 37, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ROQ", :type "CXType_Int", :name "AV_CODEC_ID_ROQ", :value 38, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INTERPLAY_VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_INTERPLAY_VIDEO", :value 39, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XAN_WC3", :type "CXType_Int", :name "AV_CODEC_ID_XAN_WC3", :value 40, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XAN_WC4", :type "CXType_Int", :name "AV_CODEC_ID_XAN_WC4", :value 41, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RPZA", :type "CXType_Int", :name "AV_CODEC_ID_RPZA", :value 42, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CINEPAK", :type "CXType_Int", :name "AV_CODEC_ID_CINEPAK", :value 43, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WS_VQA", :type "CXType_Int", :name "AV_CODEC_ID_WS_VQA", :value 44, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSRLE", :type "CXType_Int", :name "AV_CODEC_ID_MSRLE", :value 45, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSVIDEO1", :type "CXType_Int", :name "AV_CODEC_ID_MSVIDEO1", :value 46, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IDCIN", :type "CXType_Int", :name "AV_CODEC_ID_IDCIN", :value 47, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_8BPS", :type "CXType_Int", :name "AV_CODEC_ID_8BPS", :value 48, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMC", :type "CXType_Int", :name "AV_CODEC_ID_SMC", :value 49, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FLIC", :type "CXType_Int", :name "AV_CODEC_ID_FLIC", :value 50, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TRUEMOTION1", :type "CXType_Int", :name "AV_CODEC_ID_TRUEMOTION1", :value 51, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VMDVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_VMDVIDEO", :value 52, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSZH", :type "CXType_Int", :name "AV_CODEC_ID_MSZH", :value 53, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ZLIB", :type "CXType_Int", :name "AV_CODEC_ID_ZLIB", :value 54, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QTRLE", :type "CXType_Int", :name "AV_CODEC_ID_QTRLE", :value 55, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TSCC", :type "CXType_Int", :name "AV_CODEC_ID_TSCC", :value 56, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ULTI", :type "CXType_Int", :name "AV_CODEC_ID_ULTI", :value 57, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QDRAW", :type "CXType_Int", :name "AV_CODEC_ID_QDRAW", :value 58, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VIXL", :type "CXType_Int", :name "AV_CODEC_ID_VIXL", :value 59, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QPEG", :type "CXType_Int", :name "AV_CODEC_ID_QPEG", :value 60, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PNG", :type "CXType_Int", :name "AV_CODEC_ID_PNG", :value 61, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PPM", :type "CXType_Int", :name "AV_CODEC_ID_PPM", :value 62, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PBM", :type "CXType_Int", :name "AV_CODEC_ID_PBM", :value 63, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PGM", :type "CXType_Int", :name "AV_CODEC_ID_PGM", :value 64, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PGMYUV", :type "CXType_Int", :name "AV_CODEC_ID_PGMYUV", :value 65, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PAM", :type "CXType_Int", :name "AV_CODEC_ID_PAM", :value 66, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FFVHUFF", :type "CXType_Int", :name "AV_CODEC_ID_FFVHUFF", :value 67, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RV30", :type "CXType_Int", :name "AV_CODEC_ID_RV30", :value 68, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RV40", :type "CXType_Int", :name "AV_CODEC_ID_RV40", :value 69, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VC1", :type "CXType_Int", :name "AV_CODEC_ID_VC1", :value 70, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMV3", :type "CXType_Int", :name "AV_CODEC_ID_WMV3", :value 71, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_LOCO", :type "CXType_Int", :name "AV_CODEC_ID_LOCO", :value 72, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WNV1", :type "CXType_Int", :name "AV_CODEC_ID_WNV1", :value 73, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AASC", :type "CXType_Int", :name "AV_CODEC_ID_AASC", :value 74, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INDEO2", :type "CXType_Int", :name "AV_CODEC_ID_INDEO2", :value 75, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FRAPS", :type "CXType_Int", :name "AV_CODEC_ID_FRAPS", :value 76, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TRUEMOTION2", :type "CXType_Int", :name "AV_CODEC_ID_TRUEMOTION2", :value 77, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BMP", :type "CXType_Int", :name "AV_CODEC_ID_BMP", :value 78, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CSCD", :type "CXType_Int", :name "AV_CODEC_ID_CSCD", :value 79, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MMVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_MMVIDEO", :value 80, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ZMBV", :type "CXType_Int", :name "AV_CODEC_ID_ZMBV", :value 81, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVS", :type "CXType_Int", :name "AV_CODEC_ID_AVS", :value 82, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMACKVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_SMACKVIDEO", :value 83, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_NUV", :type "CXType_Int", :name "AV_CODEC_ID_NUV", :value 84, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_KMVC", :type "CXType_Int", :name "AV_CODEC_ID_KMVC", :value 85, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FLASHSV", :type "CXType_Int", :name "AV_CODEC_ID_FLASHSV", :value 86, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CAVS", :type "CXType_Int", :name "AV_CODEC_ID_CAVS", :value 87, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_JPEG2000", :type "CXType_Int", :name "AV_CODEC_ID_JPEG2000", :value 88, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VMNC", :type "CXType_Int", :name "AV_CODEC_ID_VMNC", :value 89, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP5", :type "CXType_Int", :name "AV_CODEC_ID_VP5", :value 90, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP6", :type "CXType_Int", :name "AV_CODEC_ID_VP6", :value 91, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP6F", :type "CXType_Int", :name "AV_CODEC_ID_VP6F", :value 92, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TARGA", :type "CXType_Int", :name "AV_CODEC_ID_TARGA", :value 93, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSICINVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_DSICINVIDEO", :value 94, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TIERTEXSEQVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_TIERTEXSEQVIDEO", :value 95, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TIFF", :type "CXType_Int", :name "AV_CODEC_ID_TIFF", :value 96, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_GIF", :type "CXType_Int", :name "AV_CODEC_ID_GIF", :value 97, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DXA", :type "CXType_Int", :name "AV_CODEC_ID_DXA", :value 98, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DNXHD", :type "CXType_Int", :name "AV_CODEC_ID_DNXHD", :value 99, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_THP", :type "CXType_Int", :name "AV_CODEC_ID_THP", :value 100, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SGI", :type "CXType_Int", :name "AV_CODEC_ID_SGI", :value 101, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_C93", :type "CXType_Int", :name "AV_CODEC_ID_C93", :value 102, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BETHSOFTVID", :type "CXType_Int", :name "AV_CODEC_ID_BETHSOFTVID", :value 103, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PTX", :type "CXType_Int", :name "AV_CODEC_ID_PTX", :value 104, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TXD", :type "CXType_Int", :name "AV_CODEC_ID_TXD", :value 105, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP6A", :type "CXType_Int", :name "AV_CODEC_ID_VP6A", :value 106, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AMV", :type "CXType_Int", :name "AV_CODEC_ID_AMV", :value 107, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VB", :type "CXType_Int", :name "AV_CODEC_ID_VB", :value 108, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCX", :type "CXType_Int", :name "AV_CODEC_ID_PCX", :value 109, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SUNRAST", :type "CXType_Int", :name "AV_CODEC_ID_SUNRAST", :value 110, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INDEO4", :type "CXType_Int", :name "AV_CODEC_ID_INDEO4", :value 111, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INDEO5", :type "CXType_Int", :name "AV_CODEC_ID_INDEO5", :value 112, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MIMIC", :type "CXType_Int", :name "AV_CODEC_ID_MIMIC", :value 113, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RL2", :type "CXType_Int", :name "AV_CODEC_ID_RL2", :value 114, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ESCAPE124", :type "CXType_Int", :name "AV_CODEC_ID_ESCAPE124", :value 115, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DIRAC", :type "CXType_Int", :name "AV_CODEC_ID_DIRAC", :value 116, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BFI", :type "CXType_Int", :name "AV_CODEC_ID_BFI", :value 117, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CMV", :type "CXType_Int", :name "AV_CODEC_ID_CMV", :value 118, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MOTIONPIXELS", :type "CXType_Int", :name "AV_CODEC_ID_MOTIONPIXELS", :value 119, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TGV", :type "CXType_Int", :name "AV_CODEC_ID_TGV", :value 120, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TGQ", :type "CXType_Int", :name "AV_CODEC_ID_TGQ", :value 121, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TQI", :type "CXType_Int", :name "AV_CODEC_ID_TQI", :value 122, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AURA", :type "CXType_Int", :name "AV_CODEC_ID_AURA", :value 123, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AURA2", :type "CXType_Int", :name "AV_CODEC_ID_AURA2", :value 124, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_V210X", :type "CXType_Int", :name "AV_CODEC_ID_V210X", :value 125, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TMV", :type "CXType_Int", :name "AV_CODEC_ID_TMV", :value 126, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_V210", :type "CXType_Int", :name "AV_CODEC_ID_V210", :value 127, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DPX", :type "CXType_Int", :name "AV_CODEC_ID_DPX", :value 128, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MAD", :type "CXType_Int", :name "AV_CODEC_ID_MAD", :value 129, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FRWU", :type "CXType_Int", :name "AV_CODEC_ID_FRWU", :value 130, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FLASHSV2", :type "CXType_Int", :name "AV_CODEC_ID_FLASHSV2", :value 131, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CDGRAPHICS", :type "CXType_Int", :name "AV_CODEC_ID_CDGRAPHICS", :value 132, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_R210", :type "CXType_Int", :name "AV_CODEC_ID_R210", :value 133, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ANM", :type "CXType_Int", :name "AV_CODEC_ID_ANM", :value 134, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BINKVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_BINKVIDEO", :value 135, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IFF_ILBM", :type "CXType_Int", :name "AV_CODEC_ID_IFF_ILBM", :value 136, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_KGV1", :type "CXType_Int", :name "AV_CODEC_ID_KGV1", :value 137, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_YOP", :type "CXType_Int", :name "AV_CODEC_ID_YOP", :value 138, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP8", :type "CXType_Int", :name "AV_CODEC_ID_VP8", :value 139, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PICTOR", :type "CXType_Int", :name "AV_CODEC_ID_PICTOR", :value 140, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ANSI", :type "CXType_Int", :name "AV_CODEC_ID_ANSI", :value 141, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_A64_MULTI", :type "CXType_Int", :name "AV_CODEC_ID_A64_MULTI", :value 142, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_A64_MULTI5", :type "CXType_Int", :name "AV_CODEC_ID_A64_MULTI5", :value 143, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_R10K", :type "CXType_Int", :name "AV_CODEC_ID_R10K", :value 144, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MXPEG", :type "CXType_Int", :name "AV_CODEC_ID_MXPEG", :value 145, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_LAGARITH", :type "CXType_Int", :name "AV_CODEC_ID_LAGARITH", :value 146, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PRORES", :type "CXType_Int", :name "AV_CODEC_ID_PRORES", :value 147, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_JV", :type "CXType_Int", :name "AV_CODEC_ID_JV", :value 148, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DFA", :type "CXType_Int", :name "AV_CODEC_ID_DFA", :value 149, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMV3IMAGE", :type "CXType_Int", :name "AV_CODEC_ID_WMV3IMAGE", :value 150, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VC1IMAGE", :type "CXType_Int", :name "AV_CODEC_ID_VC1IMAGE", :value 151, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_UTVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_UTVIDEO", :value 152, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BMV_VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_BMV_VIDEO", :value 153, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VBLE", :type "CXType_Int", :name "AV_CODEC_ID_VBLE", :value 154, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DXTORY", :type "CXType_Int", :name "AV_CODEC_ID_DXTORY", :value 155, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_V410", :type "CXType_Int", :name "AV_CODEC_ID_V410", :value 156, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XWD", :type "CXType_Int", :name "AV_CODEC_ID_XWD", :value 157, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CDXL", :type "CXType_Int", :name "AV_CODEC_ID_CDXL", :value 158, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XBM", :type "CXType_Int", :name "AV_CODEC_ID_XBM", :value 159, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ZEROCODEC", :type "CXType_Int", :name "AV_CODEC_ID_ZEROCODEC", :value 160, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSS1", :type "CXType_Int", :name "AV_CODEC_ID_MSS1", :value 161, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSA1", :type "CXType_Int", :name "AV_CODEC_ID_MSA1", :value 162, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TSCC2", :type "CXType_Int", :name "AV_CODEC_ID_TSCC2", :value 163, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MTS2", :type "CXType_Int", :name "AV_CODEC_ID_MTS2", :value 164, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CLLC", :type "CXType_Int", :name "AV_CODEC_ID_CLLC", :value 165, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSS2", :type "CXType_Int", :name "AV_CODEC_ID_MSS2", :value 166, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP9", :type "CXType_Int", :name "AV_CODEC_ID_VP9", :value 167, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AIC", :type "CXType_Int", :name "AV_CODEC_ID_AIC", :value 168, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ESCAPE130", :type "CXType_Int", :name "AV_CODEC_ID_ESCAPE130", :value 169, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_G2M", :type "CXType_Int", :name "AV_CODEC_ID_G2M", :value 170, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WEBP", :type "CXType_Int", :name "AV_CODEC_ID_WEBP", :value 171, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HNM4_VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_HNM4_VIDEO", :value 172, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HEVC", :type "CXType_Int", :name "AV_CODEC_ID_HEVC", :value 173, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FIC", :type "CXType_Int", :name "AV_CODEC_ID_FIC", :value 174, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ALIAS_PIX", :type "CXType_Int", :name "AV_CODEC_ID_ALIAS_PIX", :value 175, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BRENDER_PIX", :type "CXType_Int", :name "AV_CODEC_ID_BRENDER_PIX", :value 176, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PAF_VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_PAF_VIDEO", :value 177, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_EXR", :type "CXType_Int", :name "AV_CODEC_ID_EXR", :value 178, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP7", :type "CXType_Int", :name "AV_CODEC_ID_VP7", :value 179, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SANM", :type "CXType_Int", :name "AV_CODEC_ID_SANM", :value 180, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SGIRLE", :type "CXType_Int", :name "AV_CODEC_ID_SGIRLE", :value 181, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MVC1", :type "CXType_Int", :name "AV_CODEC_ID_MVC1", :value 182, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MVC2", :type "CXType_Int", :name "AV_CODEC_ID_MVC2", :value 183, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HQX", :type "CXType_Int", :name "AV_CODEC_ID_HQX", :value 184, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TDSC", :type "CXType_Int", :name "AV_CODEC_ID_TDSC", :value 185, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HQ_HQA", :type "CXType_Int", :name "AV_CODEC_ID_HQ_HQA", :value 186, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HAP", :type "CXType_Int", :name "AV_CODEC_ID_HAP", :value 187, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DDS", :type "CXType_Int", :name "AV_CODEC_ID_DDS", :value 188, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DXV", :type "CXType_Int", :name "AV_CODEC_ID_DXV", :value 189, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SCREENPRESSO", :type "CXType_Int", :name "AV_CODEC_ID_SCREENPRESSO", :value 190, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RSCC", :type "CXType_Int", :name "AV_CODEC_ID_RSCC", :value 191, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVS2", :type "CXType_Int", :name "AV_CODEC_ID_AVS2", :value 192, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PGX", :type "CXType_Int", :name "AV_CODEC_ID_PGX", :value 193, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVS3", :type "CXType_Int", :name "AV_CODEC_ID_AVS3", :value 194, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSP2", :type "CXType_Int", :name "AV_CODEC_ID_MSP2", :value 195, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VVC", :type "CXType_Int", :name "AV_CODEC_ID_VVC", :value 196, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_Y41P", :type "CXType_Int", :name "AV_CODEC_ID_Y41P", :value 32768, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVRP", :type "CXType_Int", :name "AV_CODEC_ID_AVRP", :value 32769, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_012V", :type "CXType_Int", :name "AV_CODEC_ID_012V", :value 32770, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVUI", :type "CXType_Int", :name "AV_CODEC_ID_AVUI", :value 32771, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AYUV", :type "CXType_Int", :name "AV_CODEC_ID_AYUV", :value 32772, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TARGA_Y216", :type "CXType_Int", :name "AV_CODEC_ID_TARGA_Y216", :value 32773, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_V308", :type "CXType_Int", :name "AV_CODEC_ID_V308", :value 32774, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_V408", :type "CXType_Int", :name "AV_CODEC_ID_V408", :value 32775, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_YUV4", :type "CXType_Int", :name "AV_CODEC_ID_YUV4", :value 32776, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AVRN", :type "CXType_Int", :name "AV_CODEC_ID_AVRN", :value 32777, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CPIA", :type "CXType_Int", :name "AV_CODEC_ID_CPIA", :value 32778, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XFACE", :type "CXType_Int", :name "AV_CODEC_ID_XFACE", :value 32779, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SNOW", :type "CXType_Int", :name "AV_CODEC_ID_SNOW", :value 32780, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMVJPEG", :type "CXType_Int", :name "AV_CODEC_ID_SMVJPEG", :value 32781, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_APNG", :type "CXType_Int", :name "AV_CODEC_ID_APNG", :value 32782, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DAALA", :type "CXType_Int", :name "AV_CODEC_ID_DAALA", :value 32783, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CFHD", :type "CXType_Int", :name "AV_CODEC_ID_CFHD", :value 32784, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TRUEMOTION2RT", :type "CXType_Int", :name "AV_CODEC_ID_TRUEMOTION2RT", :value 32785, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_M101", :type "CXType_Int", :name "AV_CODEC_ID_M101", :value 32786, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MAGICYUV", :type "CXType_Int", :name "AV_CODEC_ID_MAGICYUV", :value 32787, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SHEERVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_SHEERVIDEO", :value 32788, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_YLC", :type "CXType_Int", :name "AV_CODEC_ID_YLC", :value 32789, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PSD", :type "CXType_Int", :name "AV_CODEC_ID_PSD", :value 32790, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PIXLET", :type "CXType_Int", :name "AV_CODEC_ID_PIXLET", :value 32791, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SPEEDHQ", :type "CXType_Int", :name "AV_CODEC_ID_SPEEDHQ", :value 32792, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FMVC", :type "CXType_Int", :name "AV_CODEC_ID_FMVC", :value 32793, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SCPR", :type "CXType_Int", :name "AV_CODEC_ID_SCPR", :value 32794, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CLEARVIDEO", :type "CXType_Int", :name "AV_CODEC_ID_CLEARVIDEO", :value 32795, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XPM", :type "CXType_Int", :name "AV_CODEC_ID_XPM", :value 32796, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AV1", :type "CXType_Int", :name "AV_CODEC_ID_AV1", :value 32797, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BITPACKED", :type "CXType_Int", :name "AV_CODEC_ID_BITPACKED", :value 32798, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MSCC", :type "CXType_Int", :name "AV_CODEC_ID_MSCC", :value 32799, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SRGC", :type "CXType_Int", :name "AV_CODEC_ID_SRGC", :value 32800, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SVG", :type "CXType_Int", :name "AV_CODEC_ID_SVG", :value 32801, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_GDV", :type "CXType_Int", :name "AV_CODEC_ID_GDV", :value 32802, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FITS", :type "CXType_Int", :name "AV_CODEC_ID_FITS", :value 32803, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IMM4", :type "CXType_Int", :name "AV_CODEC_ID_IMM4", :value 32804, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PROSUMER", :type "CXType_Int", :name "AV_CODEC_ID_PROSUMER", :value 32805, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MWSC", :type "CXType_Int", :name "AV_CODEC_ID_MWSC", :value 32806, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WCMV", :type "CXType_Int", :name "AV_CODEC_ID_WCMV", :value 32807, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RASC", :type "CXType_Int", :name "AV_CODEC_ID_RASC", :value 32808, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HYMT", :type "CXType_Int", :name "AV_CODEC_ID_HYMT", :value 32809, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ARBC", :type "CXType_Int", :name "AV_CODEC_ID_ARBC", :value 32810, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AGM", :type "CXType_Int", :name "AV_CODEC_ID_AGM", :value 32811, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_LSCR", :type "CXType_Int", :name "AV_CODEC_ID_LSCR", :value 32812, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VP4", :type "CXType_Int", :name "AV_CODEC_ID_VP4", :value 32813, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IMM5", :type "CXType_Int", :name "AV_CODEC_ID_IMM5", :value 32814, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MVDV", :type "CXType_Int", :name "AV_CODEC_ID_MVDV", :value 32815, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MVHA", :type "CXType_Int", :name "AV_CODEC_ID_MVHA", :value 32816, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CDTOONS", :type "CXType_Int", :name "AV_CODEC_ID_CDTOONS", :value 32817, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MV30", :type "CXType_Int", :name "AV_CODEC_ID_MV30", :value 32818, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_NOTCHLC", :type "CXType_Int", :name "AV_CODEC_ID_NOTCHLC", :value 32819, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PFM", :type "CXType_Int", :name "AV_CODEC_ID_PFM", :value 32820, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MOBICLIP", :type "CXType_Int", :name "AV_CODEC_ID_MOBICLIP", :value 32821, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PHOTOCD", :type "CXType_Int", :name "AV_CODEC_ID_PHOTOCD", :value 32822, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IPU", :type "CXType_Int", :name "AV_CODEC_ID_IPU", :value 32823, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ARGO", :type "CXType_Int", :name "AV_CODEC_ID_ARGO", :value 32824, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CRI", :type "CXType_Int", :name "AV_CODEC_ID_CRI", :value 32825, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SIMBIOSIS_IMX", :type "CXType_Int", :name "AV_CODEC_ID_SIMBIOSIS_IMX", :value 32826, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SGA_VIDEO", :type "CXType_Int", :name "AV_CODEC_ID_SGA_VIDEO", :value 32827, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FIRST_AUDIO", :type "CXType_Int", :name "AV_CODEC_ID_FIRST_AUDIO", :value 65536, :enum "AVCodecID", :raw-comment "///< A dummy id pointing at the start of audio codecs"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S16LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S16LE", :value 65536, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S16BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S16BE", :value 65537, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U16LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U16LE", :value 65538, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U16BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U16BE", :value 65539, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S8", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S8", :value 65540, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U8", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U8", :value 65541, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_MULAW", :type "CXType_Int", :name "AV_CODEC_ID_PCM_MULAW", :value 65542, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_ALAW", :type "CXType_Int", :name "AV_CODEC_ID_PCM_ALAW", :value 65543, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S32LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S32LE", :value 65544, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S32BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S32BE", :value 65545, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U32LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U32LE", :value 65546, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U32BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U32BE", :value 65547, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S24LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S24LE", :value 65548, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S24BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S24BE", :value 65549, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U24LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U24LE", :value 65550, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_U24BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_U24BE", :value 65551, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S24DAUD", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S24DAUD", :value 65552, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_ZORK", :type "CXType_Int", :name "AV_CODEC_ID_PCM_ZORK", :value 65553, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S16LE_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S16LE_PLANAR", :value 65554, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_DVD", :type "CXType_Int", :name "AV_CODEC_ID_PCM_DVD", :value 65555, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F32BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F32BE", :value 65556, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F32LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F32LE", :value 65557, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F64BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F64BE", :value 65558, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F64LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F64LE", :value 65559, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_BLURAY", :type "CXType_Int", :name "AV_CODEC_ID_PCM_BLURAY", :value 65560, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_LXF", :type "CXType_Int", :name "AV_CODEC_ID_PCM_LXF", :value 65561, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_S302M", :type "CXType_Int", :name "AV_CODEC_ID_S302M", :value 65562, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S8_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S8_PLANAR", :value 65563, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S24LE_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S24LE_PLANAR", :value 65564, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S32LE_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S32LE_PLANAR", :value 65565, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S16BE_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S16BE_PLANAR", :value 65566, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S64LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S64LE", :value 67584, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_S64BE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_S64BE", :value 67585, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F16LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F16LE", :value 67586, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_F24LE", :type "CXType_Int", :name "AV_CODEC_ID_PCM_F24LE", :value 67587, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_VIDC", :type "CXType_Int", :name "AV_CODEC_ID_PCM_VIDC", :value 67588, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PCM_SGA", :type "CXType_Int", :name "AV_CODEC_ID_PCM_SGA", :value 67589, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_QT", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_QT", :value 69632, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_WAV", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_WAV", :value 69633, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_DK3", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_DK3", :value 69634, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_DK4", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_DK4", :value 69635, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_WS", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_WS", :value 69636, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_SMJPEG", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_SMJPEG", :value 69637, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_MS", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_MS", :value 69638, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_4XM", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_4XM", :value 69639, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_XA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_XA", :value 69640, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_ADX", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_ADX", :value 69641, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA", :value 69642, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_G726", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_G726", :value 69643, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_CT", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_CT", :value 69644, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_SWF", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_SWF", :value 69645, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_YAMAHA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_YAMAHA", :value 69646, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_SBPRO_4", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_SBPRO_4", :value 69647, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_SBPRO_3", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_SBPRO_3", :value 69648, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_SBPRO_2", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_SBPRO_2", :value 69649, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_THP", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_THP", :value 69650, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_AMV", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_AMV", :value 69651, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA_R1", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA_R1", :value 69652, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA_R3", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA_R3", :value 69653, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA_R2", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA_R2", :value 69654, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_EA_SEAD", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_EA_SEAD", :value 69655, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_EA_EACS", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_EA_EACS", :value 69656, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA_XAS", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA_XAS", :value 69657, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_EA_MAXIS_XA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_EA_MAXIS_XA", :value 69658, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_ISS", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_ISS", :value 69659, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_G722", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_G722", :value 69660, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_APC", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_APC", :value 69661, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_VIMA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_VIMA", :value 69662, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_AFC", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_AFC", :value 71680, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_OKI", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_OKI", :value 71681, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_DTK", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_DTK", :value 71682, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_RAD", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_RAD", :value 71683, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_G726LE", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_G726LE", :value 71684, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_THP_LE", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_THP_LE", :value 71685, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_PSX", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_PSX", :value 71686, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_AICA", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_AICA", :value 71687, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_DAT4", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_DAT4", :value 71688, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_MTAF", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_MTAF", :value 71689, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_AGM", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_AGM", :value 71690, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_ARGO", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_ARGO", :value 71691, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_SSI", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_SSI", :value 71692, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_ZORK", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_ZORK", :value 71693, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_APM", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_APM", :value 71694, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_ALP", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_ALP", :value 71695, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_MTF", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_MTF", :value 71696, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_CUNNING", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_CUNNING", :value 71697, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ADPCM_IMA_MOFLEX", :type "CXType_Int", :name "AV_CODEC_ID_ADPCM_IMA_MOFLEX", :value 71698, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AMR_NB", :type "CXType_Int", :name "AV_CODEC_ID_AMR_NB", :value 73728, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AMR_WB", :type "CXType_Int", :name "AV_CODEC_ID_AMR_WB", :value 73729, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RA_144", :type "CXType_Int", :name "AV_CODEC_ID_RA_144", :value 77824, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RA_288", :type "CXType_Int", :name "AV_CODEC_ID_RA_288", :value 77825, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ROQ_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_ROQ_DPCM", :value 81920, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INTERPLAY_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_INTERPLAY_DPCM", :value 81921, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XAN_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_XAN_DPCM", :value 81922, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SOL_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_SOL_DPCM", :value 81923, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SDX2_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_SDX2_DPCM", :value 83968, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_GREMLIN_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_GREMLIN_DPCM", :value 83969, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DERF_DPCM", :type "CXType_Int", :name "AV_CODEC_ID_DERF_DPCM", :value 83970, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP2", :type "CXType_Int", :name "AV_CODEC_ID_MP2", :value 86016, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP3", :type "CXType_Int", :name "AV_CODEC_ID_MP3", :value 86017, :enum "AVCodecID", :raw-comment "///< preferred ID for decoding MPEG audio layer 1, 2 or 3"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AAC", :type "CXType_Int", :name "AV_CODEC_ID_AAC", :value 86018, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AC3", :type "CXType_Int", :name "AV_CODEC_ID_AC3", :value 86019, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DTS", :type "CXType_Int", :name "AV_CODEC_ID_DTS", :value 86020, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VORBIS", :type "CXType_Int", :name "AV_CODEC_ID_VORBIS", :value 86021, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVAUDIO", :type "CXType_Int", :name "AV_CODEC_ID_DVAUDIO", :value 86022, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMAV1", :type "CXType_Int", :name "AV_CODEC_ID_WMAV1", :value 86023, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMAV2", :type "CXType_Int", :name "AV_CODEC_ID_WMAV2", :value 86024, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MACE3", :type "CXType_Int", :name "AV_CODEC_ID_MACE3", :value 86025, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MACE6", :type "CXType_Int", :name "AV_CODEC_ID_MACE6", :value 86026, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VMDAUDIO", :type "CXType_Int", :name "AV_CODEC_ID_VMDAUDIO", :value 86027, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FLAC", :type "CXType_Int", :name "AV_CODEC_ID_FLAC", :value 86028, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP3ADU", :type "CXType_Int", :name "AV_CODEC_ID_MP3ADU", :value 86029, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP3ON4", :type "CXType_Int", :name "AV_CODEC_ID_MP3ON4", :value 86030, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SHORTEN", :type "CXType_Int", :name "AV_CODEC_ID_SHORTEN", :value 86031, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ALAC", :type "CXType_Int", :name "AV_CODEC_ID_ALAC", :value 86032, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WESTWOOD_SND1", :type "CXType_Int", :name "AV_CODEC_ID_WESTWOOD_SND1", :value 86033, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_GSM", :type "CXType_Int", :name "AV_CODEC_ID_GSM", :value 86034, :enum "AVCodecID", :raw-comment "///< as in Berlin toast format"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QDM2", :type "CXType_Int", :name "AV_CODEC_ID_QDM2", :value 86035, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_COOK", :type "CXType_Int", :name "AV_CODEC_ID_COOK", :value 86036, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TRUESPEECH", :type "CXType_Int", :name "AV_CODEC_ID_TRUESPEECH", :value 86037, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TTA", :type "CXType_Int", :name "AV_CODEC_ID_TTA", :value 86038, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMACKAUDIO", :type "CXType_Int", :name "AV_CODEC_ID_SMACKAUDIO", :value 86039, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QCELP", :type "CXType_Int", :name "AV_CODEC_ID_QCELP", :value 86040, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WAVPACK", :type "CXType_Int", :name "AV_CODEC_ID_WAVPACK", :value 86041, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSICINAUDIO", :type "CXType_Int", :name "AV_CODEC_ID_DSICINAUDIO", :value 86042, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IMC", :type "CXType_Int", :name "AV_CODEC_ID_IMC", :value 86043, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MUSEPACK7", :type "CXType_Int", :name "AV_CODEC_ID_MUSEPACK7", :value 86044, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MLP", :type "CXType_Int", :name "AV_CODEC_ID_MLP", :value 86045, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_GSM_MS", :type "CXType_Int", :name "AV_CODEC_ID_GSM_MS", :value 86046, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC3", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC3", :value 86047, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_APE", :type "CXType_Int", :name "AV_CODEC_ID_APE", :value 86048, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_NELLYMOSER", :type "CXType_Int", :name "AV_CODEC_ID_NELLYMOSER", :value 86049, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MUSEPACK8", :type "CXType_Int", :name "AV_CODEC_ID_MUSEPACK8", :value 86050, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SPEEX", :type "CXType_Int", :name "AV_CODEC_ID_SPEEX", :value 86051, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMAVOICE", :type "CXType_Int", :name "AV_CODEC_ID_WMAVOICE", :value 86052, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMAPRO", :type "CXType_Int", :name "AV_CODEC_ID_WMAPRO", :value 86053, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WMALOSSLESS", :type "CXType_Int", :name "AV_CODEC_ID_WMALOSSLESS", :value 86054, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC3P", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC3P", :value 86055, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_EAC3", :type "CXType_Int", :name "AV_CODEC_ID_EAC3", :value 86056, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SIPR", :type "CXType_Int", :name "AV_CODEC_ID_SIPR", :value 86057, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP1", :type "CXType_Int", :name "AV_CODEC_ID_MP1", :value 86058, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TWINVQ", :type "CXType_Int", :name "AV_CODEC_ID_TWINVQ", :value 86059, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TRUEHD", :type "CXType_Int", :name "AV_CODEC_ID_TRUEHD", :value 86060, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MP4ALS", :type "CXType_Int", :name "AV_CODEC_ID_MP4ALS", :value 86061, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC1", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC1", :value 86062, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BINKAUDIO_RDFT", :type "CXType_Int", :name "AV_CODEC_ID_BINKAUDIO_RDFT", :value 86063, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BINKAUDIO_DCT", :type "CXType_Int", :name "AV_CODEC_ID_BINKAUDIO_DCT", :value 86064, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_AAC_LATM", :type "CXType_Int", :name "AV_CODEC_ID_AAC_LATM", :value 86065, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_QDMC", :type "CXType_Int", :name "AV_CODEC_ID_QDMC", :value 86066, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CELT", :type "CXType_Int", :name "AV_CODEC_ID_CELT", :value 86067, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_G723_1", :type "CXType_Int", :name "AV_CODEC_ID_G723_1", :value 86068, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_G729", :type "CXType_Int", :name "AV_CODEC_ID_G729", :value 86069, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_8SVX_EXP", :type "CXType_Int", :name "AV_CODEC_ID_8SVX_EXP", :value 86070, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_8SVX_FIB", :type "CXType_Int", :name "AV_CODEC_ID_8SVX_FIB", :value 86071, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BMV_AUDIO", :type "CXType_Int", :name "AV_CODEC_ID_BMV_AUDIO", :value 86072, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_RALF", :type "CXType_Int", :name "AV_CODEC_ID_RALF", :value 86073, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IAC", :type "CXType_Int", :name "AV_CODEC_ID_IAC", :value 86074, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ILBC", :type "CXType_Int", :name "AV_CODEC_ID_ILBC", :value 86075, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_OPUS", :type "CXType_Int", :name "AV_CODEC_ID_OPUS", :value 86076, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_COMFORT_NOISE", :type "CXType_Int", :name "AV_CODEC_ID_COMFORT_NOISE", :value 86077, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TAK", :type "CXType_Int", :name "AV_CODEC_ID_TAK", :value 86078, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_METASOUND", :type "CXType_Int", :name "AV_CODEC_ID_METASOUND", :value 86079, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PAF_AUDIO", :type "CXType_Int", :name "AV_CODEC_ID_PAF_AUDIO", :value 86080, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ON2AVC", :type "CXType_Int", :name "AV_CODEC_ID_ON2AVC", :value 86081, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSS_SP", :type "CXType_Int", :name "AV_CODEC_ID_DSS_SP", :value 86082, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_CODEC2", :type "CXType_Int", :name "AV_CODEC_ID_CODEC2", :value 86083, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FFWAVESYNTH", :type "CXType_Int", :name "AV_CODEC_ID_FFWAVESYNTH", :value 88064, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SONIC", :type "CXType_Int", :name "AV_CODEC_ID_SONIC", :value 88065, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SONIC_LS", :type "CXType_Int", :name "AV_CODEC_ID_SONIC_LS", :value 88066, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_EVRC", :type "CXType_Int", :name "AV_CODEC_ID_EVRC", :value 88067, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMV", :type "CXType_Int", :name "AV_CODEC_ID_SMV", :value 88068, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSD_LSBF", :type "CXType_Int", :name "AV_CODEC_ID_DSD_LSBF", :value 88069, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSD_MSBF", :type "CXType_Int", :name "AV_CODEC_ID_DSD_MSBF", :value 88070, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSD_LSBF_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_DSD_LSBF_PLANAR", :value 88071, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DSD_MSBF_PLANAR", :type "CXType_Int", :name "AV_CODEC_ID_DSD_MSBF_PLANAR", :value 88072, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_4GV", :type "CXType_Int", :name "AV_CODEC_ID_4GV", :value 88073, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_INTERPLAY_ACM", :type "CXType_Int", :name "AV_CODEC_ID_INTERPLAY_ACM", :value 88074, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XMA1", :type "CXType_Int", :name "AV_CODEC_ID_XMA1", :value 88075, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XMA2", :type "CXType_Int", :name "AV_CODEC_ID_XMA2", :value 88076, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DST", :type "CXType_Int", :name "AV_CODEC_ID_DST", :value 88077, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC3AL", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC3AL", :value 88078, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC3PAL", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC3PAL", :value 88079, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DOLBY_E", :type "CXType_Int", :name "AV_CODEC_ID_DOLBY_E", :value 88080, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_APTX", :type "CXType_Int", :name "AV_CODEC_ID_APTX", :value 88081, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_APTX_HD", :type "CXType_Int", :name "AV_CODEC_ID_APTX_HD", :value 88082, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SBC", :type "CXType_Int", :name "AV_CODEC_ID_SBC", :value 88083, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ATRAC9", :type "CXType_Int", :name "AV_CODEC_ID_ATRAC9", :value 88084, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HCOM", :type "CXType_Int", :name "AV_CODEC_ID_HCOM", :value 88085, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ACELP_KELVIN", :type "CXType_Int", :name "AV_CODEC_ID_ACELP_KELVIN", :value 88086, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEGH_3D_AUDIO", :type "CXType_Int", :name "AV_CODEC_ID_MPEGH_3D_AUDIO", :value 88087, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SIREN", :type "CXType_Int", :name "AV_CODEC_ID_SIREN", :value 88088, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HCA", :type "CXType_Int", :name "AV_CODEC_ID_HCA", :value 88089, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FASTAUDIO", :type "CXType_Int", :name "AV_CODEC_ID_FASTAUDIO", :value 88090, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FIRST_SUBTITLE", :type "CXType_Int", :name "AV_CODEC_ID_FIRST_SUBTITLE", :value 94208, :enum "AVCodecID", :raw-comment "///< A dummy ID pointing at the start of subtitle codecs."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVD_SUBTITLE", :type "CXType_Int", :name "AV_CODEC_ID_DVD_SUBTITLE", :value 94208, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVB_SUBTITLE", :type "CXType_Int", :name "AV_CODEC_ID_DVB_SUBTITLE", :value 94209, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TEXT", :type "CXType_Int", :name "AV_CODEC_ID_TEXT", :value 94210, :enum "AVCodecID", :raw-comment "///< raw UTF-8 text"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XSUB", :type "CXType_Int", :name "AV_CODEC_ID_XSUB", :value 94211, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SSA", :type "CXType_Int", :name "AV_CODEC_ID_SSA", :value 94212, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MOV_TEXT", :type "CXType_Int", :name "AV_CODEC_ID_MOV_TEXT", :value 94213, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HDMV_PGS_SUBTITLE", :type "CXType_Int", :name "AV_CODEC_ID_HDMV_PGS_SUBTITLE", :value 94214, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVB_TELETEXT", :type "CXType_Int", :name "AV_CODEC_ID_DVB_TELETEXT", :value 94215, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SRT", :type "CXType_Int", :name "AV_CODEC_ID_SRT", :value 94216, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MICRODVD", :type "CXType_Int", :name "AV_CODEC_ID_MICRODVD", :value 96256, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_EIA_608", :type "CXType_Int", :name "AV_CODEC_ID_EIA_608", :value 96257, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_JACOSUB", :type "CXType_Int", :name "AV_CODEC_ID_JACOSUB", :value 96258, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SAMI", :type "CXType_Int", :name "AV_CODEC_ID_SAMI", :value 96259, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_REALTEXT", :type "CXType_Int", :name "AV_CODEC_ID_REALTEXT", :value 96260, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_STL", :type "CXType_Int", :name "AV_CODEC_ID_STL", :value 96261, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SUBVIEWER1", :type "CXType_Int", :name "AV_CODEC_ID_SUBVIEWER1", :value 96262, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SUBVIEWER", :type "CXType_Int", :name "AV_CODEC_ID_SUBVIEWER", :value 96263, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SUBRIP", :type "CXType_Int", :name "AV_CODEC_ID_SUBRIP", :value 96264, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WEBVTT", :type "CXType_Int", :name "AV_CODEC_ID_WEBVTT", :value 96265, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPL2", :type "CXType_Int", :name "AV_CODEC_ID_MPL2", :value 96266, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_VPLAYER", :type "CXType_Int", :name "AV_CODEC_ID_VPLAYER", :value 96267, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PJS", :type "CXType_Int", :name "AV_CODEC_ID_PJS", :value 96268, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ASS", :type "CXType_Int", :name "AV_CODEC_ID_ASS", :value 96269, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_HDMV_TEXT_SUBTITLE", :type "CXType_Int", :name "AV_CODEC_ID_HDMV_TEXT_SUBTITLE", :value 96270, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TTML", :type "CXType_Int", :name "AV_CODEC_ID_TTML", :value 96271, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_ARIB_CAPTION", :type "CXType_Int", :name "AV_CODEC_ID_ARIB_CAPTION", :value 96272, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FIRST_UNKNOWN", :type "CXType_Int", :name "AV_CODEC_ID_FIRST_UNKNOWN", :value 98304, :enum "AVCodecID", :raw-comment "///< A dummy ID pointing at the start of various fake codecs."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TTF", :type "CXType_Int", :name "AV_CODEC_ID_TTF", :value 98304, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SCTE_35", :type "CXType_Int", :name "AV_CODEC_ID_SCTE_35", :value 98305, :enum "AVCodecID", :raw-comment "///< Contain timestamp estimated through PCR of program stream."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_EPG", :type "CXType_Int", :name "AV_CODEC_ID_EPG", :value 98306, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BINTEXT", :type "CXType_Int", :name "AV_CODEC_ID_BINTEXT", :value 100352, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_XBIN", :type "CXType_Int", :name "AV_CODEC_ID_XBIN", :value 100353, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_IDF", :type "CXType_Int", :name "AV_CODEC_ID_IDF", :value 100354, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_OTF", :type "CXType_Int", :name "AV_CODEC_ID_OTF", :value 100355, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_SMPTE_KLV", :type "CXType_Int", :name "AV_CODEC_ID_SMPTE_KLV", :value 100356, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_DVD_NAV", :type "CXType_Int", :name "AV_CODEC_ID_DVD_NAV", :value 100357, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_TIMED_ID3", :type "CXType_Int", :name "AV_CODEC_ID_TIMED_ID3", :value 100358, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_BIN_DATA", :type "CXType_Int", :name "AV_CODEC_ID_BIN_DATA", :value 100359, :enum "AVCodecID", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_PROBE", :type "CXType_Int", :name "AV_CODEC_ID_PROBE", :value 102400, :enum "AVCodecID", :raw-comment "///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEG2TS", :type "CXType_Int", :name "AV_CODEC_ID_MPEG2TS", :value 131072, :enum "AVCodecID", :raw-comment "/**< _FAKE_ codec to indicate a raw MPEG-2 TS\n                                * stream (only used by libavformat) */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_MPEG4SYSTEMS", :type "CXType_Int", :name "AV_CODEC_ID_MPEG4SYSTEMS", :value 131073, :enum "AVCodecID", :raw-comment "/**< _FAKE_ codec to indicate a MPEG-4 Systems\n                                * stream (only used by libavformat) */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_FFMETADATA", :type "CXType_Int", :name "AV_CODEC_ID_FFMETADATA", :value 135168, :enum "AVCodecID", :raw-comment "///< Dummy codec for streams containing only metadata information."} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_ID_WRAPPED_AVFRAME", :type "CXType_Int", :name "AV_CODEC_ID_WRAPPED_AVFRAME", :value 135169, :enum "AVCodecID", :raw-comment "///< Passthrough codec, AVFrames wrapped in AVPacket"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_UNKNOWN", :type "CXType_Int", :name "AV_FIELD_UNKNOWN", :value 0, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_PROGRESSIVE", :type "CXType_Int", :name "AV_FIELD_PROGRESSIVE", :value 1, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_TT", :type "CXType_Int", :name "AV_FIELD_TT", :value 2, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_BB", :type "CXType_Int", :name "AV_FIELD_BB", :value 3, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_TB", :type "CXType_Int", :name "AV_FIELD_TB", :value 4, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_FIELD_BT", :type "CXType_Int", :name "AV_FIELD_BT", :value 5, :enum "AVFieldOrder", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_PALETTE", :type "CXType_Int", :name "AV_PKT_DATA_PALETTE", :value 0, :enum "AVPacketSideDataType", :raw-comment "/**\n     * An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE\n     * bytes worth of palette. This side data signals that a new palette is\n     * present.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_NEW_EXTRADATA", :type "CXType_Int", :name "AV_PKT_DATA_NEW_EXTRADATA", :value 1, :enum "AVPacketSideDataType", :raw-comment "/**\n     * The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format\n     * that the extradata buffer was changed and the receiving side should\n     * act upon it appropriately. The new extradata is embedded in the side\n     * data buffer and should be immediately used for processing the current\n     * frame or packet.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_PARAM_CHANGE", :type "CXType_Int", :name "AV_PKT_DATA_PARAM_CHANGE", :value 2, :enum "AVPacketSideDataType", :raw-comment "/**\n     * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:\n     * @code\n     * u32le param_flags\n     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)\n     *     s32le channel_count\n     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)\n     *     u64le channel_layout\n     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)\n     *     s32le sample_rate\n     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)\n     *     s32le width\n     *     s32le height\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_H263_MB_INFO", :type "CXType_Int", :name "AV_PKT_DATA_H263_MB_INFO", :value 3, :enum "AVPacketSideDataType", :raw-comment "/**\n     * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of\n     * structures with info about macroblocks relevant to splitting the\n     * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).\n     * That is, it does not necessarily contain info about all macroblocks,\n     * as long as the distance between macroblocks in the info is smaller\n     * than the target payload size.\n     * Each MB info structure is 12 bytes, and is laid out as follows:\n     * @code\n     * u32le bit offset from the start of the packet\n     * u8    current quantizer at the start of the macroblock\n     * u8    GOB number\n     * u16le macroblock address within the GOB\n     * u8    horizontal MV predictor\n     * u8    vertical MV predictor\n     * u8    horizontal MV predictor for block number 3\n     * u8    vertical MV predictor for block number 3\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_REPLAYGAIN", :type "CXType_Int", :name "AV_PKT_DATA_REPLAYGAIN", :value 4, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data should be associated with an audio stream and contains\n     * ReplayGain information in form of the AVReplayGain struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_DISPLAYMATRIX", :type "CXType_Int", :name "AV_PKT_DATA_DISPLAYMATRIX", :value 5, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data contains a 3x3 transformation matrix describing an affine\n     * transformation that needs to be applied to the decoded video frames for\n     * correct presentation.\n     *\n     * See libavutil/display.h for a detailed description of the data.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_STEREO3D", :type "CXType_Int", :name "AV_PKT_DATA_STEREO3D", :value 6, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data should be associated with a video stream and contains\n     * Stereoscopic 3D information in form of the AVStereo3D struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_AUDIO_SERVICE_TYPE", :type "CXType_Int", :name "AV_PKT_DATA_AUDIO_SERVICE_TYPE", :value 7, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data should be associated with an audio stream and corresponds\n     * to enum AVAudioServiceType.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_QUALITY_STATS", :type "CXType_Int", :name "AV_PKT_DATA_QUALITY_STATS", :value 8, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data contains quality related information from the encoder.\n     * @code\n     * u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).\n     * u8    picture type\n     * u8    error count\n     * u16   reserved\n     * u64le[error count] sum of squared differences between encoder in and output\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_FALLBACK_TRACK", :type "CXType_Int", :name "AV_PKT_DATA_FALLBACK_TRACK", :value 9, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data contains an integer value representing the stream index\n     * of a \"fallback\" track.  A fallback track indicates an alternate\n     * track to use when the current track can not be decoded for some reason.\n     * e.g. no decoder available for codec.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_CPB_PROPERTIES", :type "CXType_Int", :name "AV_PKT_DATA_CPB_PROPERTIES", :value 10, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data corresponds to the AVCPBProperties struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_SKIP_SAMPLES", :type "CXType_Int", :name "AV_PKT_DATA_SKIP_SAMPLES", :value 11, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Recommmends skipping the specified number of samples\n     * @code\n     * u32le number of samples to skip from start of this packet\n     * u32le number of samples to skip from end of this packet\n     * u8    reason for start skip\n     * u8    reason for end   skip (0=padding silence, 1=convergence)\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_JP_DUALMONO", :type "CXType_Int", :name "AV_PKT_DATA_JP_DUALMONO", :value 12, :enum "AVPacketSideDataType", :raw-comment "/**\n     * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that\n     * the packet may contain \"dual mono\" audio specific to Japanese DTV\n     * and if it is true, recommends only the selected channel to be used.\n     * @code\n     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_STRINGS_METADATA", :type "CXType_Int", :name "AV_PKT_DATA_STRINGS_METADATA", :value 13, :enum "AVPacketSideDataType", :raw-comment "/**\n     * A list of zero terminated key/value strings. There is no end marker for\n     * the list, so it is required to rely on the side data size to stop.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_SUBTITLE_POSITION", :type "CXType_Int", :name "AV_PKT_DATA_SUBTITLE_POSITION", :value 14, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Subtitle event position\n     * @code\n     * u32le x1\n     * u32le y1\n     * u32le x2\n     * u32le y2\n     * @endcode\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL", :type "CXType_Int", :name "AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL", :value 15, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Data found in BlockAdditional element of matroska container. There is\n     * no end marker for the data, so it is required to rely on the side data\n     * size to recognize the end. 8 byte id (as found in BlockAddId) followed\n     * by data.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_WEBVTT_IDENTIFIER", :type "CXType_Int", :name "AV_PKT_DATA_WEBVTT_IDENTIFIER", :value 16, :enum "AVPacketSideDataType", :raw-comment "/**\n     * The optional first identifier line of a WebVTT cue.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_WEBVTT_SETTINGS", :type "CXType_Int", :name "AV_PKT_DATA_WEBVTT_SETTINGS", :value 17, :enum "AVPacketSideDataType", :raw-comment "/**\n     * The optional settings (rendering instructions) that immediately\n     * follow the timestamp specifier of a WebVTT cue.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_METADATA_UPDATE", :type "CXType_Int", :name "AV_PKT_DATA_METADATA_UPDATE", :value 18, :enum "AVPacketSideDataType", :raw-comment "/**\n     * A list of zero terminated key/value strings. There is no end marker for\n     * the list, so it is required to rely on the side data size to stop. This\n     * side data includes updated metadata which appeared in the stream.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_MPEGTS_STREAM_ID", :type "CXType_Int", :name "AV_PKT_DATA_MPEGTS_STREAM_ID", :value 19, :enum "AVPacketSideDataType", :raw-comment "/**\n     * MPEGTS stream ID as uint8_t, this is required to pass the stream ID\n     * information from the demuxer to the corresponding muxer.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_MASTERING_DISPLAY_METADATA", :type "CXType_Int", :name "AV_PKT_DATA_MASTERING_DISPLAY_METADATA", :value 20, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Mastering display metadata (based on SMPTE-2086:2014). This metadata\n     * should be associated with a video stream and contains data in the form\n     * of the AVMasteringDisplayMetadata struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_SPHERICAL", :type "CXType_Int", :name "AV_PKT_DATA_SPHERICAL", :value 21, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data should be associated with a video stream and corresponds\n     * to the AVSphericalMapping structure.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_CONTENT_LIGHT_LEVEL", :type "CXType_Int", :name "AV_PKT_DATA_CONTENT_LIGHT_LEVEL", :value 22, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Content light level (based on CTA-861.3). This metadata should be\n     * associated with a video stream and contains data in the form of the\n     * AVContentLightMetadata struct.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_A53_CC", :type "CXType_Int", :name "AV_PKT_DATA_A53_CC", :value 23, :enum "AVPacketSideDataType", :raw-comment "/**\n     * ATSC A53 Part 4 Closed Captions. This metadata should be associated with\n     * a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.\n     * The number of bytes of CC data is AVPacketSideData.size.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_ENCRYPTION_INIT_INFO", :type "CXType_Int", :name "AV_PKT_DATA_ENCRYPTION_INIT_INFO", :value 24, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data is encryption initialization data.\n     * The format is not part of ABI, use av_encryption_init_info_* methods to\n     * access.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_ENCRYPTION_INFO", :type "CXType_Int", :name "AV_PKT_DATA_ENCRYPTION_INFO", :value 25, :enum "AVPacketSideDataType", :raw-comment "/**\n     * This side data contains encryption info for how to decrypt the packet.\n     * The format is not part of ABI, use av_encryption_info_* methods to access.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_AFD", :type "CXType_Int", :name "AV_PKT_DATA_AFD", :value 26, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Active Format Description data consisting of a single byte as specified\n     * in ETSI TS 101 154 using AVActiveFormatDescription enum.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_PRFT", :type "CXType_Int", :name "AV_PKT_DATA_PRFT", :value 27, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Producer Reference Time data corresponding to the AVProducerReferenceTime struct,\n     * usually exported by some encoders (on demand through the prft flag set in the\n     * AVCodecContext export_side_data field).\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_ICC_PROFILE", :type "CXType_Int", :name "AV_PKT_DATA_ICC_PROFILE", :value 28, :enum "AVPacketSideDataType", :raw-comment "/**\n     * ICC profile data consisting of an opaque octet buffer following the\n     * format described by ISO 15076-1.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_DOVI_CONF", :type "CXType_Int", :name "AV_PKT_DATA_DOVI_CONF", :value 29, :enum "AVPacketSideDataType", :raw-comment "/**\n     * DOVI configuration\n     * ref:\n     * dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2\n     * dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3\n     * Tags are stored in struct AVDOVIDecoderConfigurationRecord.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_S12M_TIMECODE", :type "CXType_Int", :name "AV_PKT_DATA_S12M_TIMECODE", :value 30, :enum "AVPacketSideDataType", :raw-comment "/**\n     * Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t\n     * where the first uint32_t describes how many (1-3) of the other timecodes are used.\n     * The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n     * function in libavutil/timecode.h.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PKT_DATA_NB", :type "CXType_Int", :name "AV_PKT_DATA_NB", :value 31, :enum "AVPacketSideDataType", :raw-comment "/**\n     * The number of side data types.\n     * This is not part of the public API/ABI in the sense that it may\n     * change when new side data types are added.\n     * This must stay the last enum value.\n     * If its value becomes huge, some code using it\n     * needs to be updated as it assumes it to be smaller than other limits.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT", :type "CXType_Int", :name "AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT", :value 1, :enum "AVSideDataParamChangeFlags", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT", :type "CXType_Int", :name "AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT", :value 2, :enum "AVSideDataParamChangeFlags", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE", :type "CXType_Int", :name "AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE", :value 4, :enum "AVSideDataParamChangeFlags", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS", :type "CXType_Int", :name "AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS", :value 8, :enum "AVSideDataParamChangeFlags", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX", :type "CXType_Int", :name "AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX", :value 1, :enum "", :raw-comment "/**\n     * The codec supports this format via the hw_device_ctx interface.\n     *\n     * When selecting this format, AVCodecContext.hw_device_ctx should\n     * have been set to a device of the specified type before calling\n     * avcodec_open2().\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX", :type "CXType_Int", :name "AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX", :value 2, :enum "", :raw-comment "/**\n     * The codec supports this format via the hw_frames_ctx interface.\n     *\n     * When selecting this format for a decoder,\n     * AVCodecContext.hw_frames_ctx should be set to a suitable frames\n     * context inside the get_format() callback.  The frames context\n     * must have been created on a device of the specified type.\n     *\n     * When selecting this format for an encoder,\n     * AVCodecContext.hw_frames_ctx should be set to the context which\n     * will be used for the input frames before calling avcodec_open2().\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_HW_CONFIG_METHOD_INTERNAL", :type "CXType_Int", :name "AV_CODEC_HW_CONFIG_METHOD_INTERNAL", :value 4, :enum "", :raw-comment "/**\n     * The codec supports this format by some internal method.\n     *\n     * This format can be selected without any additional configuration -\n     * no device or frames context is required.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_CODEC_HW_CONFIG_METHOD_AD_HOC", :type "CXType_Int", :name "AV_CODEC_HW_CONFIG_METHOD_AD_HOC", :value 8, :enum "", :raw-comment "/**\n     * The codec supports this format by some ad-hoc method.\n     *\n     * Additional settings and/or function calls are required.  See the\n     * codec-specific documentation for details.  (Methods requiring\n     * this sort of configuration are deprecated and others should be\n     * used in preference.)\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_NONE", :type "CXType_Int", :name "AVDISCARD_NONE", :value -16, :enum "AVDiscard", :raw-comment "///< discard nothing"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_DEFAULT", :type "CXType_Int", :name "AVDISCARD_DEFAULT", :value 0, :enum "AVDiscard", :raw-comment "///< discard useless packets like 0 size packets in avi"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_NONREF", :type "CXType_Int", :name "AVDISCARD_NONREF", :value 8, :enum "AVDiscard", :raw-comment "///< discard all non reference"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_BIDIR", :type "CXType_Int", :name "AVDISCARD_BIDIR", :value 16, :enum "AVDiscard", :raw-comment "///< discard all bidirectional frames"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_NONINTRA", :type "CXType_Int", :name "AVDISCARD_NONINTRA", :value 24, :enum "AVDiscard", :raw-comment "///< discard all non intra frames"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_NONKEY", :type "CXType_Int", :name "AVDISCARD_NONKEY", :value 32, :enum "AVDiscard", :raw-comment "///< discard all frames except keyframes"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVDISCARD_ALL", :type "CXType_Int", :name "AVDISCARD_ALL", :value 48, :enum "AVDiscard", :raw-comment "///< discard all"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_MAIN", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_MAIN", :value 0, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_EFFECTS", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_EFFECTS", :value 1, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED", :value 2, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED", :value 3, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_DIALOGUE", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_DIALOGUE", :value 4, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_COMMENTARY", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_COMMENTARY", :value 5, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_EMERGENCY", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_EMERGENCY", :value 6, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_VOICE_OVER", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_VOICE_OVER", :value 7, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_KARAOKE", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_KARAOKE", :value 8, :enum "AVAudioServiceType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_AUDIO_SERVICE_TYPE_NB", :type "CXType_Int", :name "AV_AUDIO_SERVICE_TYPE_NB", :value 9, :enum "AVAudioServiceType", :raw-comment "///< Not part of ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "SUBTITLE_NONE", :type "CXType_Int", :name "SUBTITLE_NONE", :value 0, :enum "AVSubtitleType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SUBTITLE_BITMAP", :type "CXType_Int", :name "SUBTITLE_BITMAP", :value 1, :enum "AVSubtitleType", :raw-comment "///< A bitmap, pict will be set"} {:kind "CXCursor_EnumConstantDecl", :spelling "SUBTITLE_TEXT", :type "CXType_Int", :name "SUBTITLE_TEXT", :value 2, :enum "AVSubtitleType", :raw-comment "/**\n     * Plain text, the text field must be set by the decoder and is\n     * authoritative. ass and pict fields may contain approximations.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SUBTITLE_ASS", :type "CXType_Int", :name "SUBTITLE_ASS", :value 3, :enum "AVSubtitleType", :raw-comment "/**\n     * Formatted text, the ass field must be set by the decoder and is\n     * authoritative. pict and text fields may contain approximations.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_STRUCTURE_UNKNOWN", :type "CXType_Int", :name "AV_PICTURE_STRUCTURE_UNKNOWN", :value 0, :enum "AVPictureStructure", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_STRUCTURE_TOP_FIELD", :type "CXType_Int", :name "AV_PICTURE_STRUCTURE_TOP_FIELD", :value 1, :enum "AVPictureStructure", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_STRUCTURE_BOTTOM_FIELD", :type "CXType_Int", :name "AV_PICTURE_STRUCTURE_BOTTOM_FIELD", :value 2, :enum "AVPictureStructure", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_PICTURE_STRUCTURE_FRAME", :type "CXType_Int", :name "AV_PICTURE_STRUCTURE_FRAME", :value 3, :enum "AVPictureStructure", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_LOCK_CREATE", :type "CXType_Int", :name "AV_LOCK_CREATE", :value 0, :enum "AVLockOp", :raw-comment "///< Create a mutex"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_LOCK_OBTAIN", :type "CXType_Int", :name "AV_LOCK_OBTAIN", :value 1, :enum "AVLockOp", :raw-comment "///< Lock the mutex"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_LOCK_RELEASE", :type "CXType_Int", :name "AV_LOCK_RELEASE", :value 2, :enum "AVLockOp", :raw-comment "///< Unlock the mutex"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_LOCK_DESTROY", :type "CXType_Int", :name "AV_LOCK_DESTROY", :value 3, :enum "AVLockOp", :raw-comment "///< Free mutex resources"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_NONE", :type "CXType_Int", :name "AVSTREAM_PARSE_NONE", :value 0, :enum "AVStreamParseType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_FULL", :type "CXType_Int", :name "AVSTREAM_PARSE_FULL", :value 1, :enum "AVStreamParseType", :raw-comment "/**< full parsing and repack */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_HEADERS", :type "CXType_Int", :name "AVSTREAM_PARSE_HEADERS", :value 2, :enum "AVStreamParseType", :raw-comment "/**< Only parse headers, do not repack. */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_TIMESTAMPS", :type "CXType_Int", :name "AVSTREAM_PARSE_TIMESTAMPS", :value 3, :enum "AVStreamParseType", :raw-comment "/**< full parsing and interpolation of timestamps for frames not starting on a packet boundary */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_FULL_ONCE", :type "CXType_Int", :name "AVSTREAM_PARSE_FULL_ONCE", :value 4, :enum "AVStreamParseType", :raw-comment "/**< full parsing and repack of the first frame only, only implemented for H.264 currently */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVSTREAM_PARSE_FULL_RAW", :type "CXType_Int", :name "AVSTREAM_PARSE_FULL_RAW", :value 5, :enum "AVStreamParseType", :raw-comment "/**< full parsing and repack with timestamp and position generation by parser for raw\n                                    this assumes that each packet in the file contains no demuxer level headers and\n                                    just codec level data, otherwise position generation would fail */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_DURATION_FROM_PTS", :type "CXType_Int", :name "AVFMT_DURATION_FROM_PTS", :value 0, :enum "AVDurationEstimationMethod", :raw-comment "///< Duration accurately estimated from PTSes"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_DURATION_FROM_STREAM", :type "CXType_Int", :name "AVFMT_DURATION_FROM_STREAM", :value 1, :enum "AVDurationEstimationMethod", :raw-comment "///< Duration estimated from a stream with a known duration"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_DURATION_FROM_BITRATE", :type "CXType_Int", :name "AVFMT_DURATION_FROM_BITRATE", :value 2, :enum "AVDurationEstimationMethod", :raw-comment "///< Duration estimated from bitrate (less accurate)"} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_TBCF_AUTO", :type "CXType_Int", :name "AVFMT_TBCF_AUTO", :value -1, :enum "AVTimebaseSource", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_TBCF_DECODER", :type "CXType_Int", :name "AVFMT_TBCF_DECODER", :value 0, :enum "AVTimebaseSource", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_TBCF_DEMUXER", :type "CXType_Int", :name "AVFMT_TBCF_DEMUXER", :value 1, :enum "AVTimebaseSource", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AVFMT_TBCF_R_FRAMERATE", :type "CXType_Int", :name "AVFMT_TBCF_R_FRAMERATE", :value 2, :enum "AVTimebaseSource", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_NONE", :type "CXType_Int", :name "AV_APP_TO_DEV_NONE", :value 1313820229, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Dummy message.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_WINDOW_SIZE", :type "CXType_Int", :name "AV_APP_TO_DEV_WINDOW_SIZE", :value 1195724621, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Window size change message.\n     *\n     * Message is sent to the device every time the application changes the size\n     * of the window device renders to.\n     * Message should also be sent right after window is created.\n     *\n     * data: AVDeviceRect: new window size.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_WINDOW_REPAINT", :type "CXType_Int", :name "AV_APP_TO_DEV_WINDOW_REPAINT", :value 1380274241, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Repaint request message.\n     *\n     * Message is sent to the device when window has to be repainted.\n     *\n     * data: AVDeviceRect: area required to be repainted.\n     *       NULL: whole area is required to be repainted.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_PAUSE", :type "CXType_Int", :name "AV_APP_TO_DEV_PAUSE", :value 1346458912, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Request pause/play.\n     *\n     * Application requests pause/unpause playback.\n     * Mostly usable with devices that have internal buffer.\n     * By default devices are not paused.\n     *\n     * data: NULL\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_PLAY", :type "CXType_Int", :name "AV_APP_TO_DEV_PLAY", :value 1347174745, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Request pause/play.\n     *\n     * Application requests pause/unpause playback.\n     * Mostly usable with devices that have internal buffer.\n     * By default devices are not paused.\n     *\n     * data: NULL\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_TOGGLE_PAUSE", :type "CXType_Int", :name "AV_APP_TO_DEV_TOGGLE_PAUSE", :value 1346458964, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Request pause/play.\n     *\n     * Application requests pause/unpause playback.\n     * Mostly usable with devices that have internal buffer.\n     * By default devices are not paused.\n     *\n     * data: NULL\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_SET_VOLUME", :type "CXType_Int", :name "AV_APP_TO_DEV_SET_VOLUME", :value 1398165324, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Volume control message.\n     *\n     * Set volume level. It may be device-dependent if volume\n     * is changed per stream or system wide. Per stream volume\n     * change is expected when possible.\n     *\n     * data: double: new volume with range of 0.0 - 1.0.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_MUTE", :type "CXType_Int", :name "AV_APP_TO_DEV_MUTE", :value 541939028, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Mute control messages.\n     *\n     * Change mute state. It may be device-dependent if mute status\n     * is changed per stream or system wide. Per stream mute status\n     * change is expected when possible.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_UNMUTE", :type "CXType_Int", :name "AV_APP_TO_DEV_UNMUTE", :value 1431131476, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Mute control messages.\n     *\n     * Change mute state. It may be device-dependent if mute status\n     * is changed per stream or system wide. Per stream mute status\n     * change is expected when possible.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_TOGGLE_MUTE", :type "CXType_Int", :name "AV_APP_TO_DEV_TOGGLE_MUTE", :value 1414354260, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Mute control messages.\n     *\n     * Change mute state. It may be device-dependent if mute status\n     * is changed per stream or system wide. Per stream mute status\n     * change is expected when possible.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_GET_VOLUME", :type "CXType_Int", :name "AV_APP_TO_DEV_GET_VOLUME", :value 1196838732, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Get volume/mute messages.\n     *\n     * Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or\n     * AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_APP_TO_DEV_GET_MUTE", :type "CXType_Int", :name "AV_APP_TO_DEV_GET_MUTE", :value 1196250452, :enum "AVAppToDevMessageType", :raw-comment "/**\n     * Get volume/mute messages.\n     *\n     * Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or\n     * AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_NONE", :type "CXType_Int", :name "AV_DEV_TO_APP_NONE", :value 1313820229, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Dummy message.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_CREATE_WINDOW_BUFFER", :type "CXType_Int", :name "AV_DEV_TO_APP_CREATE_WINDOW_BUFFER", :value 1111708229, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Create window buffer message.\n     *\n     * Device requests to create a window buffer. Exact meaning is device-\n     * and application-dependent. Message is sent before rendering first\n     * frame and all one-shot initializations should be done here.\n     * Application is allowed to ignore preferred window buffer size.\n     *\n     * @note: Application is obligated to inform about window buffer size\n     *        with AV_APP_TO_DEV_WINDOW_SIZE message.\n     *\n     * data: AVDeviceRect: preferred size of the window buffer.\n     *       NULL: no preferred size of the window buffer.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER", :type "CXType_Int", :name "AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER", :value 1112560197, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Prepare window buffer message.\n     *\n     * Device requests to prepare a window buffer for rendering.\n     * Exact meaning is device- and application-dependent.\n     * Message is sent before rendering of each frame.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER", :type "CXType_Int", :name "AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER", :value 1111771475, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Display window buffer message.\n     *\n     * Device requests to display a window buffer.\n     * Message is sent when new frame is ready to be displayed.\n     * Usually buffers need to be swapped in handler of this message.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER", :type "CXType_Int", :name "AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER", :value 1111770451, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Destroy window buffer message.\n     *\n     * Device requests to destroy a window buffer.\n     * Message is sent when device is about to be destroyed and window\n     * buffer is not required anymore.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_BUFFER_OVERFLOW", :type "CXType_Int", :name "AV_DEV_TO_APP_BUFFER_OVERFLOW", :value 1112491596, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Buffer fullness status messages.\n     *\n     * Device signals buffer overflow/underflow.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_BUFFER_UNDERFLOW", :type "CXType_Int", :name "AV_DEV_TO_APP_BUFFER_UNDERFLOW", :value 1112884812, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Buffer fullness status messages.\n     *\n     * Device signals buffer overflow/underflow.\n     *\n     * data: NULL.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_BUFFER_READABLE", :type "CXType_Int", :name "AV_DEV_TO_APP_BUFFER_READABLE", :value 1112687648, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Buffer readable/writable.\n     *\n     * Device informs that buffer is readable/writable.\n     * When possible, device informs how many bytes can be read/write.\n     *\n     * @warning Device may not inform when number of bytes than can be read/write changes.\n     *\n     * data: int64_t: amount of bytes available to read/write.\n     *       NULL: amount of bytes available to read/write is not known.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_BUFFER_WRITABLE", :type "CXType_Int", :name "AV_DEV_TO_APP_BUFFER_WRITABLE", :value 1113018912, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Buffer readable/writable.\n     *\n     * Device informs that buffer is readable/writable.\n     * When possible, device informs how many bytes can be read/write.\n     *\n     * @warning Device may not inform when number of bytes than can be read/write changes.\n     *\n     * data: int64_t: amount of bytes available to read/write.\n     *       NULL: amount of bytes available to read/write is not known.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_MUTE_STATE_CHANGED", :type "CXType_Int", :name "AV_DEV_TO_APP_MUTE_STATE_CHANGED", :value 1129141588, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Mute state change message.\n     *\n     * Device informs that mute state has changed.\n     *\n     * data: int: 0 for not muted state, non-zero for muted state.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED", :type "CXType_Int", :name "AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED", :value 1129729868, :enum "AVDevToAppMessageType", :raw-comment "/**\n     * Volume level change message.\n     *\n     * Device informs that volume level has changed.\n     *\n     * data: double: new volume with range of 0.0 - 1.0.\n     */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NONE", :type "CXType_Int", :name "SWR_DITHER_NONE", :value 0, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_RECTANGULAR", :type "CXType_Int", :name "SWR_DITHER_RECTANGULAR", :value 1, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_TRIANGULAR", :type "CXType_Int", :name "SWR_DITHER_TRIANGULAR", :value 2, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_TRIANGULAR_HIGHPASS", :type "CXType_Int", :name "SWR_DITHER_TRIANGULAR_HIGHPASS", :value 3, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS", :type "CXType_Int", :name "SWR_DITHER_NS", :value 64, :enum "SwrDitherType", :raw-comment "///< not part of API/ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_LIPSHITZ", :type "CXType_Int", :name "SWR_DITHER_NS_LIPSHITZ", :value 65, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_F_WEIGHTED", :type "CXType_Int", :name "SWR_DITHER_NS_F_WEIGHTED", :value 66, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_MODIFIED_E_WEIGHTED", :type "CXType_Int", :name "SWR_DITHER_NS_MODIFIED_E_WEIGHTED", :value 67, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_IMPROVED_E_WEIGHTED", :type "CXType_Int", :name "SWR_DITHER_NS_IMPROVED_E_WEIGHTED", :value 68, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_SHIBATA", :type "CXType_Int", :name "SWR_DITHER_NS_SHIBATA", :value 69, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_LOW_SHIBATA", :type "CXType_Int", :name "SWR_DITHER_NS_LOW_SHIBATA", :value 70, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NS_HIGH_SHIBATA", :type "CXType_Int", :name "SWR_DITHER_NS_HIGH_SHIBATA", :value 71, :enum "SwrDitherType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_DITHER_NB", :type "CXType_Int", :name "SWR_DITHER_NB", :value 72, :enum "SwrDitherType", :raw-comment "///< not part of API/ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_ENGINE_SWR", :type "CXType_Int", :name "SWR_ENGINE_SWR", :value 0, :enum "SwrEngine", :raw-comment "/**< SW Resampler */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_ENGINE_SOXR", :type "CXType_Int", :name "SWR_ENGINE_SOXR", :value 1, :enum "SwrEngine", :raw-comment "/**< SoX Resampler */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_ENGINE_NB", :type "CXType_Int", :name "SWR_ENGINE_NB", :value 2, :enum "SwrEngine", :raw-comment "///< not part of API/ABI"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_FILTER_TYPE_CUBIC", :type "CXType_Int", :name "SWR_FILTER_TYPE_CUBIC", :value 0, :enum "SwrFilterType", :raw-comment "/**< Cubic */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_FILTER_TYPE_BLACKMAN_NUTTALL", :type "CXType_Int", :name "SWR_FILTER_TYPE_BLACKMAN_NUTTALL", :value 1, :enum "SwrFilterType", :raw-comment "/**< Blackman Nuttall windowed sinc */"} {:kind "CXCursor_EnumConstantDecl", :spelling "SWR_FILTER_TYPE_KAISER", :type "CXType_Int", :name "SWR_FILTER_TYPE_KAISER", :value 2, :enum "SwrFilterType", :raw-comment "/**< Kaiser windowed sinc */"} {:kind "CXCursor_EnumConstantDecl", :spelling "DFT_R2C", :type "CXType_Int", :name "DFT_R2C", :value 0, :enum "RDFTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "IDFT_C2R", :type "CXType_Int", :name "IDFT_C2R", :value 1, :enum "RDFTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "IDFT_R2C", :type "CXType_Int", :name "IDFT_R2C", :value 2, :enum "RDFTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DFT_C2R", :type "CXType_Int", :name "DFT_C2R", :value 3, :enum "RDFTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DCT_II", :type "CXType_Int", :name "DCT_II", :value 0, :enum "DCTTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DCT_III", :type "CXType_Int", :name "DCT_III", :value 1, :enum "DCTTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DCT_I", :type "CXType_Int", :name "DCT_I", :value 2, :enum "DCTTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DST_I", :type "CXType_Int", :name "DST_I", :value 3, :enum "DCTTransformType", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_SEQ_HEADER", :type "CXType_Int", :name "DIRAC_PCODE_SEQ_HEADER", :value 0, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_END_SEQ", :type "CXType_Int", :name "DIRAC_PCODE_END_SEQ", :value 16, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_AUX", :type "CXType_Int", :name "DIRAC_PCODE_AUX", :value 32, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_PAD", :type "CXType_Int", :name "DIRAC_PCODE_PAD", :value 48, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_PICTURE_CODED", :type "CXType_Int", :name "DIRAC_PCODE_PICTURE_CODED", :value 8, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_PICTURE_RAW", :type "CXType_Int", :name "DIRAC_PCODE_PICTURE_RAW", :value 72, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_PICTURE_LOW_DEL", :type "CXType_Int", :name "DIRAC_PCODE_PICTURE_LOW_DEL", :value 200, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_PICTURE_HQ", :type "CXType_Int", :name "DIRAC_PCODE_PICTURE_HQ", :value 232, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTER_NOREF_CO1", :type "CXType_Int", :name "DIRAC_PCODE_INTER_NOREF_CO1", :value 10, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTER_NOREF_CO2", :type "CXType_Int", :name "DIRAC_PCODE_INTER_NOREF_CO2", :value 9, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTER_REF_CO1", :type "CXType_Int", :name "DIRAC_PCODE_INTER_REF_CO1", :value 13, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTER_REF_CO2", :type "CXType_Int", :name "DIRAC_PCODE_INTER_REF_CO2", :value 14, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTRA_REF_CO", :type "CXType_Int", :name "DIRAC_PCODE_INTRA_REF_CO", :value 12, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTRA_REF_RAW", :type "CXType_Int", :name "DIRAC_PCODE_INTRA_REF_RAW", :value 76, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_INTRA_REF_PICT", :type "CXType_Int", :name "DIRAC_PCODE_INTRA_REF_PICT", :value 204, :enum "DiracParseCodes", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :spelling "DIRAC_PCODE_MAGIC", :type "CXType_Int", :name "DIRAC_PCODE_MAGIC", :value 1111638852, :enum "DiracParseCodes", :raw-comment nil})}